{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 20731b1361f1f47115ff","webpack:///./index.js","webpack:///./~/babel-runtime/helpers/classCallCheck.js","webpack:///./~/dom4/build/dom4.max.js","webpack:///./shaders/noise.frag","webpack:///./shaders/main.frag","webpack:///./shaders/main.vert","webpack:///./midday.jpg","webpack:///./~/twgl-base.js/dist/2.x/twgl.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck2","_classCallCheck3","_noise","_noise2","_main","_main2","_main3","_main4","_midday","_midday2","_twglBase","arrays","position","numComponents","data","AnimatedBackground","_this","this","updateMouse","event","touches","length","clientX","clientY","pos","gl","canvas","height","width","delta","Math","round","subsideScale","abs","render","time","noiseUniforms","Period","resolution","uniforms","Frequency","Amplitude","Intensity","u_texSampler","texture","u_noiseSampler","framebufferInfo","attachments","document","hasFocus","resizeCanvasToDisplaySize","bindFramebufferInfo","useProgram","noiseProgramInfo","program","setBuffersAndAttributes","bufferInfo","setUniforms","drawBufferInfo","programInfo","requestAnimationFrame","createElement","body","appendChild","addEventListener","getWebGLContext","createProgramInfo","createBufferInfoFromArrays","createFramebufferInfo","createTexture","src","wrap","CLAMP_TO_EDGE","instance","Constructor","TypeError","window","createDocumentFragment","nodeName","enoughArguments","name","Error","mutationMacro","nodes","textNodeIfString","fragment","list","slice","i","node","createTextNode","head","property","TemporaryPrototype","TemporaryTokenList","wrapVerifyToken","hOP","Object","prototype","hasOwnProperty","defineProperty","object","descriptor","value","__defineGetter__","get","__defineSetter__","set","indexOf","verifyToken","token","spaces","test","DOMTokenList","noClassName","className","getAttribute","isSVG","baseVal","replace","trim","properties","push","apply","split","_isSVG","_","classListDescriptor","uid","concat","random","Date","SPACE","CLASS_LIST","toggle","force","contains","remove","undefined","add","DocumentFragmentPrototype","DocumentFragment","Node","NodePrototype","Element","CharacterData","CharacterDataPrototype","DocumentType","DocumentTypePrototype","ElementPrototype","HTMLElement","HTMLSelectElement","constructor","selectRemove","ShadowRoot","SVGElement","idSpaceFinder","idSpaceReplacer","createQueryMethod","methodName","createArray","css","a","query","nl","selectors","parentNode","join","setAttribute","removeAttribute","Array","addQueryAndAll","where","queryAll","matchesSelector","webkitMatchesSelector","khtmlMatchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","selector","querySelectorAll","matches","firstChild","arguments","insertBefore","nextSibling","replaceWith","replaceChild","removeChild","o_O","j","item","splice","toString","documentElement","original","el","getElementsByTagName","raf","rAF","cAF","cancelAnimationFrame","prefixes","callback","goOn","setTimeout","clearTimeout","CustomEvent","eventName","defaultInitDict","type","eventInitDict","createEvent","initCustomEvent","bubbles","cancelable","detail","initEvent","Event","$Event","init","out","KeyboardEvent","$KeyboardEvent","getModifier","keys","withDefaults","target","source","key","withInitValues","defaults","args","eventType","ctrlKey","shiftKey","altKey","metaKey","altGraphKey","modifiers","initType","String","chr","char","location","keyCode","charCodeAt","charCode","repeat","locale","view","which","initKeyEvent","initKeyboardEvent","navigator","language","e","keyIdentifier","keyLocation","MouseEvent","$MouseEvent","initMouseEvent","screenX","screenY","button","relatedTarget","global","Dict","createEventListener","options","eventListener","once","currentTarget","removeEventListener","removed","passive","preventDefault","handleEvent","capture","DOMMap","WeakMap","dispatch","ce","shouldDrop","drop","dispatched","dispatchEvent","Handler","counter","__ce__","delete","v","has","create","augment","dE","aEL","rEL","increment","getListenerKey","createAEL","handler","tmp","info","dm","createREL","proto","EventTarget","Text","HTMLDocument","Window","XMLHttpRequest","self","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","twgl","notrequirebecasebrowserifymessesupjs","notrequirebecasebrowserifymessesup","define","undef","hasProp","prop","hasOwn","normalize","baseName","nameParts","nameSegment","mapValue","foundMap","lastIndex","foundI","foundStarMap","starI","part","baseParts","map","config","starMap","charAt","nodeIdCompat","jsSuffixRegExp","substring","makeRequire","relName","forceSync","aps","req","makeNormalize","makeLoad","depName","defined","callDep","waiting","defining","main","splitPrefix","prefix","index","makeConfig","makeMap","handlers","plugin","parts","f","n","pr","uri","deps","cjsModule","ret","usingExports","callbackType","load","alt","cfg","_defined","amd","jQuery","getGLTypeForTypedArray","typedArray","Int8Array","BYTE","Uint8Array","UNSIGNED_BYTE","Uint8ClampedArray","Int16Array","SHORT","Uint16Array","UNSIGNED_SHORT","Int32Array","INT","Uint32Array","UNSIGNED_INT","Float32Array","FLOAT","getTypedArrayTypeForGLType","isArrayBuffer","buffer","ArrayBuffer","shallowCopy","dst","forEach","copyNamedProperties","names","copyExistingProperties","getVersionAsNumber","parseFloat","getParameter","VERSION","substr","isWebGL2","isWebGL1","version","error","console","bind","warn","typedArrays","utils","setAttributePrefix","attribPrefix","setDefaults","newDefaults","setBufferFromTypedArray","array","drawType","bindBuffer","bufferData","STATIC_DRAW","createBufferFromTypedArray","WebGLBuffer","ARRAY_BUFFER","createBuffer","isIndices","getNormalizationForTypedArray","getArray","guessNumComponentsFromName","texcoordRE","colorRE","getNumComponents","arrayName","size","makeTypedArray","isArray","Type","createAttribsFromArrays","attribs","attribName","attrib","stride","offset","setAttribInfoBufferFromArray","attribInfo","bufferSubData","indices","ELEMENT_ARRAY_BUFFER","numElements","elementType","getNumElementsFromNonIndexedArrays","createBufferFromArray","createBuffersFromArrays","buffers","createVertexArrayInfo","programInfos","vao","createVertexArray","bindVertexArray","vertexArrayObject","positionKeys","ii","setDefaults_","getNumComponents_","getArray_","getBindPointForSamplerType","typeMap","bindPoint","floatSetter","uniform1f","floatArraySetter","uniform1fv","floatVec2Setter","uniform2fv","floatVec3Setter","uniform3fv","floatVec4Setter","uniform4fv","intSetter","uniform1i","intArraySetter","uniform1iv","intVec2Setter","uniform2iv","intVec3Setter","uniform3iv","intVec4Setter","uniform4iv","uintSetter","uniform1ui","uintArraySetter","uniform1uiv","uintVec2Setter","uniform2uiv","uintVec3Setter","uniform3uiv","uintVec4Setter","uniform4uiv","floatMat2Setter","uniformMatrix2fv","floatMat3Setter","uniformMatrix3fv","floatMat4Setter","uniformMatrix4fv","floatMat23Setter","uniformMatrix2x3fv","floatMat32Setter","uniformMatrix3x2fv","floatMat24Setter","uniformMatrix2x4fv","floatMat42Setter","uniformMatrix4x2fv","floatMat34Setter","uniformMatrix3x4fv","floatMat43Setter","uniformMatrix4x3fv","samplerSetter","unit","activeTexture","TEXTURE0","bindTexture","samplerArraySetter","units","textures","addLineNumbers","lineOffset","line","ndx","loadShader","shaderSource","shaderType","opt_errorCallback","errFn","shader","createShader","spaceRE","compileShader","compiled","getShaderParameter","COMPILE_STATUS","lastError","getShaderInfoLog","deleteShader","createProgram","shaders","opt_attribs","opt_locations","attachShader","bindAttribLocation","linkProgram","linked","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","createShaderFromScript","scriptId","opt_shaderType","shaderScript","getElementById","text","VERTEX_SHADER","FRAGMENT_SHADER","createProgramFromScripts","shaderScriptIds","defaultShaderType","createProgramFromSources","shaderSources","createUniformSetters","createUniformSetter","uniformInfo","getUniformLocation","typeInfo","textureUnit","arraySetter","setter","uniformSetters","numUniforms","ACTIVE_UNIFORMS","getActiveUniform","createUniformBlockSpecFromProgram","uniformData","uniformIndices","pair","pname","getActiveUniforms","blockSpecs","numUniformBlocks","ACTIVE_UNIFORM_BLOCKS","getActiveUniformBlockName","blockSpec","usedByVertexShader","getActiveUniformBlockParameter","UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER","usedByFragmentShader","UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER","UNIFORM_BLOCK_DATA_SIZE","UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES","used","usedByVertexSahder","createUniformBlockInfoFromProgram","uniformBlockSpec","blockName","uniformBufferIndex","UNIFORM_BUFFER","uniformBlockBinding","arraySuffixRE","uniformNdx","BYTES_PER_ELEMENT","asFloat","createUniformBlockInfo","bindUniformBlock","uniformBlockInfo","bufferBindIndex","bindBufferRange","byteLength","setUniformBlock","DYNAMIC_DRAW","setBlockUniforms","values","setters","actualSetters","numArgs","andx","vals","numValues","createAttributeSetters","createAttribSetter","b","enableVertexAttribArray","vertexAttribPointer","createMatAttribSetter","defaultSize","count","rowOffset","attribSetters","numAttribs","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","attrTypeMap","setAttributes","createProgramInfoFromProgram","good","script","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","INT_VEC2","INT_VEC3","INT_VEC4","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","SAMPLER_2D","SAMPLER_CUBE","SAMPLER_3D","SAMPLER_2D_SHADOW","FLOAT_MAT2x3","FLOAT_MAT2x4","FLOAT_MAT3x2","FLOAT_MAT3x4","FLOAT_MAT4x2","FLOAT_MAT4x3","SAMPLER_2D_ARRAY","SAMPLER_2D_ARRAY_SHADOW","SAMPLER_CUBE_SHADOW","UNSIGNED_INT_VEC2","UNSIGNED_INT_VEC3","UNSIGNED_INT_VEC4","INT_SAMPLER_2D","INT_SAMPLER_3D","INT_SAMPLER_CUBE","INT_SAMPLER_2D_ARRAY","UNSIGNED_INT_SAMPLER_2D","UNSIGNED_INT_SAMPLER_3D","UNSIGNED_INT_SAMPLER_CUBE","UNSIGNED_INT_SAMPLER_2D_ARRAY","TEXTURE_2D","TEXTURE_CUBE_MAP","TEXTURE_3D","TEXTURE_2D_ARRAY","programs","TRIANGLES","drawElements","drawArrays","drawObjectList","objectsToDraw","lastUsedProgramInfo","lastUsedBufferInfo","active","vertexArrayInfo","bindBuffers","setDefaultTextureColor","color","textureColor","savePackState","colorspaceConversion","lastPackState","UNPACK_COLORSPACE_CONVERSION_WEBGL","pixelStorei","premultiplyAlpha","UNPACK_PREMULTIPLY_ALPHA_WEBGL","flipY","UNPACK_FLIP_Y_WEBGL","restorePackState","setTextureParameters","tex","min","texParameteri","TEXTURE_MIN_FILTER","mag","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_WRAP_R","wrapR","wrapS","wrapT","minLod","TEXTURE_MIN_LOD","maxLod","TEXTURE_MAX_LOD","baseLevel","TEXTURE_BASE_LEVEL","maxLevel","TEXTURE_MAX_LEVEL","make1Pixel","isPowerOf2","setTextureFilteringForSize","textureOptions","generateMipmap","LINEAR","getCubeFaceOrder","cubeFaceOrder","TEXTURE_CUBE_MAP_POSITIVE_X","TEXTURE_CUBE_MAP_NEGATIVE_X","TEXTURE_CUBE_MAP_POSITIVE_Y","TEXTURE_CUBE_MAP_NEGATIVE_Y","TEXTURE_CUBE_MAP_POSITIVE_Z","TEXTURE_CUBE_MAP_NEGATIVE_Z","getCubeFacesWithNdx","faces","facesWithNdx","face","sort","noop","loadImage","url","crossOrigin","clearEventHandlers","img","onError","onLoad","msg","Image","setTextureTo1PixelColor","texImage2D","RGBA","texImage3D","loadTextureFromUrl","err","setTextureFromElement","loadCubemapFromUrls","uploadImg","faceTarget","numToLoad","errors","otherTarget","format","imgs","urls","getNumComponentsForFormat","ALPHA","LUMINANCE","LUMINANCE_ALPHA","RGB","getTextureTypeForArrayType","guessDimensions","sqrt","setTextureFromArray","depth","internalFormat","glEnumToString","dimensions","cbrt","UNPACK_ALIGNMENT","unpackAlignment","faceSize","subarray","setEmptyTexture","auto","resizeTexture","isAsyncSrc","createTextures","callCallbackIfReady","numDownloading","images","onLoadFn","enums","ctx","getContext","element","slices","imgWidth","imgHeight","xOffset","yOffset","drawImage","smallest","largest","max","xMult","yMult","d","srcX","srcY","srcW","srcH","dstX","dstY","dstW","dstH","texSubImage3D","getAttachmentPointForFormat","attachmentsByFormat","isRenderbufferFormat","renderbufferFormats","FRAMEBUFFER","fb","createFramebuffer","bindFramebuffer","drawingBufferWidth","drawingBufferHeight","defaultAttachments","colorAttachmentCount","framebuffer","attachmentOptions","attachment","attachmentPoint","COLOR_ATTACHMENT0","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","WebGLRenderbuffer","framebufferRenderbuffer","WebGLTexture","framebufferTexture2D","texTarget","level","resizeFramebufferInfo","viewport","DEPTH_COMPONENT","RGBA4","RGB5_A1","RGB565","DEPTH_COMPONENT16","STENCIL_INDEX","STENCIL_INDEX8","DEPTH_STENCIL","DEPTH_ATTACHMENT","STENCIL_ATTACHMENT","DEPTH_STENCIL_ATTACHMENT","attributes","draw","framebuffers","addVertexArrayObjectSupport","enableVertexArrayObjects","ext","getExtension","createVertexArrayOES","deleteVertexArray","deleteVertexArrayOES","isVertexArray","isVertexArrayOES","bindVertexArrayOES","VERTEX_ARRAY_BINDING","VERTEX_ARRAY_BINDING_OES","create3DContext","context","createContext","multiplier","clientWidth","clientHeight","notPrivate","copyPublicProperties","filter","api","apis","srcApi"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GAE/BA,EAAoB,GACpBI,EAAOD,QAAUH,EAAoB,IAKhC,SAASI,EAAQD,EAASH,GAE/B,YA0BA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAxBvF,GAAIG,GAAmBf,EAAoB,GAEvCgB,EAAmBL,EAAuBI,EE1D/Cf,GAAA,EACA,IAAAiB,GAAAjB,EAAA,GF+DKkB,EAAUP,EAAuBM,GE9DtCE,EAAAnB,EAAA,GFkEKoB,EAAST,EAAuBQ,GEjErCE,EAAArB,EAAA,GFqEKsB,EAASX,EAAuBU,GEpErCE,EAAAvB,EAAA,GFwEKwB,EAAWb,EAAuBY,GEvEvCE,EAAAzB,EAAA,GAYM0B,GACJC,UAAWC,cAAe,EAAGC,MAAO,EAAG,EAAG,GAAG,GAAI,GAAI,EAAI,EAAG,GAAG,EAAI,GAAG,GAAI,KAGtEC,EACJ,QAAAA,KAAe,GAAAC,GAAAC,MAAA,EAAAhB,EAAAF,SAAAkB,KAAAF,GAAAE,KAiBfC,YAAc,SAAAC,GACZ,KAAIA,EAAMC,SAAWD,EAAMC,QAAQC,OAAS,GAA5C,CAGA,GAAID,GAAUD,EAAMC,OACfA,KACHA,IAAaE,QAASH,EAAMG,QAASC,QAASJ,EAAMI,UAEtD,IAAIC,IAAOJ,EAAQ,GAAGG,QAAUP,EAAKS,GAAGC,OAAOC,OAAQP,EAAQ,GAAGE,QAAUN,EAAKS,GAAGC,OAAOE,OACvFC,EAAQb,EAAKa,MAAQC,KAAKC,MAAMf,EAAKgB,cAAgBF,KAAKG,IAAIjB,EAAKQ,IAAI,GAAKA,EAAI,IAAMM,KAAKG,IAAIjB,EAAKQ,IAAI,GAAKA,EAAI,KACjHK,GAAQb,EAAKgB,eAAcH,EAAQb,EAAKa,OAC5Cb,EAAKa,MAAQA,EACbb,EAAKQ,IAAMA,IA7BEP,KA+BfiB,OAAS,SAAAC,GACHnB,EAAKa,MAAQ,IAAGb,EAAKa,OAAS,EAClC,IAAIO,IACFD,OACAE,OAAQ,KACRC,YAAatB,EAAKS,GAAGC,OAAOE,MAAOZ,EAAKS,GAAGC,OAAOC,SAEhDY,GACFC,UAAW,EACXC,UAAW,EACXC,UAAW1B,EAAKa,MAAQb,EAAKgB,aAC7BW,aAAc3B,EAAK4B,QACnBC,eAAgB7B,EAAK8B,gBAAgBC,YAAY,GACjDT,YAAatB,EAAKS,GAAGC,OAAOE,MAAOZ,EAAKS,GAAGC,OAAOC,QAEhDqB,UAASC,cACX,EAAAvC,EAAAwC,2BAA0BlC,EAAKS,GAAGC,SAClC,EAAAhB,EAAAyC,qBAAoBnC,EAAKS,GAAIT,EAAK8B,iBAElC9B,EAAKS,GAAG2B,WAAWpC,EAAKqC,iBAAiBC,UACzC,EAAA5C,EAAA6C,yBAAwBvC,EAAKS,GAAIT,EAAKqC,iBAAkBrC,EAAKwC,aAC7D,EAAA9C,EAAA+C,aAAYzC,EAAKqC,iBAAkBjB,IACnC,EAAA1B,EAAAgD,gBAAe1C,EAAKS,GAAIT,EAAKwC,aAE7B,EAAA9C,EAAAyC,qBAAoBnC,EAAKS,GAAI,MAC7BT,EAAKS,GAAG2B,WAAWpC,EAAK2C,YAAYL,UACpC,EAAA5C,EAAA6C,yBAAwBvC,EAAKS,GAAIT,EAAK2C,YAAa3C,EAAKwC,aACxD,EAAA9C,EAAA+C,aAAYzC,EAAK2C,YAAapB,IAC9B,EAAA7B,EAAAgD,gBAAe1C,EAAKS,GAAIT,EAAKwC,aAE/BI,sBAAsB5C,EAAKkB,QA5D3B,IAAIR,GAASsB,SAASa,cAAc,SACpCb,UAASc,KAAKC,YAAYrC,GAC1BT,KAAKO,KAAO,EAAG,GACfP,KAAKY,MAAQ,EACbZ,KAAKe,aAAe,IACpBN,EAAOsC,iBAAiB,YAAa/C,KAAKC,aAC1CQ,EAAOsC,iBAAiB,YAAa/C,KAAKC,aAC1CD,KAAKQ,IAAK,EAAAf,EAAAuD,iBAAgBvC,GAC1BT,KAAK0C,aAAc,EAAAjD,EAAAwD,mBAAkBjD,KAAKQ,IAAIlB,EAAAR,QAAAM,EAAAN,UAC9CkB,KAAKoC,kBAAmB,EAAA3C,EAAAwD,mBAAkBjD,KAAKQ,IAAIlB,EAAAR,QAAAI,EAAAJ,UACnDkB,KAAKuC,YAAa,EAAA9C,EAAAyD,4BAA2BlD,KAAKQ,GAAId,GACtDM,KAAK6B,iBAAkB,EAAApC,EAAA0D,uBAAsBnD,KAAKQ,IAClDR,KAAK2B,SAAU,EAAAlC,EAAA2D,eAAcpD,KAAKQ,IAAK6C,cAAYC,KAAMtD,KAAKQ,GAAG+C,eAAgB,WAC/ExD,EAAKkB,WAmDX,IAAInB,IFyEE,SAAS1B,EAAQD,GGhKvB,YAEAA,GAAAU,YAAA,EAEAV,EAAAW,QAAA,SAAA0E,EAAAC,GACA,KAAAD,YAAAC,IACA,SAAAC,WAAA,uCHwKM,SAAStF,EAAQD;;;;;;;;;;;;;;;;;;;;;;CIxJvB,SAAAwF,GAAkB,YAIlB,SAAAC,KACA,MAAA7B,GAAA6B,yBAGA,QAAAhB,GAAAiB,GACA,MAAA9B,GAAAa,cAAAiB,GAGA,QAAAC,GAAA1D,EAAA2D,GACA,IAAA3D,EAAA,SAAA4D,OACA,uBACAD,EACA,8CAIA,QAAAE,GAAAC,GACA,OAAAA,EAAA9D,OACA,MAAA+D,GAAAD,EAAA,GAEA,QACAE,GAAAR,IACAS,EAAAC,EAAA/F,KAAA2F,GACAK,EAAA,EAAYA,EAAAL,EAAA9D,OAAkBmE,IAE9BH,EAAAtB,YAAAqB,EAAAE,EAAAE,IAEA,OAAAH,GAGA,QAAAD,GAAAK,GACA,sBAAAA,GAAAzC,EAAA0C,eAAAD,KAGA,OACAE,GACAC,EACAC,EACAC,EACAC,EACA/C,EAAA4B,EAAA5B,SACAgD,EAAAC,OAAAC,UAAAC,eACAC,EAAAH,OAAAG,gBAAA,SAAAC,EAAAT,EAAAU,GASA,MARAN,GAAAxG,KAAA8G,EAAA,SACAD,EAAAT,GAAAU,EAAAC,OAEAP,EAAAxG,KAAA8G,EAAA,QACAD,EAAAG,iBAAAZ,EAAAU,EAAAG,KACAT,EAAAxG,KAAA8G,EAAA,QACAD,EAAAK,iBAAAd,EAAAU,EAAAK,MAEAN,GAEAO,cAAA,SAAAL,GAEA,IADA,GAAAlF,GAAAJ,KAAAI,OACAA,KACAJ,KAAAI,KAAAkF,IAIA,MAAAlF,IAGAwF,EAAA,SAAAC,GACA,IAAAA,EACA,kBACO,IAAAC,EAAAC,KAAAF,GACP,4BAEA,OAAAA,IAEAG,EAAA,SAAAxB,GACA,GACAyB,GAAA,mBAAAzB,GAAA0B,UACAA,EAAAD,EACAzB,EAAA2B,aAAA,aAAA3B,EAAA0B,UACAE,EAAAH,GAAA,gBAAAC,GACAZ,GAAAc,EACAH,EAAAC,IAAAG,QACAH,GACAI,QAAAC,EAAA,GAEAjB,GAAAlF,QACAoG,EAAAC,KAAAC,MACA1G,KACAsF,EAAAqB,MAAAb,IAGA9F,KAAA4G,OAAAR,EACApG,KAAA6G,EAAArC,GAEAsC,GACAtB,IAAA,WACA,UAAAQ,GAAAhG,OAEA0F,IAAA,cAEAqB,EAAA,YAAAC,OAAAnG,KAAAoG,UAAA,GAAAC,OAAAZ,QAAA,SACAC,EAAA,aACAT,EAAA,MACAqB,EAAA,IACAC,EAAA,YACAC,EAAA,SAAAxB,EAAAyB,GAUA,MATAtH,MAAAuH,SAAA1B,GACAyB,GAEAtH,KAAAwH,OAAA3B,IAEO4B,SAAAH,QACPA,GAAA,EACAtH,KAAA0H,IAAA7B,MAEAyB,GAEAK,EAAAhE,EAAAiE,mCAAA3C,UACA4C,EAAAlE,EAAAkE,KACAC,GAAAD,GAAAE,SAAA9C,UACA+C,EAAArE,EAAAqE,eAAAH,EACAI,EAAAD,KAAA/C,UACAiD,EAAAvE,EAAAuE,aACAC,EAAAD,KAAAjD,UACAmD,GAAAzE,EAAAoE,SAAAF,GAAAlE,EAAA0E,aAAApD,UACAqD,EAAA3E,EAAA2E,mBAAA1F,EAAA,UAAA2F,YACAC,EAAAF,EAAArD,UAAAuC,OACAiB,EAAA9E,EAAA8E,WACAC,EAAA/E,EAAA+E,WAEAC,EAAA,KACAC,EAAA,MACAC,EAAA,SAAAC,GACA,GAAAC,GAAA,qBAAAD,CACA,iBAAAE,GACA,GAAAC,GAAA1E,EAAAlG,EAAA6K,EAAAC,EAAAC,EAAA5E,EAAAxE,KAAAqJ,UACA,IAAA7E,EAAA,CACA,IACAnG,EAAA2B,KAAAmG,aAAA,OAAAY,EACAmC,EAAA7K,IAAA0I,EAAA1I,IAAAiI,QAAAqC,EAAAC,GACAQ,EAAAJ,EAAArC,MAAA,KACApC,EAAA,EAAkBA,EAAA6E,EAAAhJ,OAAsBmE,IAExC6E,EAAA7E,GAAA,IAAA2E,EAAA,IAAAE,EAAA7E,EAEAyE,GAAAI,EAAAE,KAAA,KAMA,GAJAjL,IAAA0I,GAAA/G,KAAAuJ,aAAA,KAAAlL,GACA8K,GAAA3E,GAAAxE,MAAA8I,GAAAE,GACA3K,IAAA0I,GAAA/G,KAAAwJ,gBAAA,MAEAT,EAGA,IAFAxE,EAAA4E,EAAA/I,OACA6I,EAAA,GAAAQ,OAAAlF,GACAA,KAAA0E,EAAA1E,GAAA4E,EAAA5E,OAIA0E,GAAAE,CAEA,OAAAF,KAGAS,GAAA,SAAAC,GACA,SAAAA,KACAA,EAAAT,MAAAd,EAAAc,OAEA,YAAAS,KACAA,EAAAC,SAAAxB,EAAAwB,YAGApD,GACA,UACA4B,EAAAyB,iBACAzB,EAAA0B,uBACA1B,EAAA2B,sBACA3B,EAAA4B,oBACA5B,EAAA6B,mBACA7B,EAAA8B,kBACA,SAAAC,GACA,GAAAd,GAAArJ,KAAAqJ,UACA,SAAAA,IAAA,EAAA1D,EAAApH,KACA8K,EAAAe,iBAAAD,GACAnK,OAIA,mBAAAmK,GAEA,IADA,GAAAE,GAAAhB,EAAArJ,MAGAqK,EAAAhB,KAAAgB,WACAhB,EAAAgB,QAAAF,IAEAd,cAEA,OAAAgB,GAAAhB,EAAA,MAEA,qBACA,GAAAiB,GAAAtK,KAAAsK,WACA9F,EAAAP,EAAAsG,UACAD,GACAtK,KAAAwK,aAAAhG,EAAA8F,GAEAtK,KAAA8C,YAAA0B,IAGA,oBACAxE,KAAA8C,YAAAmB,EAAAsG,aAEA,oBACA,GAAAlB,GAAArJ,KAAAqJ,UACAA,IACAA,EAAAmB,aACAvG,EAAAsG,WAAAvK,OAIA,mBACA,GAAAqJ,GAAArJ,KAAAqJ,WACAoB,EAAAzK,KAAAyK,YACAjG,EAAAP,EAAAsG,UACAlB,KACAoB,EACApB,EAAAmB,aAAAhG,EAAAiG,GAEApB,EAAAvG,YAAA0B,KAKA,qBACAxE,KAAA0K,YAAAhE,MAAA1G,KAAAuK,YAEA,yBACA,GAAAlB,GAAArJ,KAAAqJ,UACAA,IACAA,EAAAsB,aACA1G,EAAAsG,WACAvK,OAIA,oBACA,GAAAqJ,GAAArJ,KAAAqJ,UACAA,IACAA,EAAAuB,YAAA5K,OAGA,QAAA6I,EAAA,iBACA,WAAAA,EAAA,qBAEAvE,EAAAkC,EAAAlC,MACAC,EAAAiC,EAAApG,OAA0BmE,EAAGA,GAAA,EAwB7B,GAtBAI,EAAA6B,EAAAjC,EAAA,GACAI,IAAAyD,KACAA,EAAAzD,GAAA6B,EAAAjC,EAAA,IAEA,WAAAI,IAEA2D,EAAArD,UAAAN,GAAA,WACA,SAAA4F,UAAAnK,OACAoI,EAAA9B,MAAA1G,KAAAuK,WACAnC,EAAAZ,OAAAjJ,KAAAyB,QAIA,gDAAA+F,KAAApB,MACAqD,GAAArD,IAAAsD,KACAA,EAAAtD,GAAA6B,EAAAjC,EAAA,KAEA2D,GAAAvD,IAAAwD,KACAA,EAAAxD,GAAA6B,EAAAjC,EAAA,KAIA,uBAAAwB,KAAApB,GACA,GAAAgD,EACAhD,IAAAgD,KACAA,EAAAhD,GAAA6B,EAAAjC,EAAA,QAGA,KACAX,IAAA2E,YAAAtD,UAAAN,GAAA6B,EAAAjC,EAAA,GACS,MAAAsG,IAST,GAHAnB,EAAA3H,GAGA4F,EACA+B,EAAA/B,OAEA,KACA+B,EAAA9F,IAAA2E,YAAAtD,WACK,MAAA4F,IAILpC,GACAiB,EAAAjB,EAAAxD,WAKArC,EAAA,KAAAyH,QAAA,OACAjC,EAAAzD,GAAA,SAAA0F,GACA,gBAAAF,GACA,MAAAE,GAAA9L,KACAyB,KAAAqJ,WACArJ,KACA4D,IAAAd,YAAA9C,MACAmK,KAGK/B,EAAAzD,KAILqB,EAAAf,WACA7E,OAAA,EACAsH,IAAA,WACA,OAAA7B,GAAAiF,EAAA,EAA2BA,EAAAP,UAAAnK,OAAsB0K,IACjDjF,EAAA0E,UAAAO,GACA9K,KAAAuH,SAAA1B,IACAW,EAAAC,KAAAlI,KAAAyB,KAAA2E,EAGA3E,MAAA4G,OACA5G,KAAA6G,EAAA0C,aAAA,WAAAvJ,MAEAA,KAAA6G,EAAAX,UAAA,GAAAlG,MAGAuH,SAAA,SAAA5B,GACA,gBAAAE,GAEA,MADAtB,GAAAoB,EAAApH,KAAAyB,KAAA2E,EAAAiB,EAAAC,KACA,EAAAtB,OAEKoB,SAAA,SAAAE,GAEL,IADAtB,EAAAvE,KAAAI,OACAmE,KAAAvE,KAAAuE,KAAAsB,IACA,MAAAtB,KAEAwG,KAAA,SAAAxG,GACA,MAAAvE,MAAAuE,IAAA,MAEAiD,OAAA,WACA,OAAA3B,GAAAiF,EAAA,EAA2BA,EAAAP,UAAAnK,OAAsB0K,IACjDjF,EAAA0E,UAAAO,GACA9K,KAAAuH,SAAA1B,IACAW,EAAAwE,OAAAzM,KAAAyB,KAAAuE,EAAA,EAGAvE,MAAA4G,OACA5G,KAAA6G,EAAA0C,aAAA,WAAAvJ,MAEAA,KAAA6G,EAAAX,UAAA,GAAAlG,MAGAqH,SACA4D,SAAA,WACA,MAAAzE,GAAA8C,KAAA/K,KAAAyB,KAAAmH,MAIAuB,GAAAtB,IAAAsB,GAAAzD,WACAE,EAAAuD,EAAAzD,UAAAmC,EAAAN,GAOAM,IAAArF,GAAAmJ,iBAKArG,EAAAjC,EAAA,OAAAwE,GACAvC,EAAA6C,IAAA,aACA,OAAA7C,IAEAD,EAAAC,EAAA0D,YAAAtD,UACA,OAAAL,KAEAA,EAAAjB,EAAAkB,mBAAAI,WAEAH,EAAA,SAAAqG,GACA,kBAEA,IADA,GAAA5G,GAAA,EACAA,EAAAgG,UAAAnK,QACA+K,EAAA5M,KAAAyB,KAAAuK,UAAAhG,QAIAK,EAAA8C,IAAA5C,EAAAF,EAAA8C,KACA9C,EAAA4C,OAAA1C,EAAAF,EAAA4C,QAEA5C,EAAAyC,WAxBAlC,EAAAiD,EAAAhB,EAAAN,GA4BA,YAAAgB,IACA3C,EAAA2C,EAAA,YACAxC,MAAA,SAAA8F,GACA,KAAAA,OAAApL,MAAAoL,IAAA/B,UACA,OAAArJ,QAAAoL,KAKA,QAAArJ,IACAoD,EAAApD,EAAA,QACAyD,IAAA,WACA,MAAAd,KACAA,EAAA3C,EAAAsJ,qBAAA,eAOA,WACA,OACAC,GACAC,EAAA5H,EAAAhB,sBACA6I,EAAA7H,EAAA8H,qBACAC,GAAA,yBACAnH,EAAAmH,EAAAtL,QACAoL,GAAAjH,KAEAgH,KAAA5H,EAAA+H,EAAAnH,GAAA,yBACAiH,EAAA7H,EAAA+H,EAAAnH,GAAA,yBACAZ,EAAA+H,EAAAnH,GAAA,8BAEAiH,KAEAD,GACAD,EAAAC,EACAA,EAAA,SAAAI,GACA,GAAAC,IAAA,CAIA,OAHAN,GAAA,WACAM,GAAAD,EAAAjF,MAAA1G,KAAAuK,aAEA,WACAqB,GAAA,IAGAJ,EAAA,SAAAnN,GACAA,OAGAkN,EAAA,SAAAI,GACA,MAAAE,YAAAF,EAAA,QAEAH,EAAA,SAAAnN,GACAyN,aAAAzN,MAIAsF,EAAAhB,sBAAA4I,EACA5H,EAAA8H,qBAAAD,IAIA,KAAM,GAAA7H,GAAAoI,YAAA,KAA6B,MAAAlB,GACnClH,EAAAoI,YAAA,SACAC,EACAC,GAIA,QAAAF,GAAAG,EAAAC,GAEA,GAAAjM,GAAA6B,EAAAqK,YAAAJ,EACA,oBAAAE,GACA,SAAAlI,OAAA,iCAcA,OAZA,SAAAgI,IACA9L,EAAAmM,mBAEA,MAAAF,IACAA,EAAAF,GAEA/L,EAAAmM,gBACAH,EACAC,EAAAG,QACAH,EAAAI,WACAJ,EAAAK,QAEAtM,EAIA,QAAAmM,GACAH,EAAAI,EAAAC,EAAAC,GAGAxM,KAAAyM,UAAAP,EAAAI,EAAAC,GACAvM,KAAAwM,SAIA,MAAAT,IAKApI,EAAAoI,YAEA,uBAGAO,SAAA,EACAC,YAAA,EACAC,OAAA,OAMA,IAAO,GAAAE,OAAA,KAAkB,MAAA7B,GAEzBA,EAAA,SAAA8B,GACA,QAAAD,GAAAR,EAAAU,GACA9I,EAAAyG,UAAAnK,OAAA,QACA,IAAAyM,GAAA9K,EAAAqK,YAAA,QAOA,OANAQ,WACAC,EAAAJ,UACAP,IACAU,EAAAN,UACAM,EAAAL,YAEAM,EAGA,MADAH,GAAAzH,UAAA0H,EAAA1H,UACAyH,GACK/I,EAAA+I,OAAA,cACLvH,EAAAxB,EAAA,SAAqC2B,MAAAuF,IAErC6B,QAAA7B,IAAA6B,MAAA7B,GAIA,IAAO,GAAAiC,eAAA,QAA8B,MAAAjC,GAErCA,EAAA,SAAAkC,GAuCA,QAAAC,GAAAJ,GACA,OACAC,MACAI,GACA,UACA,UACA,WACA,QACA,SACA,MACA,UACA,OACA,cACA,YAEA1I,EAAA,EAAgBA,EAAA0I,EAAA7M,OAAiBmE,GAAA,EAEjCqI,EAAAK,EAAA1I,KACAsI,EAAApG,KAAAwG,EAAA1I,EAAA,GAEA,OAAAsI,GAAAvD,KAAA,KAGA,QAAA4D,GAAAC,EAAAC,GACA,OAAAC,KAAAD,GAEAA,EAAAlI,eAAAmI,KACAD,EAAAlI,eAAA3G,KAAA4O,EAAAE,KACAF,EAAAE,GAAAD,EAAAC,GAEA,OAAAF,GAGA,QAAAG,GAAAD,EAAAR,EAAAD,GACA,IACAC,EAAAQ,GAAAT,EAAAS,GACS,MAAAxC,KAGT,QAAAiC,GAAAZ,EAAAU,GACA9I,EAAAyG,UAAAnK,OAAA,iBACAwM,EAAAM,EAAAN,MAAsCW,EACtC,IAwBAC,GAvBAX,EAAA9K,EAAAqK,YAAAqB,GACAC,EAAAd,EAAAc,QACAC,EAAAf,EAAAe,SACAC,EAAAhB,EAAAgB,OACAC,EAAAjB,EAAAiB,QACAC,EAAAlB,EAAAkB,YACAC,EAAAC,EAAA,EAAAhB,EAAAJ,GAAA,KACAS,EAAAY,OAAArB,EAAAS,KACAa,EAAAD,OAAArB,EAAAuB,MACAC,EAAAxB,EAAAwB,SACAC,EAAAzB,EAAAyB,UACAzB,EAAAyB,QAAAhB,IACAA,EAAAiB,WAAA,IACA,EACAC,EAAA3B,EAAA2B,WACA3B,EAAA2B,SAAAL,IACAA,EAAAI,WAAA,IACA,EACAhC,EAAAM,EAAAN,QACAC,EAAAK,EAAAL,WACAiC,EAAA5B,EAAA4B,OACAC,EAAA7B,EAAA6B,OACAC,EAAA9B,EAAA8B,MAAA/K,CAIA,IADAiJ,EAAA+B,QAAA/B,EAAA+B,MAAA/B,EAAAyB,SACA,gBAAAxB,GACAA,EAAA+B,aACA1C,EAAAI,EAAAC,EAAAmC,EACAhB,EAAAE,EAAAD,EAAAE,EAAAQ,EAAAE,OAES,MAAAP,GAAA,qBAAAnB,GAAA,CAET,OADAW,GAAAtB,EAAAI,EAAAC,EAAAmC,GACAV,GACA,OACAR,EAAA/G,KAAA4G,EAAAe,EAAAV,EAAAC,EAAAC,EAAAC,EAAAC,EACA,MACA,QACAN,EAAA/G,KAAAiH,EAAAE,EAAAD,EAAAE,EAAAQ,EAAAE,EACA,MACA,QACAf,EAAA/G,KAAA4G,EAAAe,EAAAV,EAAAE,EAAAD,EAAAE,EAAAC,EACA,MACA,QACAN,EAAA/G,KAAA4G,EAAAe,EAAAL,EAAAS,EAAAC,EACA,MACA,SACAjB,EAAA/G,KAAA0H,KAAAd,EAAAe,EAAAL,EAAAS,EAAAC,GAEA5B,EAAAgC,kBAAAnI,MAAAmG,EAAAW,OAEAX,GAAAJ,UAAAP,EAAAI,EAAAC,EAEA,KAAAc,IAAAR,GACAU,EAAArI,eAAAmI,IAAAR,EAAAQ,KAAAT,EAAAS,IACAC,EAAAD,EAAAR,EAAAD,EAGA,OAAAC,GA1IA,GAoBAY,GAnBAO,EAAA,EACAT,GACAY,KAAA,GACAd,IAAA,GACAe,SAAA,EACAV,SAAA,EACAC,UAAA,EACAC,QAAA,EACAC,SAAA,EACAC,aAAA,EACAU,QAAA,EACAC,OAAAK,UAAAC,SACAvC,OAAA,EACAF,SAAA,EACAC,YAAA,EACA8B,QAAA,EACAE,SAAA,EACAI,MAAA,EAIA,KACA,GAAAK,GAAAjN,EAAAqK,YAAA,gBACA4C,GAAAH,kBACA,cAAAlL,EAAA,OACA,eAEAqK,EACA,MAAAgB,EAAAC,eAAAD,EAAA3B,MACA,IAAA2B,EAAAE,aAAAF,EAAAZ,YAEAY,EAAAtB,QAAAsB,EAAApB,OAAA,IAAAoB,EAAArB,SAAA,MACA,EACO,MAAA9C,IA2GP,MA1GA4C,GAAA,EAAAO,EAAA,wBAyGAlB,EAAA7H,UAAA8H,EAAA9H,UACA6H,GACKnJ,EAAAmJ,eAAA,cACL3H,EAAAxB,EAAA,iBAA6C2B,MAAAuF,IAE7CiC,gBAAAjC,IAAAiC,cAAAjC,GAIA,IAAO,GAAAsE,YAAA,QAA2B,MAAAtE,GAElCA,EAAA,SAAAuE,GACA,QAAAD,GAAAjD,EAAAU,GACA9I,EAAAyG,UAAAnK,OAAA,aACA,IAAAyM,GAAA9K,EAAAqK,YAAA,aAmBA,OAlBAQ,WACAC,EAAAwC,eACAnD,IACAU,EAAAN,UACAM,EAAAL,WACAK,EAAA8B,MAAA/K,EACAiJ,EAAAJ,QAAA,EACAI,EAAA0C,SAAA,EACA1C,EAAA2C,SAAA,EACA3C,EAAAvM,SAAA,EACAuM,EAAAtM,SAAA,IACAsM,EAAAc,UACAd,EAAAgB,SACAhB,EAAAe,WACAf,EAAAiB,QACAjB,EAAA4C,QAAA,EACA5C,EAAA6C,eAAA,MAEA5C,EAGA,MADAsC,GAAAlK,UAAAmK,EAAAnK,UACAkK,GACKxL,EAAAwL,YAAA,cACLhK,EAAAxB,EAAA,cAA0C2B,MAAAuF,IAE1CsE,aAAAtE,IAAAsE,WAAAtE,KAGClH,QAAU,SAAA+L,GAAmB,YA8D9B,SAAAC,MAKA,QAAAC,GAAA1D,EAAAP,EAAAkE,GACA,QAAAC,GAAAd,GACAc,EAAAC,OACAf,EAAAgB,cAAAC,oBACAjB,EAAA9C,KACAP,EACAmE,GAEAA,EAAAI,SAAA,GAEAJ,EAAAK,UACAnB,EAAAoB,eAAAR,EAAAQ,gBAEA,kBAAAN,GAAAnE,SAEAmE,EAAAnE,SAAApN,KAAAyB,KAAAgP,GACOc,EAAAnE,UACPmE,EAAAnE,SAAA0E,YAAArB,GAEAc,EAAAK,eACAnB,GAAAoB,eAUA,MAPAN,GAAA5D,OACA4D,EAAAnE,WACAmE,EAAAQ,UAAAT,EAAAS,QACAR,EAAAK,UAAAN,EAAAM,QACAL,EAAAC,OAAAF,EAAAE,KAEAD,EAAAI,SAAA,EACAJ,EA9FA,GAAAS,GAAAb,EAAAc,SAAA,WASA,QAAAC,GAAApD,EAAAqD,EAAAC,GACAC,EAAAD,EACAE,GAAA,EACAvL,EAAAmC,OACA4F,EAAAyD,cAAAJ,GAGA,QAAAK,GAAAzL,GACAtF,KAAAsF,QAYA,QAAAiL,KACAS,IACAhR,KAAAiR,OAAA,GAAAvE,GAAA,WAAAsE,EAAAnQ,KAAAoG,UA7BA,GAIA3B,GAHA0L,EAAA,EACAH,GAAA,EACAD,GAAA,CAkDA,OAnCAG,GAAA9L,UAAAoL,YAAA,SAAArB,GACA6B,GAAA,EACAD,EACA5B,EAAAgB,cAAAC,oBAAAjB,EAAA9C,KAAAlM,MAAA,GAEAsF,EAAAtF,KAAAsF,OASAiL,EAAAtL,WACAsD,YAAAgI,EACAW,OAAA,SAAA7D,GACA,MAAAoD,GAAApD,EAAArN,KAAAiR,QAAA,GAAAJ,GAEArL,IAAA,SAAA6H,GACAoD,EAAApD,EAAArN,KAAAiR,QAAA,EACA,IAAAE,GAAA7L,CAEA,OADAA,GAAAmC,OACA0J,GAEAC,IAAA,SAAA/D,GACA,MAAAoD,GAAApD,EAAArN,KAAAiR,QAAA,GAAAJ,GAEAnL,IAAA,SAAA2H,EAAA/H,GAGA,MAFAmL,GAAApD,EAAArN,KAAAiR,QAAA,GACA5D,EAAAtK,iBAAA/C,KAAAiR,OAAA/E,KAAA,GAAA6E,GAAAzL,IAAA,GACAtF,OAIAuQ,IAKAZ,GAAA1K,WAAAD,OAAAqM,QAAArM,QAAA,MAqCA4K,EAAAQ,eAAA,YAEA,IAwBAkB,GAvBA5E,EAAAgD,EAAA3D,YAEAwF,GADAvM,OAAAC,UAAAC,eACAwK,EAAAoB,eACAU,EAAA9B,EAAA3M,iBACA0O,EAAA/B,EAAAO,oBACAe,EAAA,EACAU,EAAA,WAA6BV,KAC7BrL,cAAA,SAAAL,GAEA,IADA,GAAAlF,GAAAJ,KAAAI,OACAA,KACAJ,KAAAI,KAAAkF,IAIA,MAAAlF,IAEAuR,EAAA,SAAA9B,GACA,SAAA7I,OACA6I,EAAAS,QAAA,QACAT,EAAAM,QAAA,QACAN,EAAAE,KAAA,SAMA,KACAyB,EAAA,IAAAE,GAAyB3B,MAAA,IACzBwB,EAAA,GAAA7E,GAAA,MACA6E,EAAA,GAAA7E,GAAA,MACA+E,EAAA,IAAAC,GAAyB3B,MAAA,IACtB,MAAAlF,IAEH,IAAAmG,IACA,WAEA,QAAAY,GAAAJ,GACA,gBAAAtF,EAAA2F,EAAAhC,GACA,GAAAA,GAAA,iBAAAA,GAAA,CACA,GAGAtL,GAAAuN,EAAAxO,EAFAyO,EAAAC,EAAAxM,IAAAxF,MACAqN,EAAAsE,EAAA9B,EAGAkC,IAAAC,EAAAtM,IAAA1F,KAAA+R,EAAA,GAAApC,IACAzD,IAAA6F,OAAA7F,IACA2F,WACAvO,UAEAwO,EAAAC,EAAA7F,GACA3H,EAAAoB,EAAApH,KAAAuT,EAAAD,WACAtN,EAAA,GACAA,EAAAuN,EAAAD,QAAApL,KAAAoL,GAAA,EACAC,EAAAxO,KAAAiB,GAAAjB,EAAA,GAAAqM,IAEArM,EAAAwO,EAAAxO,KAAAiB,GAEA8I,IAAA/J,KACAA,EAAA+J,GAAAuC,EAAA1D,EAAA2F,EAAAhC,GACA2B,EAAAjT,KAAAyB,KAAAkM,EAAA5I,EAAA+J,GAAA/J,EAAA+J,GAAAiD,cAGAkB,GAAAjT,KAAAyB,KAAAkM,EAAA2F,EAAAhC,IAIA,QAAAoC,GAAAR,GACA,gBAAAvF,EAAA2F,EAAAhC,GACA,GAAAA,GAAA,iBAAAA,GAAA,CACA,GAEAxC,GAAA9I,EAAAuN,EAAAxO,EADAyO,EAAAC,EAAAxM,IAAAxF,KAGA,IAAA+R,GAAA7F,IAAA6F,KACAD,EAAAC,EAAA7F,GACA3H,EAAAoB,EAAApH,KAAAuT,EAAAD,YACA,EAAAtN,IACA8I,EAAAsE,EAAA9B,GACAvM,EAAAwO,EAAAxO,KAAAiB,GACA8I,IAAA/J,KAAA,CACAmO,EAAAlT,KAAAyB,KAAAkM,EAAA5I,EAAA+J,GAAA/J,EAAA+J,GAAAiD,eACAhN,GAAA+J,EAEA,KAAAA,IAAA/J,GAAA,MAEAwO,GAAAD,QAAA7G,OAAAzG,EAAA,GACAuN,EAAAxO,KAAA0H,OAAAzG,EAAA,GAEA,IAAAuN,EAAAD,QAAAzR,cAEA2R,GAAA7F,QAKAuF,GAAAlT,KAAAyB,KAAAkM,EAAA2F,EAAAhC,IA5DA,GAAAmC,GAAA,GAAAzB,EAiEAe,GAAA,SAAA7N,GACA,GAAAA,EAAA,CACA,GAAAyO,GAAAzO,EAAAwB,SACAiN,GAAAnP,iBAAA6O,EAAAM,EAAAnP,kBACAmP,EAAAjC,oBAAAgC,EAAAC,EAAAjC,uBAGAP,EAAAyC,YACAb,EAAAa,cAEAb,EAAA5B,EAAA0C,MACAd,EAAA5B,EAAA3H,SAAA2H,EAAArH,aACAiJ,EAAA5B,EAAA2C,cACAf,EAAA5B,EAAA4C,SAAkCrN,UAAAyK,IAClC4B,EAAA5B,EAAA6C,qBAMCC,OJoLK,SAASpU,EAAQD,GK1oCvBC,EAAAD,QAAA,6wGLgpCM,SAASC,EAAQD,GMhpCvBC,EAAAD,QAAA,wkDNspCM,SAASC,EAAQD,GOtpCvBC,EAAAD,QAAA,mOP4pCM,SAASC,EAAQD,EAASH,GQ5pChCI,EAAAD,QAAAH,EAAAU,EAAA,wCRkqCM,SAASN,EAAQD,EAASH,GSlqChC,GAAAyU,GAAAC,EAAAC;;;;;;;;;;CAUA,SAAAC,EAAAC,GAEAH,KAAAD,EAAA,EAAAE,EAAA,kBAAAF,KAAA/L,MAAAvI,EAAAuU,GAAAD,IAAAhL,SAAAkL,IAAAvU,EAAAD,QAAAwU,IACK,mBAAAvU,MAAAD,QACLC,EAAAD,QAAA0U,IAEAD,EAAAE,KAAAD,KAEC7S,KAAA;;;;;AAYD,GAAA+S,GAAAC,EAAAC,CA4nJA,OA3nJA,UAAAC,GAUA,QAAAC,GAAAvU,EAAAwU,GACA,MAAAC,GAAA9U,KAAAK,EAAAwU,GAWA,QAAAE,GAAAvP,EAAAwP,GACA,GAAAC,GAAAC,EAAAC,EAAAC,EAAAC,EACAC,EAAAC,EAAAC,EAAAxP,EAAAuG,EAAAkJ,EACAC,EAAAV,KAAA5M,MAAA,KACAuN,EAAAC,EAAAD,IACAE,EAAAF,KAAA,QAGA,IAAAnQ,GAAA,MAAAA,EAAAsQ,OAAA,GAIA,GAAAd,EAAA,CAgBA,IAfAxP,IAAA4C,MAAA,KACAiN,EAAA7P,EAAA3D,OAAA,EAGA+T,EAAAG,cAAAC,EAAAxO,KAAAhC,EAAA6P,MACA7P,EAAA6P,GAAA7P,EAAA6P,GAAAtN,QAAAiO,EAAA,KAOAxQ,EAAAkQ,EAAA3P,MAAA,EAAA2P,EAAA7T,OAAA,GAAA4G,OAAAjD,GAGAQ,EAAA,EAA2BA,EAAAR,EAAA3D,OAAiBmE,GAAA,EAE5C,GADAyP,EAAAjQ,EAAAQ,GACA,MAAAyP,EACAjQ,EAAAiH,OAAAzG,EAAA,GACAA,GAAA,MACqB,WAAAyP,EAAA,CACrB,OAAAzP,IAAA,OAAAR,EAAA,WAAAA,EAAA,IAOA,KACyBQ,GAAA,IACzBR,EAAAiH,OAAAzG,EAAA,KACAA,GAAA,GAMAR,IAAAuF,KAAA,SACa,KAAAvF,EAAA4B,QAAA,QAGb5B,IAAAyQ,UAAA,GAKA,KAAAP,GAAAG,IAAAF,EAAA,CAGA,IAFAV,EAAAzP,EAAA4C,MAAA,KAEApC,EAAAiP,EAAApT,OAAsCmE,EAAA,EAAOA,GAAA,GAG7C,GAFAkP,EAAAD,EAAAlP,MAAA,EAAAC,GAAA+E,KAAA,KAEA2K,EAGA,IAAAnJ,EAAAmJ,EAAA7T,OAA8C0K,EAAA,EAAOA,GAAA,EAKrD,GAJA4I,EAAAQ,EAAAD,EAAA3P,MAAA,EAAAwG,GAAAxB,KAAA,MAIAoK,IACAA,IAAAD,IACA,CAEAE,EAAAD,EACAG,EAAAtP,CACA,OAMA,GAAAoP,EACA,OAMAG,GAAAM,KAAAX,KACAK,EAAAM,EAAAX,GACAM,EAAAxP,IAIAoP,GAAAG,IACAH,EAAAG,EACAD,EAAAE,GAGAJ,IACAH,EAAAxI,OAAA,EAAA6I,EAAAF,GACA5P,EAAAyP,EAAAlK,KAAA,MAIA,MAAAvF,GAGA,QAAA0Q,GAAAC,EAAAC,GACA,kBAIA,GAAAnH,GAAAoH,EAAArW,KAAAgM,UAAA,EAQA,OAHA,gBAAAiD,GAAA,QAAAA,EAAApN,QACAoN,EAAA/G,KAAA,MAEAoO,EAAAnO,MAAAwM,EAAA1F,EAAAxG,QAAA0N,EAAAC,MAIA,QAAAG,GAAAJ,GACA,gBAAA3Q,GACA,MAAAuP,GAAAvP,EAAA2Q,IAIA,QAAAK,GAAAC,GACA,gBAAA1P,GACA2P,EAAAD,GAAA1P,GAIA,QAAA4P,GAAAnR,GACA,GAAAoP,EAAAgC,EAAApR,GAAA,CACA,GAAAyJ,GAAA2H,EAAApR,SACAoR,GAAApR,GACAqR,EAAArR,IAAA,EACAsR,EAAA3O,MAAAwM,EAAA1F,GAGA,IAAA2F,EAAA8B,EAAAlR,KAAAoP,EAAAiC,EAAArR,GACA,SAAAC,OAAA,MAAAD,EAEA,OAAAkR,GAAAlR,GAMA,QAAAuR,GAAAvR,GACA,GAAAwR,GACAC,EAAAzR,IAAA4B,QAAA,OAKA,OAJA6P,IAAA,IACAD,EAAAxR,EAAAyQ,UAAA,EAAAgB,GACAzR,IAAAyQ,UAAAgB,EAAA,EAAAzR,EAAA3D,UAEAmV,EAAAxR,GA8CA,QAAA0R,GAAA1R,GACA,kBACA,MAAAoQ,uBAAApQ,QA1OA,GAAAsR,GAAAR,EAAAa,EAAAC,EACAV,KACAE,KACAhB,KACAiB,KACA/B,EAAArO,OAAAC,UAAAC,eACA0P,KAAAtQ,MACAiQ,EAAA,OA2LAmB,GAAA,SAAA3R,EAAA2Q,GACA,GAAAkB,GACAC,EAAAP,EAAAvR,GACAwR,EAAAM,EAAA,EA2BA,OAzBA9R,GAAA8R,EAAA,GAEAN,IACAA,EAAAjC,EAAAiC,EAAAb,GACAkB,EAAAV,EAAAK,IAIAA,EAEAxR,EADA6R,KAAAtC,UACAsC,EAAAtC,UAAAvP,EAAA+Q,EAAAJ,IAEApB,EAAAvP,EAAA2Q,IAGA3Q,EAAAuP,EAAAvP,EAAA2Q,GACAmB,EAAAP,EAAAvR,GACAwR,EAAAM,EAAA,GACA9R,EAAA8R,EAAA,GACAN,IACAK,EAAAV,EAAAK,MAMAO,EAAAP,IAAA,IAAAxR,IACAgS,EAAAhS,EACAiS,GAAAT,EACA7W,EAAAkX,IAUAD,GACA3C,mCAAA,SAAAjP,GACA,MAAA0Q,GAAA1Q,IAEA5F,QAAA,SAAA4F,GACA,GAAAiL,GAAAiG,EAAAlR,EACA,0BAAAiL,GACAA,EAEAiG,EAAAlR,OAGA3F,OAAA,SAAA2F,GACA,OACA1F,GAAA0F,EACAkS,IAAA,GACA9X,QAAA8W,EAAAlR,GACAoQ,OAAAsB,EAAA1R,MAKAsR,EAAA,SAAAtR,EAAAmS,EAAAvK,EAAA+I,GACA,GAAAyB,GAAAnB,EAAAoB,EAAAlC,EAAA3P,EAGA8R,EAFA7I,KACA8I,QAAA3K,EAOA,IAHA+I,KAAA3Q,EAGA,cAAAuS,GAAA,aAAAA,EAAA,CAKA,IADAJ,KAAA9V,QAAAuL,EAAAvL,QAAA,yDAAA8V,EACA3R,EAAA,EAAuBA,EAAA2R,EAAA9V,OAAiBmE,GAAA,EAKxC,GAJA2P,EAAAwB,EAAAQ,EAAA3R,GAAAmQ,GACAM,EAAAd,EAAA4B,EAGA,uCAAAd,EACAxH,EAAAjJ,GAAAoR,EAAA3C,mCAAAjP,OACiB,gBAAAiR,EAEjBxH,EAAAjJ,GAAAoR,EAAAxX,QAAA4F,GACAsS,GAAA,MACiB,eAAArB,EAEjBmB,EAAA3I,EAAAjJ,GAAAoR,EAAAvX,OAAA2F,OACiB,IAAAoP,EAAA8B,EAAAD,IACjB7B,EAAAgC,EAAAH,IACA7B,EAAAiC,EAAAJ,GACAxH,EAAAjJ,GAAA2Q,EAAAF,OACiB,KAAAd,EAAAxV,EAIjB,SAAAsF,OAAAD,EAAA,YAAAiR,EAHAd,GAAAxV,EAAA6X,KAAArC,EAAA6B,EAAAtB,EAAAC,GAAA,GAAAK,EAAAC,OACAxH,EAAAjJ,GAAA0Q,EAAAD,GAMAoB,EAAAzK,IAAAjF,MAAAuO,EAAAlR,GAAAyJ,GAAA/F,OAEA1D,IAIAoS,KAAAhY,UAAA+U,GACAiD,EAAAhY,UAAA8W,EAAAlR,GACAkR,EAAAlR,GAAAoS,EAAAhY,QACiBiY,IAAAlD,GAAAmD,IAEjBpB,EAAAlR,GAAAqS,QAGSrS,KAGTkR,EAAAlR,GAAA4H,IAIAoH,EAAAC,EAAA6B,EAAA,SAAAqB,EAAAvK,EAAA+I,EAAAC,EAAA6B,GACA,mBAAAN,GACA,MAAAP,GAAAO,GAEAP,EAAAO,GAAAvK,GAMAuJ,EAAAQ,EAAAQ,EAAAvK,GAAAmK,EACS,KAAAI,EAAAlL,OAAA,CAMT,GAJAmJ,EAAA+B,EACA/B,EAAA+B,MACArB,EAAAV,EAAA+B,KAAA/B,EAAAxI,WAEAA,EACA,MAGAA,GAAAX,QAGAkL,EAAAvK,EACAA,EAAA+I,EACAA,EAAA,MAEAwB,EAAAhD,EA6BA,MAxBAvH,MAAA,aAIA,kBAAA+I,KACAA,EAAAC,EACAA,EAAA6B,GAIA7B,EACAU,EAAAnC,EAAAgD,EAAAvK,EAAA+I,GAQA7I,WAAA,WACAwJ,EAAAnC,EAAAgD,EAAAvK,EAAA+I,IACa,GAGbG,GAOAA,EAAAV,OAAA,SAAAsC,GACA,MAAA5B,GAAA4B,IAMA1D,EAAA2D,SAAAzB,EAEAhC,EAAA,SAAAlP,EAAAmS,EAAAvK,GACA,mBAAA5H,GACA,SAAAC,OAAA,4DAIAkS,GAAAlL,SAIAW,EAAAuK,EACAA,MAGA/C,EAAA8B,EAAAlR,IAAAoP,EAAAgC,EAAApR,KACAoR,EAAApR,MAAAmS,EAAAvK,KAIAsH,EAAA0D,KACAC,QAAA,MAIA3D,EAAA,8CAgCAA,EAAA,iCAsCA,QAAA4D,GAAAC,GACA,GAAAA,YAAAC,WAAkD,MAAAC,EAClD,IAAAF,YAAAG,YAAkD,MAAAC,EAClD,IAAAJ,YAAAK,mBAAkD,MAAAD,EAClD,IAAAJ,YAAAM,YAAkD,MAAAC,EAClD,IAAAP,YAAAQ,aAAkD,MAAAC,EAClD,IAAAT,YAAAU,YAAkD,MAAAC,EAClD,IAAAX,YAAAY,aAAkD,MAAAC,EAClD,IAAAb,YAAAc,cAAkD,MAAAC,EAClD,qCASA,QAAAC,GAAA5L,GACA,OAAAA,GACA,IAAA8K,GAAA,MAAAD,UACA,KAAAG,GAAA,MAAAD,WACA,KAAAI,GAAA,MAAAD,WACA,KAAAG,GAAA,MAAAD,YACA,KAAAG,GAAA,MAAAD,WACA,KAAAG,GAAA,MAAAD,YACA,KAAAG,GAAA,MAAAD,aACA,SACA,wBAIA,QAAAG,GAAA9O,GACA,MAAAA,MAAA+O,QAAA/O,EAAA+O,iBAAAC,aAnDA,GAGAjB,GAAA,KACAE,EAAA,KACAG,EAAA,KACAE,EAAA,KACAE,EAAA,KACAE,EAAA,KACAE,EAAA,IA8CA,QACAhB,yBACAiB,6BACAC,mBAoCA9E,EAAA,2BAQA,QAAAiF,GAAA7U,GACA,GAAA8U,KAIA,OAHAnT,QAAAiI,KAAA5J,GAAA+U,QAAA,SAAA/K,GACA8K,EAAA9K,GAAAhK,EAAAgK,KAEA8K,EAUA,QAAAE,GAAAC,EAAAjV,EAAA8U,GACAG,EAAAF,QAAA,SAAArU,GACA,GAAAuB,GAAAjC,EAAAU,EACA0D,UAAAnC,IACA6S,EAAApU,GAAAuB,KAWA,QAAAiT,GAAAlV,EAAA8U,GACAnT,OAAAiI,KAAAkL,GAAAC,QAAA,SAAA/K,GACA8K,EAAAjT,eAAAmI,IAAAhK,EAAA6B,eAAAmI,KACA8K,EAAA9K,GAAAhK,EAAAgK,MAUA,QAAAmL,GAAAhY,GACA,MAAAiY,YAAAjY,EAAAkY,aAAAlY,EAAAmY,SAAAC,OAAA,IASA,QAAAC,GAAArY,GACA,WAAAA,EAAAkY,aAAAlY,EAAAmY,SAAAhT,QAAA,aASA,QAAAmT,GAAAtY,GACA,GAAAuY,GAAAP,EAAAhY,EACA,OAAAuY,IAAA,GAAAA,EAAA,EAGA,GAAAC,GACArV,OAAAsV,SACAtV,OAAAsV,QAAAD,OACA,kBAAArV,QAAAsV,QAAAD,MAEArV,OAAAsV,QAAAD,MAAAE,KAAAvV,OAAAsV,SACA,aAEAE,EACAxV,OAAAsV,SACAtV,OAAAsV,QAAAE,MACA,kBAAAxV,QAAAsV,QAAAE,KAEAxV,OAAAsV,QAAAE,KAAAD,KAAAvV,OAAAsV,SACA,YAEA,QACAV,yBACAF,sBACAH,cACAY,WACAD,WACAG,QACAG,UAoCAlG,EAAA,mBACA,gBACA,WACA,SACAmG,EACAC,GA4CA,QAAAC,GAAA/D,GACAhI,EAAAgM,aAAAhE,EAGA,QAAAiE,GAAAC,GACAJ,EAAAd,uBAAAkB,EAAAlM,GAGA,QAAAmM,GAAAlZ,EAAA0L,EAAA8L,EAAA2B,EAAAC,GACApZ,EAAAqZ,WAAA3N,EAAA8L,GACAxX,EAAAsZ,WAAA5N,EAAAyN,EAAAC,GAAApZ,EAAAuZ,aAcA,QAAAC,GAAAxZ,EAAAsW,EAAA5K,EAAA0N,GACA,GAAA9C,YAAAmD,aACA,MAAAnD,EAEA5K,MAAA1L,EAAA0Z,YACA,IAAAlC,GAAAxX,EAAA2Z,cAEA,OADAT,GAAAlZ,EAAA0L,EAAA8L,EAAAlB,EAAA8C,GACA5B,EAGA,QAAAoC,GAAArW,GACA,kBAAAA,EAKA,QAAAsW,GAAAvD,GACA,MAAAA,aAAAC,YACAD,YAAAG,YAIA,QAAAqD,GAAAX,GACA,MAAAA,GAAAvZ,OAAAuZ,IAAA9Z,KAMA,QAAA0a,GAAAxW,EAAA3D,GACA,GAAAR,EASA,IAPAA,EADA4a,EAAAzU,KAAAhC,GACA,EACK0W,EAAA1U,KAAAhC,GACL,EAEA,EAGA3D,EAAAR,EAAA,EACA,mDAAAmE,EAAA,YACAnE,EAAA,QAAAQ,EACA,sCAAAR,EACA,0BAGA,OAAAA,GAGA,QAAA8a,GAAAf,EAAAgB,GACA,MAAAhB,GAAA/Z,eAAA+Z,EAAAiB,MAAAL,EAAAI,EAAAL,EAAAX,GAAAvZ,QAGA,QAAAya,GAAAlB,EAAA5V,GACA,GAAAqV,EAAArB,cAAA4B,GACA,MAAAA,EAGA,IAAAP,EAAArB,cAAA4B,EAAA9Z,MACA,MAAA8Z,GAAA9Z,IAGA4J,OAAAqR,QAAAnB,KACAA,GACA9Z,KAAA8Z,GAIA,IAAAoB,GAAApB,EAAAzN,IAQA,OAPA6O,KAEAA,EADAX,EAAArW,GACAuT,YAEAM,cAGA,GAAAmD,GAAApB,EAAA9Z,MAmJA,QAAAmb,GAAAxa,EAAAd,GACA,GAAAub,KAiBA,OAhBAjW,QAAAiI,KAAAvN,GAAA0Y,QAAA,SAAAuC,GACA,IAAAP,EAAAO,GAAA,CACA,GAAAhB,GAAAja,EAAAib,GACAO,EAAAvB,EAAAwB,QAAAxB,EAAA5V,MAAA4V,EAAAuB,YAAA3N,EAAAgM,aAAAoB,EACA7D,EAAA+D,EAAAlB,EAAAgB,EACAM,GAAAC,IACAlD,OAAAgC,EAAAxZ,EAAAsW,EAAArP,OAAAkS,EAAAC,UACAha,cAAA8a,EAAAf,EAAAgB,GACAzO,KAAAkN,EAAAvC,uBAAAC,GACAxD,UAAA7L,SAAAkS,EAAArG,UAAAqG,EAAArG,UAAA+G,EAAAvD,GACAsE,OAAAzB,EAAAyB,QAAA,EACAC,OAAA1B,EAAA0B,QAAA,EACAzB,SAAAD,EAAAC,aAIAqB,EAuCA,QAAAK,GAAA9a,EAAA+a,EAAA5B,EAAA0B,GACA1B,EAAAkB,EAAAlB,GACA0B,GACA7a,EAAAqZ,WAAArZ,EAAA0Z,aAAAqB,EAAAvD,QACAxX,EAAAgb,cAAAhb,EAAA0Z,aAAAmB,EAAA1B,IAEAD,EAAAlZ,IAAA0Z,aAAAqB,EAAAvD,OAAA2B,EAAA4B,EAAA3B,UA6IA,QAAA1W,GAAA1C,EAAAd,GACA,GAAA6C,IACA0Y,QAAAD,EAAAxa,EAAAd,IAEA+b,EAAA/b,EAAA+b,OAUA,OATAA,IACAA,EAAAZ,EAAAY,EAAA,WACAlZ,EAAAkZ,QAAAzB,EAAAxZ,EAAAib,EAAAjb,EAAAkb,sBACAnZ,EAAAoZ,YAAAF,EAAArb,OACAmC,EAAAqZ,YAAAxC,EAAAvC,uBAAA4E,IAEAlZ,EAAAoZ,YAAAE,EAAAnc,GAGA6C,EA6BA,QAAAuZ,GAAAtb,EAAAmZ,EAAAgB,GACA,GAAAzO,GAAA,YAAAyO,EAAAna,EAAAkb,qBAAAlb,EAAA0Z,aACApD,EAAA+D,EAAAlB,EAAAgB,EACA,OAAAX,GAAAxZ,EAAAsW,EAAA5K,GA2BA,QAAA6P,GAAAvb,EAAAd,GACA,GAAAsc,KAKA,OAJAhX,QAAAiI,KAAAvN,GAAA0Y,QAAA,SAAA/K,GACA2O,EAAA3O,GAAAyO,EAAAtb,EAAAd,EAAA2N,QAGA2O,EAsCA,QAAAC,GAAAzb,EAAA0b,EAAA3Z,GACA,GAAA4Z,GAAA3b,EAAA4b,mBASA,OARA5b,GAAA6b,gBAAAF,GACAD,EAAA9b,SACA8b,OAEAA,EAAA9D,QAAA,SAAA1V,GACAoQ,KAAAxQ,wBAAA9B,EAAAkC,EAAAH,KAEA/B,EAAA6b,gBAAA,OAEAV,YAAApZ,EAAAoZ,YACAC,YAAArZ,EAAAqZ,YACAU,kBAAAH,GA9lBA,GACA5O,IACAgM,aAAA,IAyEAiB,EAAA,iBACAC,EAAA,gBA2QAoB,EAAA,WACA,GAAAU,IAAA,oCAEA,iBAAA7c,GAEA,OADA2N,GACAmP,EAAA,EAAsBA,EAAAD,EAAAnc,SACtBiN,EAAAkP,EAAAC,KACAnP,IAAA3N,OAFgD8c,GAMhDA,IAAAD,EAAAnc,SACAiN,EAAArI,OAAAiI,KAAAvN,GAAA,GAEA,IAAAia,GAAAja,EAAA2N,GACAjN,EAAAka,EAAAX,GAAAvZ,OACAR,EAAA8a,EAAAf,EAAAtM,GACAsO,EAAAvb,EAAAR,CACA,IAAAQ,EAAAR,EAAA,EACA,sBAAAA,EAAA,2BAAAQ,CAEA,OAAAub,MAwPA,QACAX,0BACAe,0BACAD,wBACA9B,6BACA9W,6BACAoY,+BAEAW,wBAEA3C,qBAEAmD,aAAAjD,EACAkD,kBAAAhC,EACAiC,UAAArC,KAqCArH,EAAA,iBACA,WACA,SACAoG,GAwEA,QAAAuD,GAAApc,EAAA0L,GACA,MAAA2Q,IAAA3Q,GAAA4Q,UAMA,QAAAC,GAAAvc,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAwc,UAAA5O,EAAA+C,IAIA,QAAA8L,GAAAzc,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAA0c,WAAA9O,EAAA+C,IAIA,QAAAgM,GAAA3c,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAA4c,WAAAhP,EAAA+C,IAIA,QAAAkM,GAAA7c,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAA8c,WAAAlP,EAAA+C,IAIA,QAAAoM,GAAA/c,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAgd,WAAApP,EAAA+C,IAIA,QAAAsM,GAAAjd,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAkd,UAAAtP,EAAA+C,IAIA,QAAAwM,GAAAnd,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAod,WAAAxP,EAAA+C,IAIA,QAAA0M,GAAArd,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAsd,WAAA1P,EAAA+C,IAIA,QAAA4M,GAAAvd,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAwd,WAAA5P,EAAA+C,IAIA,QAAA8M,GAAAzd,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAA0d,WAAA9P,EAAA+C,IAIA,QAAAgN,GAAA3d,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAA4d,WAAAhQ,EAAA+C,IAIA,QAAAkN,GAAA7d,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAA8d,YAAAlQ,EAAA+C,IAIA,QAAAoN,GAAA/d,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAge,YAAApQ,EAAA+C,IAIA,QAAAsN,GAAAje,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAke,YAAAtQ,EAAA+C,IAIA,QAAAwN,GAAAne,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAoe,YAAAxQ,EAAA+C,IAIA,QAAA0N,GAAAre,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAse,iBAAA1Q,GAAA,EAAA+C,IAIA,QAAA4N,GAAAve,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAwe,iBAAA5Q,GAAA,EAAA+C,IAIA,QAAA8N,GAAAze,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAA0e,iBAAA9Q,GAAA,EAAA+C,IAIA,QAAAgO,GAAA3e,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAA4e,mBAAAhR,GAAA,EAAA+C,IAIA,QAAAkO,GAAA7e,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAA8e,mBAAAlR,GAAA,EAAA+C,IAIA,QAAAoO,GAAA/e,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAgf,mBAAApR,GAAA,EAAA+C,IAIA,QAAAsO,GAAAjf,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAkf,mBAAAtR,GAAA,EAAA+C,IAIA,QAAAwO,GAAAnf,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAof,mBAAAxR,GAAA,EAAA+C,IAIA,QAAA0O,GAAArf,EAAA4N,GACA,gBAAA+C,GACA3Q,EAAAsf,mBAAA1R,GAAA,EAAA+C,IAIA,QAAA4O,GAAAvf,EAAA0L,EAAA8T,EAAA5R,GACA,GAAA0O,GAAAF,EAAApc,EAAA0L,EACA,iBAAAvK,GACAnB,EAAAkd,UAAAtP,EAAA4R,GACAxf,EAAAyf,cAAAzf,EAAA0f,SAAAF,GACAxf,EAAA2f,YAAArD,EAAAnb,IAIA,QAAAye,GAAA5f,EAAA0L,EAAA8T,EAAA5R,EAAAwM,GAGA,OAFAkC,GAAAF,EAAApc,EAAA0L,GACAmU,EAAA,GAAA7I,YAAAoD,GACA4B,EAAA,EAAoBA,EAAA5B,IAAW4B,EAC/B6D,EAAA7D,GAAAwD,EAAAxD,CAGA,iBAAA8D,GACA9f,EAAAod,WAAAxP,EAAAiS,GACAC,EAAAlI,QAAA,SAAAzW,EAAA6T,GACAhV,EAAAyf,cAAAzf,EAAA0f,SAAAG,EAAA7K,IACAhV,EAAA2f,YAAArD,EAAAnb,MA8DA,QAAA4e,GAAAld,EAAAmd,GAIA,MAHAA,MAAA,IACAA,EAEAnd,EAAAsD,MAAA,MAAAuN,IAAA,SAAAuM,EAAAC,GACA,MAAAA,GAAAF,EAAA,KAAAC,IACKnX,KAAA,MAaL,QAAAqX,GAAAngB,EAAAogB,EAAAC,EAAAC,GACA,GAAAC,GAAAD,GAAA9H,EAEAgI,EAAAxgB,EAAAygB,aAAAJ,GAaAL,EAAA,CACAU,IAAAnb,KAAA6a,KACAJ,EAAA,EACAI,IAAAta,QAAA4a,GAAA,KAIA1gB,EAAAogB,aAAAI,EAAAJ,GAGApgB,EAAA2gB,cAAAH,EAGA,IAAAI,GAAA5gB,EAAA6gB,mBAAAL,EAAAxgB,EAAA8gB,eACA,KAAAF,EAAA,CAEA,GAAAG,GAAA/gB,EAAAghB,iBAAAR,EAGA,OAFAD,GAAAR,EAAAK,EAAAJ,GAAA,iCAAAe,GACA/gB,EAAAihB,aAAAT,GACA,KAGA,MAAAA,GAqBA,QAAAU,GACAlhB,EAAAmhB,EAAAC,EAAAC,EAAAf,GACA,kBAAAe,KACAf,EAAAe,EACAA,EAAApa,QAEA,kBAAAma,KACAd,EAAAc,EACAA,EAAAna,OAEA,IAAAsZ,GAAAD,GAAA9H,EACA3W,EAAA7B,EAAAkhB,eACAC,GAAAvJ,QAAA,SAAA4I,GACAxgB,EAAAshB,aAAAzf,EAAA2e,KAEAY,GACAA,EAAAxJ,QAAA,SAAA+C,EAAAuF,GACAlgB,EAAAuhB,mBACA1f,EACAwf,IAAAnB,KACAvF,KAGA3a,EAAAwhB,YAAA3f,EAGA,IAAA4f,GAAAzhB,EAAA0hB,oBAAA7f,EAAA7B,EAAA2hB,YACA,KAAAF,EAAA,CAEA,GAAAV,GAAA/gB,EAAA4hB,kBAAA/f,EAIA,OAHA0e,GAAA,4BAAAQ,GAEA/gB,EAAA6hB,cAAAhgB,GACA,KAEA,MAAAA,GAYA,QAAAigB,GACA9hB,EAAA+hB,EAAAC,EAAA1B,GACA,GACAD,GADAD,EAAA,GAEA6B,EAAA1gB,SAAA2gB,eAAAH,EACA,KAAAE,EACA,yCAAAF,CAIA,IAFA3B,EAAA6B,EAAAE,MAEAH,EACA,yBAAAC,EAAAvW,KACA2U,EAAArgB,EAAAoiB,kBACO,4BAAAH,EAAAvW,KACP2U,EAAArgB,EAAAqiB,oBACO,IAAAhC,IAAArgB,EAAAoiB,eAAA/B,IAAArgB,EAAAqiB,gBACP,qCAIA,OAAAlC,GACAngB,EAAAogB,EAAA4B,IAAA3B,EACAC,GA6BA,QAAAgC,GACAtiB,EAAAuiB,EAAAnB,EAAAC,EAAAf,GAEA,OADAa,MACAnF,EAAA,EAAoBA,EAAAuG,EAAA3iB,SAA6Boc,EAAA,CACjD,GAAAwE,GAAAsB,EACA9hB,EAAAuiB,EAAAvG,GAAAhc,EAAAwiB,GAAAxG,IAAAsE,EACA,KAAAE,EACA,WAEAW,GAAAlb,KAAAua,GAEA,MAAAU,GAAAlhB,EAAAmhB,EAAAC,EAAAC,EAAAf,GAwBA,QAAAmC,GACAziB,EAAA0iB,EAAAtB,EAAAC,EAAAf,GAEA,OADAa,MACAnF,EAAA,EAAoBA,EAAA0G,EAAA9iB,SAA2Boc,EAAA,CAC/C,GAAAwE,GAAAL,EACAngB,EAAA0iB,EAAA1G,GAAAhc,EAAAwiB,GAAAxG,IAAAsE,EACA,KAAAE,EACA,WAEAW,GAAAlb,KAAAua,GAEA,MAAAU,GAAAlhB,EAAAmhB,EAAAC,EAAAC,EAAAf,GAaA,QAAAqC,GAAA3iB,EAAA6B,GAUA,QAAA+gB,GAAA/gB,EAAAghB,GACA,GAAAjV,GAAA5N,EAAA8iB,mBAAAjhB,EAAAghB,EAAAtf,MACA+W,EAAAuI,EAAAzI,KAAA,WAAAyI,EAAAtf,KAAA6U,QAAA,GACA1M,EAAAmX,EAAAnX,KACAqX,EAAA1G,GAAA3Q,EACA,KAAAqX,EACA,wBAAArX,EAAAjB,SAAA,GAEA,IAAAsY,EAAAzG,UAAA,CAEA,GAAAkD,GAAAwD,CAGA,OAFAA,IAAAH,EAAAzI,KAEAE,EACAyI,EAAAE,YAAAjjB,EAAA0L,EAAA8T,EAAA5R,EAAAiV,EAAAzI,MAEA2I,EAAAG,OAAAljB,EAAA0L,EAAA8T,EAAA5R,EAAAiV,EAAAzI,MAGA,MAAA2I,GAAAE,aAAA3I,EACAyI,EAAAE,YAAAjjB,EAAA4N,GAEAmV,EAAAG,OAAAljB,EAAA4N,GAQA,OAvCAoV,GAAA,EAoCAG,KACAC,EAAApjB,EAAA0hB,oBAAA7f,EAAA7B,EAAAqjB,iBAEArH,EAAA,EAAoBA,EAAAoH,IAAkBpH,EAAA,CACtC,GAAA6G,GAAA7iB,EAAAsjB,iBAAAzhB,EAAAma,EACA,KAAA6G,EACA,KAEA,IAAAtf,GAAAsf,EAAAtf,IAEA,SAAAA,EAAA6U,QAAA,KACA7U,IAAA6U,OAAA,EAAA7U,EAAA3D,OAAA,GAEA,IAAAsjB,GAAAN,EAAA/gB,EAAAghB,EACAM,GAAA5f,GAAA2f,EAEA,MAAAC,GA+CA,QAAAI,GAAAvjB,EAAA6B,GAKA,OAJAuhB,GAAApjB,EAAA0hB,oBAAA7f,EAAA7B,EAAAqjB,iBACAG,KACAC,KAEAzH,EAAA,EAAoBA,EAAAoH,IAAkBpH,EAAA,CACtCyH,EAAAxd,KAAA+V,GACAwH,EAAAvd,QACA,IAAA4c,GAAA7iB,EAAAsjB,iBAAAzhB,EAAAma,EACA,KAAA6G,EACA,KAGAW,GAAAxH,GAAAzY,KAAAsf,EAAAtf,OAIA,wBACA,wBACA,mCACA,4BACAqU,QAAA,SAAA8L,GACA,GAAAC,GAAAD,EAAA,GACA7W,EAAA6W,EAAA,EACA1jB,GAAA4jB,kBAAA/hB,EAAA4hB,EAAAzjB,EAAA2jB,IAAA/L,QAAA,SAAA9S,EAAAob,GACAsD,EAAAtD,GAAArT,GAAA/H,KAIA,IAAA+e,MAEAC,EAAA9jB,EAAA0hB,oBAAA7f,EAAA7B,EAAA+jB,sBACA,KAAA/H,EAAA,EAAgBA,EAAA8H,IAAuB9H,EAAA,CACvC,GAAAzY,GAAAvD,EAAAgkB,0BAAAniB,EAAAma,GACAiI,GACAjP,MAAAgH,EACAkI,mBAAAlkB,EAAAmkB,+BAAAtiB,EAAAma,EAAAhc,EAAAokB,2CACAC,qBAAArkB,EAAAmkB,+BAAAtiB,EAAAma,EAAAhc,EAAAskB,6CACAlK,KAAApa,EAAAmkB,+BAAAtiB,EAAAma,EAAAhc,EAAAukB,yBACAd,eAAAzjB,EAAAmkB,+BAAAtiB,EAAAma,EAAAhc,EAAAwkB,sCAEAP,GAAAQ,KAAAR,EAAAS,oBAAAT,EAAAI,qBACAR,EAAAtgB,GAAA0gB,EAGA,OACAJ,aACAL,eA0CA,QAAAmB,GAAA3kB,EAAA6B,EAAA+iB,EAAAC,GACA,GAAAhB,GAAAe,EAAAf,WACAL,EAAAoB,EAAApB,YACAS,EAAAJ,EAAAgB,EACA,KAAAZ,EAEA,MADAtL,GAAA,iCAAAkM,IAEAthB,KAAAshB,EACA/jB,YAGA,IAAAqY,GAAA,GAAA1B,aAAAwM,EAAA7J,MACA5C,EAAAxX,EAAA2Z,eACAmL,EAAAb,EAAAjP,KACAhV,GAAAqZ,WAAArZ,EAAA+kB,eAAAvN,GACAxX,EAAAglB,oBAAAnjB,EAAAoiB,EAAAjP,MAAA8P,EAEA,IAAA/P,GAAA8P,EAAA,GACAI,IAAA1f,KAAAwP,KACAA,IAAAjP,QAAAmf,GAAA,KAEA,IAAAnkB,KAYA,OAXAmjB,GAAAR,eAAA7L,QAAA,SAAAsN,GACA,GAAA7lB,GAAAmkB,EAAA0B,GACAnC,EAAA1G,GAAAhd,EAAAqM,MACA6O,EAAAwI,EAAAxI,KACA3a,EAAAP,EAAA+a,KAAA2I,EAAA3I,KACA7W,EAAAlE,EAAAkE,IACAA,GAAA6U,OAAA,EAAArD,EAAAnV,UAAAmV,IACAxR,IAAA6U,OAAArD,EAAAnV,SAEAkB,EAAAyC,GAAA,GAAAgX,GAAApB,EAAA9Z,EAAAwb,OAAAjb,EAAA2a,EAAA4K,sBAGA5hB,KAAAshB,EACA1L,QACAiM,QAAA,GAAAhO,cAAA+B,GACA3B,SACA1W,YAoBA,QAAAukB,GAAArlB,EAAAkC,EAAA2iB,GACA,MAAAF,GAAA3kB,EAAAkC,EAAAL,QAAAK,EAAA0iB,iBAAAC,GAqBA,QAAAS,GAAAtlB,EAAAkC,EAAAqjB,GACA,GAAAX,GAAA1iB,EAAA0iB,kBAAA1iB,EACA+hB,EAAAW,EAAAf,WAAA0B,EAAAhiB,KACA,IAAA0gB,EAAA,CACA,GAAAuB,GAAAvB,EAAAjP,KAEA,OADAhV,GAAAylB,gBAAAzlB,EAAA+kB,eAAAS,EAAAD,EAAA/N,OAAA+N,EAAA1K,QAAA,EAAA0K,EAAApM,MAAAuM,aACA,EAEA,SAkBA,QAAAC,GAAA3lB,EAAAkC,EAAAqjB,GACAD,EAAAtlB,EAAAkC,EAAAqjB,IACAvlB,EAAAsZ,WAAAtZ,EAAA+kB,eAAAQ,EAAApM,MAAAnZ,EAAA4lB,cAgCA,QAAAC,GAAAN,EAAAO,GACA,GAAAhlB,GAAAykB,EAAAzkB,QACA,QAAAyC,KAAAuiB,GAAA,CACA,GAAA3M,GAAArY,EAAAyC,EACA,IAAA4V,EAAA,CACA,GAAArU,GAAAghB,EAAAviB,EACAuB,GAAAlF,OACAuZ,EAAAjU,IAAAJ,GAEAqU,EAAA,GAAArU,IA4GA,QAAA9C,GAAA+jB,EAAAD,GAGA,OAFAE,GAAAD,EAAA5C,gBAAA4C,EACAE,EAAAlc,UAAAnK,OACAsmB,EAAA,EAAsBA,EAAAD,IAAgBC,EAAA,CACtC,GAAAC,GAAApc,UAAAmc,EACA,IAAAjd,MAAAqR,QAAA6L,GAEA,OADAC,GAAAD,EAAAvmB,OACAoc,EAAA,EAAwBA,EAAAoK,IAAgBpK,EACxCha,EAAAgkB,EAAAG,EAAAnK,QAGA,QAAAzY,KAAA4iB,GAAA,CACA,GAAAjD,GAAA8C,EAAAziB,EACA2f,IACAA,EAAAiD,EAAA5iB,MAgBA,QAAA8iB,GAAArmB,EAAA6B,GAIA,QAAAykB,GAAAtR,GACA,gBAAAuR,GACAvmB,EAAAqZ,WAAArZ,EAAA0Z,aAAA6M,EAAA/O,QACAxX,EAAAwmB,wBAAAxR,GACAhV,EAAAymB,oBACAzR,EAAAuR,EAAAnnB,eAAAmnB,EAAAnM,KAAAmM,EAAA7a,MAAA1L,EAAAqX,MAAAkP,EAAAzT,YAAA,EAAAyT,EAAA3L,QAAA,EAAA2L,EAAA1L,QAAA,IAIA,QAAA6L,GAAA1R,EAAA+N,GACA,GAAA4D,GAAA5D,EAAA3I,KACAwM,EAAA7D,EAAA6D,KAEA,iBAAAL,GACAvmB,EAAAqZ,WAAArZ,EAAA0Z,aAAA6M,EAAA/O,OASA,QARApY,GAAAmnB,EAAAnM,MAAAmM,EAAAnnB,eAAAunB,EACAvM,EAAAhb,EAAAwnB,EACAlb,EAAA6a,EAAA7a,MAAA1L,EAAAqX,MACA0L,EAAA1G,GAAA3Q,GACAkP,EAAAmI,EAAA3I,KAAAhb,EACA0T,EAAAyT,EAAAzT,YAAA,EACA+H,EAAA0L,EAAA1L,QAAA,EACAgM,EAAAjM,EAAAgM,EACA7iB,EAAA,EAAuBA,EAAA6iB,IAAW7iB,EAClC/D,EAAAwmB,wBAAAxR,EAAAjR,GACA/D,EAAAymB,oBACAzR,EAAAjR,EAAAqW,EAAA1O,EAAAoH,EAAA8H,EAAAC,EAAAgM,EAAA9iB,IAMA,OAnCA+iB,MAkCAC,EAAA/mB,EAAA0hB,oBAAA7f,EAAA7B,EAAAgnB,mBACAhL,EAAA,EAAoBA,EAAA+K,IAAiB/K,EAAA,CACrC,GAAAjB,GAAA/a,EAAAinB,gBAAAplB,EAAAma,EACA,KAAAjB,EACA,KAEA,IAAA/F,GAAAhV,EAAAknB,kBAAArlB,EAAAkZ,EAAAxX,MACAwf,EAAAoE,GAAApM,EAAArP,KACAqX,GACA+D,EAAA/L,EAAAxX,MAAAmjB,EAAA1R,EAAA+N,GAEA+D,EAAA/L,EAAAxX,MAAA+iB,EAAAtR,GAIA,MAAA8R,GAwDA,QAAAM,GAAArB,EAAAvK,GACA,OAAAjY,KAAAiY,GAAA,CACA,GAAA0H,GAAA6C,EAAAxiB,EACA2f,IACAA,EAAA1H,EAAAjY,KA0CA,QAAAzB,GAAA9B,EAAAkC,EAAAsZ,GACAA,EAAAM,kBACA9b,EAAA6b,gBAAAL,EAAAM,oBAEAsL,EAAAllB,EAAA4kB,eAAA5kB,EAAAsZ,EAAAf,SACAe,EAAAP,SACAjb,EAAAqZ,WAAArZ,EAAAkb,qBAAAM,EAAAP,UA8BA,QAAAoM,GAAArnB,EAAA6B,GACA,GAAAshB,GAAAR,EAAA3iB,EAAA6B,GACAilB,EAAAT,EAAArmB,EAAA6B,GACAK,GACAL,UACAshB,iBACA2D,gBAOA,OAJAjO,GAAAR,SAAArY,KACAkC,EAAA0iB,iBAAArB,EAAAvjB,EAAA6B,IAGAK,EAgCA,QAAAO,GACAzC,EAAA0iB,EAAAtB,EAAAC,EAAAf,GACA,kBAAAe,KACAf,EAAAe,EACAA,EAAApa,QAEA,kBAAAma,KACAd,EAAAc,EACAA,EAAAna,OAEA,IAAAsZ,GAAAD,GAAA9H,EACA8O,GAAA,CAcA,IAbA5E,IAAAhP,IAAA,SAAA9G,GAEA,GAAAA,EAAAzH,QAAA,SACA,GAAAoiB,GAAAhmB,SAAA2gB,eAAAtV,EACA2a,GAIA3a,EAAA2a,EAAApF,MAHA5B,EAAA,uBAAA3T,GACA0a,GAAA,GAKA,MAAA1a,MAEA0a,EACA,WAEA,IAAAzlB,GAAA4gB,EAAAziB,EAAA0iB,EAAAtB,EAAAC,EAAAf,EACA,OAAAze,GAGAwlB,EAAArnB,EAAA6B,GAFA,KA7uCA,GAAA2W,GAAAK,EAAAL,MACAG,EAAAE,EAAAF,KAEAtB,EAAA,KACAmQ,EAAA,MACAC,EAAA,MACAC,EAAA,MACAzQ,EAAA,KACA0Q,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACA9R,GAAA,KACA+R,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MAEAC,GAAA,KACAC,GAAA,MACAC,GAAA,MACAC,GAAA,MAEA3N,KAqLAA,IAAAhF,IAA4CkD,KAAAnD,aAAAgD,KAAA,EAAA8I,OAAA3G,EAAA0G,YAAAxG,GAC5CJ,GAAAmL,IAA4CjN,KAAAnD,aAAAgD,KAAA,EAAA8I,OAAAvG,GAC5CN,GAAAoL,IAA4ClN,KAAAnD,aAAAgD,KAAA,GAAA8I,OAAArG,GAC5CR,GAAAqL,IAA4CnN,KAAAnD,aAAAgD,KAAA,GAAA8I,OAAAnG,GAC5CV,GAAApF,IAA4CsD,KAAAvD,WAAAoD,KAAA,EAAA8I,OAAAjG,EAAAgG,YAAA9F,GAC5Cd,GAAAsL,KAA4CpN,KAAAvD,WAAAoD,KAAA,EAAA8I,OAAA7F,GAC5ChB,GAAAuL,KAA4CrN,KAAAvD,WAAAoD,KAAA,GAAA8I,OAAA3F,GAC5ClB,GAAAwL,KAA4CtN,KAAAvD,WAAAoD,KAAA,GAAA8I,OAAAzF,GAC5CpB,GAAAlF,KAA4CoD,KAAArD,YAAAkD,KAAA,EAAA8I,OAAAvF,EAAAsF,YAAApF,GAC5CxB,GAAA6M,KAA4C3O,KAAArD,YAAAkD,KAAA,EAAA8I,OAAAnF,GAC5C1B,GAAA8M,KAA4C5O,KAAArD,YAAAkD,KAAA,GAAA8I,OAAAjF,GAC5C5B,GAAA+M,KAA4C7O,KAAArD,YAAAkD,KAAA,GAAA8I,OAAA/E,GAC5C9B,GAAAyL,KAA4CvN,KAAArD,YAAAkD,KAAA,EAAA8I,OAAAjG,EAAAgG,YAAA9F,GAC5Cd,GAAA0L,KAA4CxN,KAAArD,YAAAkD,KAAA,EAAA8I,OAAA7F,GAC5ChB,GAAA2L,KAA4CzN,KAAArD,YAAAkD,KAAA,GAAA8I,OAAA3F,GAC5ClB,GAAA4L,KAA4C1N,KAAArD,YAAAkD,KAAA,GAAA8I,OAAAzF,GAC5CpB,GAAA6L,KAA4C3N,KAAAnD,aAAAgD,KAAA,GAAA8I,OAAA7E,GAC5ChC,GAAA8L,KAA4C5N,KAAAnD,aAAAgD,KAAA,GAAA8I,OAAA3E,GAC5ClC,GAAA+L,KAA4C7N,KAAAnD,aAAAgD,KAAA,GAAA8I,OAAAzE,GAC5CpC,GAAAoM,KAA4ClO,KAAAnD,aAAAgD,KAAA,GAAA8I,OAAAvE,GAC5CtC,GAAAqM,KAA4CnO,KAAAnD,aAAAgD,KAAA,GAAA8I,OAAAnE,GAC5C1C,GAAAsM,KAA4CpO,KAAAnD,aAAAgD,KAAA,GAAA8I,OAAArE,GAC5CxC,GAAAuM,KAA4CrO,KAAAnD,aAAAgD,KAAA,GAAA8I,OAAA/D,GAC5C9C,GAAAwM,KAA4CtO,KAAAnD,aAAAgD,KAAA,GAAA8I,OAAAjE,GAC5C5C,GAAAyM,KAA4CvO,KAAAnD,aAAAgD,KAAA,GAAA8I,OAAA7D,GAC5ChD,GAAAgM,KAA4C9N,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAAuN,IAC5CxN,GAAAiM,KAA4C/N,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAAwN,IAC5CzN,GAAAkM,KAA4ChO,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAAyN,IAC5C1N,GAAAmM,KAA4CjO,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAAuN,IAC5CxN,GAAA0M,KAA4CxO,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAA0N,IAC5C3N,GAAA2M,KAA4CzO,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAA0N,IAC5C3N,GAAA4M,KAA4C1O,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAAwN,IAC5CzN,GAAAgN,KAA4C9O,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAAuN,IAC5CxN,GAAAiN,KAA4C/O,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAAyN,IAC5C1N,GAAAkN,KAA4ChP,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAAwN,IAC5CzN,GAAAmN,KAA4CjP,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAA0N,IAC5C3N,GAAAoN,KAA4ClP,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAAuN,IAC5CxN,GAAAqN,KAA4CnP,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAAyN,IAC5C1N,GAAAsN,KAA4CpP,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAAwN,IAC5CzN,GAAAuN,KAA4CrP,KAAA,KAAAH,KAAA,EAAA8I,OAAA3D,EAAA0D,YAAArD,EAAAtD,UAAA0N,GAE5C,IAAA7C,MACAA,IAAAe,KAA6B9N,KAAA,EAAAwM,MAAA,GAC7BO,GAAAgB,KAA6B/N,KAAA,EAAAwM,MAAA,GAC7BO,GAAAiB,KAA6BhO,KAAA,GAAAwM,MAAA,EAG7B,IAmBAlG,IAAA,YA6IA8B,IACA,gBACA,mBA0OAyC,GAAA,YAmlBA,QACAoB,yBAEAnF,gBACAoB,2BACAG,2BACAhgB,oBACA4kB,+BACA1E,uBACAY,oCACAoB,oCACAU,yBAEA+B,gBACAtlB,0BACAE,cACA2jB,kBACAE,mBACAP,sBAqCA7S,EAAA,aACA,cACA,SACAwX,GA6BA,QAAAhoB,GAAAjC,EAAA+B,EAAA2J,EAAAkb,EAAA/L,GACAnP,EAAAzE,SAAAyE,EAAA1L,EAAAkqB,UAAAxe,CACA,IAAAuP,GAAAlZ,EAAAkZ,QACAG,EAAArZ,EAAAqZ,YACAD,EAAAlU,SAAA2f,EAAA7kB,EAAAoZ,YAAAyL,CACA/L,GAAA5T,SAAA4T,EAAA,EAAAA,EACAO,GAAAH,EACAjb,EAAAmqB,aAAAze,EAAAyP,EAAAlU,SAAAmU,EAAApb,EAAA+W,eAAAhV,EAAAqZ,YAAAP,GAEA7a,EAAAoqB,WAAA1e,EAAAmP,EAAAM,GA4CA,QAAAkP,GAAArqB,EAAAsqB,GACA,GAAAC,GAAA,KACAC,EAAA,IAEAF,GAAA1S,QAAA,SAAAhT,GACA,GAAAA,EAAA6lB,UAAA,GAIA,GAAAvoB,GAAA0C,EAAA1C,YACAH,EAAA6C,EAAA8lB,iBAAA9lB,EAAA7C,WACA4oB,GAAA,EACAjf,EAAAzE,SAAArC,EAAA8G,KAAA1L,EAAAkqB,UAAAtlB,EAAA8G,IAEAxJ,KAAAqoB,IACAA,EAAAroB,EACAlC,EAAA2B,WAAAO,EAAAL,SAMA8oB,GAAA,IAIAA,GAAA5oB,IAAAyoB,KACAA,KAAA1O,oBAAA/Z,EAAA+Z,mBACA9b,EAAA6b,gBAAA,MAEA2O,EAAAzoB,EACAkoB,EAAAnoB,wBAAA9B,EAAAkC,EAAAH,IAIAkoB,EAAAjoB,YAAAE,EAAA0C,EAAA9D,UAGAmB,EAAAjC,EAAA+B,EAAA2J,EAAA9G,EAAAgiB,MAAAhiB,EAAAiW,WAGA2P,EAAA1O,mBACA9b,EAAA6b,gBAAA,MAMA,OACA5Z,iBACAooB,oBAqCA5X,EAAA,iBACA,gBACA,WACA,SACAmG,EACAC,GA4DA,QAAA+R,GAAAC,GACA9d,EAAA+d,aAAA,GAAArU,aAAA,IAAAoU,EAAA,OAAAA,EAAA,OAAAA,EAAA,OAAAA,EAAA,KAGA,QAAA7R,GAAAC,GACAJ,EAAAd,uBAAAkB,EAAAlM,GACAkM,EAAA6R,cACAF,EAAA3R,EAAA6R,cA2IA,QAAAC,GAAA/qB,EAAAqP,GACApI,SAAAoI,EAAA2b,uBACAC,EAAAD,qBAAAhrB,EAAAkY,aAAAlY,EAAAkrB,oCACAlrB,EAAAmrB,YAAAnrB,EAAAkrB,mCAAA7b,EAAA2b,uBAEA/jB,SAAAoI,EAAA+b,mBACAH,EAAAG,iBAAAprB,EAAAkY,aAAAlY,EAAAqrB,gCACArrB,EAAAmrB,YAAAnrB,EAAAqrB,+BAAAhc,EAAA+b,mBAEAnkB,SAAAoI,EAAAic,QACAL,EAAAK,MAAAtrB,EAAAkY,aAAAlY,EAAAurB,qBACAvrB,EAAAmrB,YAAAnrB,EAAAurB,oBAAAlc,EAAAic,QASA,QAAAE,GAAAxrB,EAAAqP,GACApI,SAAAoI,EAAA2b,sBACAhrB,EAAAmrB,YAAAnrB,EAAAkrB,mCAAAD,EAAAD,sBAEA/jB,SAAAoI,EAAA+b,kBACAprB,EAAAmrB,YAAAnrB,EAAAqrB,+BAAAJ,EAAAG,kBAEAnkB,SAAAoI,EAAAic,OACAtrB,EAAAmrB,YAAAnrB,EAAAurB,oBAAAN,EAAAK,OAYA,QAAAG,GAAAzrB,EAAA0rB,EAAArc,GACA,GAAA1C,GAAA0C,EAAA1C,QAAA3M,EAAA6pB,UACA7pB,GAAA2f,YAAAhT,EAAA+e,GACArc,EAAAsc,KACA3rB,EAAA4rB,cAAAjf,EAAA3M,EAAA6rB,mBAAAxc,EAAAsc,KAEAtc,EAAAyc,KACA9rB,EAAA4rB,cAAAjf,EAAA3M,EAAA+rB,mBAAA1c,EAAAyc,KAEAzc,EAAAvM,OACA9C,EAAA4rB,cAAAjf,EAAA3M,EAAAgsB,eAAA3c,EAAAvM,MACA9C,EAAA4rB,cAAAjf,EAAA3M,EAAAisB,eAAA5c,EAAAvM,MACA6J,IAAA3M,EAAA+pB,YACA/pB,EAAA4rB,cAAAjf,EAAA3M,EAAAksB,eAAA7c,EAAAvM,OAGAuM,EAAA8c,OACAnsB,EAAA4rB,cAAAjf,EAAA3M,EAAAksB,eAAA7c,EAAA8c,OAEA9c,EAAA+c,OACApsB,EAAA4rB,cAAAjf,EAAA3M,EAAAgsB,eAAA3c,EAAA+c,OAEA/c,EAAAgd,OACArsB,EAAA4rB,cAAAjf,EAAA3M,EAAAisB,eAAA5c,EAAAgd,OAEAhd,EAAAid,QACAtsB,EAAA4rB,cAAAjf,EAAA3M,EAAAusB,gBAAAld,EAAAid,QAEAjd,EAAAmd,QACAxsB,EAAA4rB,cAAAjf,EAAA3M,EAAAysB,gBAAApd,EAAAmd,QAEAnd,EAAAqd,WACA1sB,EAAA4rB,cAAAjf,EAAA3M,EAAA2sB,mBAAAtd,EAAAqd,WAEArd,EAAAud,UACA5sB,EAAA4rB,cAAAjf,EAAA3M,EAAA6sB,kBAAAxd,EAAAud,UAUA,QAAAE,GAAAjC,GAEA,MADAA,MAAA9d,EAAA+d,aACAvT,EAAAsT,GACAA,EAEA,GAAApU,aAAA,IAAAoU,EAAA,OAAAA,EAAA,OAAAA,EAAA,OAAAA,EAAA,KAQA,QAAAkC,GAAAjoB,GACA,YAAAA,IAAA,GAeA,QAAAkoB,GAAAhtB,EAAA0rB,EAAArc,EAAAlP,EAAAD,GACAmP,KAAAtC,EAAAkgB,cACA,IAAAtgB,GAAA0C,EAAA1C,QAAA3M,EAAA6pB,UACA1pB,MAAAkP,EAAAlP,MACAD,KAAAmP,EAAAnP,OACAF,EAAA2f,YAAAhT,EAAA+e,GACAqB,EAAA5sB,IAAA4sB,EAAA7sB,GAKAF,EAAAktB,eAAAvgB,IAJA3M,EAAA4rB,cAAAjf,EAAA3M,EAAA6rB,mBAAA7rB,EAAAmtB,QACAntB,EAAA4rB,cAAAjf,EAAA3M,EAAAgsB,eAAAhsB,EAAA+C,eACA/C,EAAA4rB,cAAAjf,EAAA3M,EAAAisB,eAAAjsB,EAAA+C,gBAaA,QAAAqqB,GAAAptB,EAAAqP,GAEA,MADAA,SACAA,EAAAge,gBACArtB,EAAAstB,4BACAttB,EAAAutB,4BACAvtB,EAAAwtB,4BACAxtB,EAAAytB,4BACAztB,EAAA0tB,4BACA1tB,EAAA2tB,6BAuBA,QAAAC,GAAA5tB,EAAAqP,GACA,GAAAwe,GAAAT,EAAAptB,EAAAqP,GAEAye,EAAAD,EAAAna,IAAA,SAAAqa,EAAA7N,GACA,OAAc6N,OAAA7N,QAKd,OAHA4N,GAAAE,KAAA,SAAAvlB,EAAA8d,GACA,MAAA9d,GAAAslB,KAAAxH,EAAAwH,OAEAD,EA4GA,QAAAG,MAUA,QAAAC,GAAAC,EAAAC,EAAAjjB,GAQA,QAAAkjB,KACAC,EAAA7e,oBAAA,QAAA8e,GACAD,EAAA7e,oBAAA,OAAA+e,GACAF,EAAA,KAGA,QAAAC,KACA,GAAAE,GAAA,wBAAAN,CACAtV,GAAAL,MAAAiW,GACAtjB,EAAAsjB,EAAAH,GACAD,IAGA,QAAAG,KACArjB,EAAA,KAAAmjB,GACAD,IAtBAljB,KAAA8iB,CACA,IAAAK,GAAA,GAAAI,MA2BA,OA1BAN,GAAAnnB,SAAAmnB,IAAArhB,EAAAqhB,YACAnnB,SAAAmnB,IACAE,EAAAF,eAqBAE,EAAA/rB,iBAAA,QAAAgsB,GACAD,EAAA/rB,iBAAA,OAAAisB,GACAF,EAAAzrB,IAAAsrB,EACAG,EAYA,QAAAK,GAAA3uB,EAAA0rB,EAAArc,GACAA,KAAAtC,EAAAkgB,cACA,IAAAtgB,GAAA0C,EAAA1C,QAAA3M,EAAA6pB,UAEA,IADA7pB,EAAA2f,YAAAhT,EAAA+e,GACArc,EAAAwb,SAAA,GAKA,GAAAA,GAAAiC,EAAAzd,EAAAwb,MACA,IAAAle,IAAA3M,EAAA8pB,iBACA,OAAA9N,GAAA,EAAsBA,EAAA,IAAQA,EAC9Bhc,EAAA4uB,WAAA5uB,EAAAstB,4BAAAtR,EAAA,EAAAhc,EAAA6uB,KAAA,MAAA7uB,EAAA6uB,KAAA7uB,EAAA0W,cAAAmU,OAEKle,KAAA3M,EAAA+pB,WACL/pB,EAAA8uB,WAAAniB,EAAA,EAAA3M,EAAA6uB,KAAA,QAAA7uB,EAAA6uB,KAAA7uB,EAAA0W,cAAAmU,GAEA7qB,EAAA4uB,WAAAjiB,EAAA,EAAA3M,EAAA6uB,KAAA,MAAA7uB,EAAA6uB,KAAA7uB,EAAA0W,cAAAmU,IAwDA,QAAAkE,GAAA/uB,EAAA0rB,EAAArc,EAAAlE,GACAA,KAAA8iB,EACA5e,KAAAtC,EAAAkgB,eACA0B,EAAA3uB,EAAA0rB,EAAArc,GAEAA,EAAAwJ,EAAAnB,YAAArI,EACA,IAAAif,GAAAJ,EAAA7e,EAAAxM,IAAAwM,EAAA+e,YAAA,SAAAY,EAAAV,GACAU,EACA7jB,EAAA6jB,EAAAtD,EAAA4C,IAEAW,EAAAjvB,EAAA0rB,EAAA4C,EAAAjf,GACAlE,EAAA,KAAAugB,EAAA4C,KAGA,OAAAA,GAaA,QAAAY,GAAAlvB,EAAA0rB,EAAArc,EAAAlE,GAoBA,QAAAgkB,GAAAC,GACA,gBAAAJ,EAAAV,KACAe,EACAL,EACAM,EAAArpB,KAAA+oB,GAEAV,EAAAnuB,QAAAmuB,EAAApuB,OACAovB,EAAArpB,KAAA,qCAAAqoB,EAAAzrB,MAEAkoB,EAAA/qB,EAAAqP,GACArP,EAAA2f,YAAAhT,EAAA+e,GAIA,IAAA2D,EAEAjC,EAAAptB,GAAA4X,QAAA,SAAA2X,GAEAvvB,EAAA4uB,WAAAW,EAAA,EAAAC,IAAA9jB,EAAA4iB,KAGAtuB,EAAA4uB,WAAAQ,EAAA,EAAAI,IAAA9jB,EAAA4iB,GAGA9C,EAAAxrB,EAAAqP,GACArP,EAAAktB,eAAAvgB,IAIA,IAAA0iB,GACAlkB,EAAAmkB,EAAA1vB,OAAA0vB,EAAAroB,OAAAwoB,EAAA/D,IAjDAvgB,KAAA8iB,CACA,IAAAyB,GAAArgB,EAAAxM,GACA,QAAA6sB,EAAA9vB,OACA,yCAEA,IAAA4vB,GAAAngB,EAAAmgB,QAAAxvB,EAAA6uB,KACAnjB,EAAA2D,EAAA3D,MAAA1L,EAAA0W,cACA/J,EAAA0C,EAAA1C,QAAA3M,EAAA6pB,UACA,IAAAld,IAAA3M,EAAA8pB,iBACA,sCAEA6E,GAAA3uB,EAAA0rB,EAAArc,GAEAA,EAAAwJ,EAAAnB,YAAArI,EACA,IAEAogB,GAFAJ,EAAA,EACAC,KAEAzB,EAAAT,EAAAptB,EAAAqP,EAqCAogB,GAAAC,EAAAhc,IAAA,SAAAya,EAAAjO,GACA,MAAAgO,GAAAC,EAAA9e,EAAA+e,YAAAe,EAAAtB,EAAA3N,OAUA,QAAAyP,GAAAH,GACA,OAAAA,GACA,IAAAI,GACA,IAAAC,GACA,QACA,KAAAC,GACA,QACA,KAAAC,GACA,QACA,KAAAlB,GACA,QACA,SACA,sBAAAW,GASA,QAAAQ,GAAAhwB,EAAA6C,GACA,MAAA0U,GAAA1U,GACA+V,EAAAvC,uBAAAxT,GAEA7C,EAAA0W,cAGA,QAAAuZ,GAAAjwB,EAAA2M,EAAAxM,EAAAD,EAAAib,GACA,GAAAA,EAAA,MACA,6BAEA,IAAAhb,GAAAD,GASK,GAAAA,GAKA,IAAAC,IACLA,EAAAgb,EAAAjb,EACAC,EAAA,GACA,kCANA,IADAD,EAAAib,EAAAhb,EACAD,EAAA,EACA,kCAZA,CACA,GAAAka,GAAA/Z,KAAA6vB,KAAA/U,GAAAxO,IAAA3M,EAAA8pB,iBAAA,KACA1P,GAAA,OACAja,EAAAia,EACAla,EAAAka,IAEAja,EAAAgb,EACAjb,EAAA,GAaA,OACAC,QACAD,UAcA,QAAAiwB,GAAAnwB,EAAA0rB,EAAA7oB,EAAAwM,GACAA,KAAAtC,EAAAkgB,cACA,IAAAtgB,GAAA0C,EAAA1C,QAAA3M,EAAA6pB,UACA7pB,GAAA2f,YAAAhT,EAAA+e,EACA,IAAAvrB,GAAAkP,EAAAlP,MACAD,EAAAmP,EAAAnP,OACAkwB,EAAA/gB,EAAA+gB,MACAZ,EAAAngB,EAAAmgB,QAAAxvB,EAAA6uB,KACAwB,EAAAhhB,EAAAghB,gBAAAb,EACA9jB,EAAA2D,EAAA3D,MAAAskB,EAAAhwB,EAAA6C,GACAzD,EAAAuwB,EAAAH,GACArU,EAAAtY,EAAAjD,OAAAR,CACA,IAAA+b,EAAA,EACA,sCAAAmV,EAAAtwB,EAAAwvB,EAEA,IAAAe,EACA,IAAA5jB,IAAA3M,EAAA+pB,WACA,GAAA5pB,GAAAD,GAAAkwB,GAQOjwB,GAAAD,GAAAkwB,GAIAlwB,GAAAC,GAAAiwB,GAKPG,EAAAN,EAAAjwB,EAAA2M,EAAAxM,EAAAD,EAAAib,EAAAiV,GACAjwB,EAAAowB,EAAApwB,MACAD,EAAAqwB,EAAArwB,SANAqwB,EAAAN,EAAAjwB,EAAA2M,EAAAxM,EAAAiwB,EAAAjV,EAAAjb,GACAC,EAAAowB,EAAApwB,MACAiwB,EAAAG,EAAArwB,SANAqwB,EAAAN,EAAAjwB,EAAA2M,EAAAzM,EAAAkwB,EAAAjV,EAAAhb,GACAD,EAAAqwB,EAAApwB,MACAiwB,EAAAG,EAAArwB,YAXA,CACA,GAAAka,GAAA/Z,KAAAmwB,KAAArV,EACA,IAAAf,EAAA,MACA,uDAAAe,CAEAhb,GAAAia,EACAla,EAAAka,EACAgW,EAAAhW,MAeAmW,GAAAN,EAAAjwB,EAAA2M,EAAAxM,EAAAD,EAAAib,GACAhb,EAAAowB,EAAApwB,MACAD,EAAAqwB,EAAArwB,MAEA,IAAAqX,EAAA1U,GAIAA,YAAA8T,qBACA9T,EAAA,GAAA4T,YAAA5T,EAAA2U,aALA,CACA,GAAA+C,GAAA3B,EAAAtB,2BAAA5L,EACA7I,GAAA,GAAA0X,GAAA1X,GAQA,GAFA7C,EAAAmrB,YAAAnrB,EAAAywB,iBAAAphB,EAAAqhB,iBAAA,GACA3F,EAAA/qB,EAAAqP,GACA1C,IAAA3M,EAAA8pB,iBAAA,CACA,GAAA6G,GAAAxV,EAAA,EAAA/b,CACAwuB,GAAA5tB,EAAAqP,GAAAuI,QAAA,SAAAtC,GACA,GAAAuF,GAAA8V,EAAArb,EAAA4K,IACA7gB,EAAAwD,EAAA+tB,SAAA/V,IAAA8V,EACA3wB,GAAA4uB,WAAAtZ,EAAAyY,KAAA,EAAAsC,EAAAlwB,EAAAD,EAAA,EAAAsvB,EAAA9jB,EAAArM,SAEKsN,KAAA3M,EAAA+pB,WACL/pB,EAAA8uB,WAAAniB,EAAA,EAAA0jB,EAAAlwB,EAAAD,EAAAkwB,EAAA,EAAAZ,EAAA9jB,EAAA7I,GAEA7C,EAAA4uB,WAAAjiB,EAAA,EAAA0jB,EAAAlwB,EAAAD,EAAA,EAAAsvB,EAAA9jB,EAAA7I,EAGA,OADA2oB,GAAAxrB,EAAAqP,IAEAlP,QACAD,SACAkwB,SAYA,QAAAS,GAAA7wB,EAAA0rB,EAAArc,GACA,GAAA1C,GAAA0C,EAAA1C,QAAA3M,EAAA6pB,UACA7pB,GAAA2f,YAAAhT,EAAA+e,EACA,IAAA8D,GAAAngB,EAAAmgB,QAAAxvB,EAAA6uB,KACAwB,EAAAhhB,EAAAghB,gBAAAb,EACA9jB,EAAA2D,EAAA3D,MAAA1L,EAAA0W,aAEA,IADAqU,EAAA/qB,EAAAqP,GACA1C,IAAA3M,EAAA8pB,iBACA,OAAA9N,GAAA,EAAsBA,EAAA,IAAQA,EAC9Bhc,EAAA4uB,WAAA5uB,EAAAstB,4BAAAtR,EAAA,EAAAqU,EAAAhhB,EAAAlP,MAAAkP,EAAAnP,OAAA,EAAAsvB,EAAA9jB,EAAA,UAEKiB,KAAA3M,EAAA+pB,WACL/pB,EAAA8uB,WAAAniB,EAAA,EAAA0jB,EAAAhhB,EAAAlP,MAAAkP,EAAAnP,OAAAmP,EAAA+gB,MAAA,EAAAZ,EAAA9jB,EAAA,MAEA1L,EAAA4uB,WAAAjiB,EAAA,EAAA0jB,EAAAhhB,EAAAlP,MAAAkP,EAAAnP,OAAA,EAAAsvB,EAAA9jB,EAAA,KAEA8f,GAAAxrB,EAAAqP,GAWA,QAAAzM,GAAA5C,EAAAqP,EAAAlE,GACAA,KAAA8iB,EACA5e,KAAAtC,EAAAkgB,cACA,IAAAvB,GAAA1rB,EAAA4C,gBACA+J,EAAA0C,EAAA1C,QAAA3M,EAAA6pB,WACA1pB,EAAAkP,EAAAlP,OAAA,EACAD,EAAAmP,EAAAnP,QAAA,CACAF,GAAA2f,YAAAhT,EAAA+e,GACA/e,IAAA3M,EAAA8pB,mBAEA9pB,EAAA4rB,cAAAjf,EAAA3M,EAAAgsB,eAAAhsB,EAAA+C,eACA/C,EAAA4rB,cAAAjf,EAAA3M,EAAAisB,eAAAjsB,EAAA+C,eAEA,IAAAF,GAAAwM,EAAAxM,GACA,IAAAA,EAIA,GAHA,kBAAAA,KACAA,IAAA7C,EAAAqP,IAEA,mBACA0f,EAAA/uB,EAAA0rB,EAAArc,EAAAlE,OACO,IAAAoM,EAAA1U,IACPoG,MAAAqR,QAAAzX,KACA,gBAAAA,GAAA,IACAoG,MAAAqR,QAAAzX,EAAA,KACA0U,EAAA1U,EAAA,KAEA,CACA,GAAA0tB,GAAAJ,EAAAnwB,EAAA0rB,EAAA7oB,EAAAwM,EACAlP,GAAAowB,EAAApwB,MACAD,EAAAqwB,EAAArwB,WACO,IAAA+I,MAAAqR,QAAAzX,IAAA,gBAAAA,GAAA,GACPqsB,EAAAlvB,EAAA0rB,EAAArc,EAAAlE,OACO,MAAAtI,YAAAgF,cAKP,2BAJAonB,GAAAjvB,EAAA0rB,EAAA7oB,EAAAwM,GACAlP,EAAA0C,EAAA1C,MACAD,EAAA2C,EAAA3C,WAKA2wB,GAAA7wB,EAAA0rB,EAAArc,EAMA,OAJAA,GAAAyhB,QAAA,GACA9D,EAAAhtB,EAAA0rB,EAAArc,EAAAlP,EAAAD,GAEAurB,EAAAzrB,EAAA0rB,EAAArc,GACAqc,EAmBA,QAAAqF,GAAA/wB,EAAA0rB,EAAArc,EAAAlP,EAAAD,GACAC,KAAAkP,EAAAlP,MACAD,KAAAmP,EAAAnP,MACA,IAAAyM,GAAA0C,EAAA1C,QAAA3M,EAAA6pB,UACA7pB,GAAA2f,YAAAhT,EAAA+e,EACA,IACAhgB,GADA8jB,EAAAngB,EAAAmgB,QAAAxvB,EAAA6uB,KAEAhsB,EAAAwM,EAAAxM,GAQA,IAJA6I,EAHA7I,IAEK0U,EAAA1U,IAAAoG,MAAAqR,QAAAzX,IAAA,gBAAAA,GAAA,IACLwM,EAAA3D,MAAAskB,EAAAhwB,EAAA6C,GAFAwM,EAAA3D,MAAA1L,EAAA0W,cAMA/J,IAAA3M,EAAA8pB,iBACA,OAAA9N,GAAA,EAAsBA,EAAA,IAAQA,EAC9Bhc,EAAA4uB,WAAA5uB,EAAAstB,4BAAAtR,EAAA,EAAAwT,EAAArvB,EAAAD,EAAA,EAAAsvB,EAAA9jB,EAAA,UAGA1L,GAAA4uB,WAAAjiB,EAAA,EAAA6iB,EAAArvB,EAAAD,EAAA,EAAAsvB,EAAA9jB,EAAA,MAWA,QAAAslB,GAAAnuB,GACA,sBAAAA,IACAoG,MAAAqR,QAAAzX,IAAA,gBAAAA,GAAA,GA8EA,QAAAouB,GAAAjxB,EAAAitB,EAAA9hB,GAOA,QAAA+lB,KACA,IAAAC,GACA9lB,WAAA,WACAF,EAAAmkB,EAAA1vB,OAAA0vB,EAAAroB,OAAA6Y,EAAAsR,IACS,GAVTjmB,KAAA8iB,CACA,IAAAkD,GAAA,EACA7B,KACAxP,KACAsR,IAiCA,OAvBA5sB,QAAAiI,KAAAwgB,GAAArV,QAAA,SAAArU,GACA,GACA8tB,GADAhiB,EAAA4d,EAAA1pB,EAEAytB,GAAA3hB,EAAAxM,OACAwuB,EAAA,SAAArC,EAAAtD,EAAA4C,GACA8C,EAAA7tB,GAAA+qB,IACA6C,EACAnC,GACAM,EAAArpB,KAAA+oB,GAEAkC,OAEAC,GAEArR,EAAAvc,GAAAX,EAAA5C,EAAAqP,EAAAgiB,KAOAH,IAEApR,EAtjCA,GACA/S,IACA+d,aAAA,GAAArU,aAAA,kBACAwW,kBACAmB,YAAAnnB,QAEAsQ,EAAAqB,EAAArB,cAGAqY,EAAA,KACAG,EAAA,KACAlB,EAAA,KACAgB,EAAA,KACAC,EAAA,KAiDAQ,EAAA,WAGA,QAAAlkB,GAAApM,GACAsxB,IACAA,KACA9sB,OAAAiI,KAAAzM,GAAA4X,QAAA,SAAA/K,GACA,gBAAA7M,GAAA6M,KACAykB,EAAAtxB,EAAA6M,UAPA,GAAAykB,EAaA,iBAAAtxB,EAAA8E,GAEA,MADAsH,KACAklB,EAAAxsB,IAAA,KAAAA,EAAA2F,SAAA,QAsGAwgB,KAuMAgE,EAAA,WACA,GAAAsC,GAAAhwB,SAAAa,cAAA,UAAAovB,WAAA,KACA,iBAAAxxB,EAAA0rB,EAAA+F,EAAApiB,GACAA,KAAAtC,EAAAkgB,cACA,IAAAtgB,GAAA0C,EAAA1C,QAAA3M,EAAA6pB,WACA1pB,EAAAsxB,EAAAtxB,MACAD,EAAAuxB,EAAAvxB,OACAsvB,EAAAngB,EAAAmgB,QAAAxvB,EAAA6uB,KACAwB,EAAAhhB,EAAAghB,gBAAAb,EACA9jB,EAAA2D,EAAA3D,MAAA1L,EAAA0W,aAGA,IAFAqU,EAAA/qB,EAAAqP,GACArP,EAAA2f,YAAAhT,EAAA+e,GACA/e,IAAA3M,EAAA8pB,iBAAA,CAEA,GAEA1P,GACAsX,EAHAC,EAAAF,EAAAtxB,MACAyxB,EAAAH,EAAAvxB,MAGA,IAAAyxB,EAAA,IAAAC,EAEAxX,EAAAwX,EACAF,GAAA,6BACS,IAAAE,EAAA,IAAAD,EAETvX,EAAAuX,EACAD,GAAA,6BACS,IAAAC,EAAA,IAAAC,EAAA,EAETxX,EAAAuX,EAAA,EACAD,GAAA,6BACS,IAAAC,EAAA,IAAAC,EAAA,EAKT,iDAAAH,EAAA5uB,IAAA4uB,EAAA5uB,IAAA4uB,EAAApuB,SAHA+W,GAAAuX,EAAA,EACAD,GAAA,yBAIAH,EAAAtxB,OAAAE,MAAAia,EACAmX,EAAAtxB,OAAAC,OAAAka,EACAja,EAAAia,EACAla,EAAAka,EACAwT,EAAA5tB,EAAAqP,GAAAuI,QAAA,SAAAtC,GACA,GAAAuc,GAAAH,EAAA,EAAApc,EAAA4K,IAAA,GAAA9F,EACA0X,EAAAJ,EAAA,EAAApc,EAAA4K,IAAA,GAAA9F,CACAmX,GAAAQ,UAAAN,EAAAI,EAAAC,EAAA1X,IAAA,IAAAA,KACApa,EAAA4uB,WAAAtZ,EAAAyY,KAAA,EAAAsC,EAAAb,EAAA9jB,EAAA6lB,EAAAtxB,UAGAsxB,EAAAtxB,OAAAE,MAAA,EACAoxB,EAAAtxB,OAAAC,OAAA,MACO,IAAAyM,IAAA3M,EAAA+pB,WAAA,CACP,GAAAiI,GAAA3xB,KAAAsrB,IAAA8F,EAAAtxB,MAAAsxB,EAAAvxB,QACA+xB,EAAA5xB,KAAA6xB,IAAAT,EAAAtxB,MAAAsxB,EAAAvxB,QACAkwB,EAAA6B,EAAAD,CACA,IAAA5B,EAAA,MACA,+CAEA,IAAA+B,GAAAV,EAAAtxB,QAAA8xB,EAAA,IACAG,EAAAX,EAAAvxB,SAAA+xB,EAAA,GACAjyB,GAAA8uB,WAAAniB,EAAA,EAAA0jB,EAAA2B,MAAA,EAAAxC,EAAA9jB,EAAA,MAEA6lB,EAAAtxB,OAAAE,MAAA6xB,EACAT,EAAAtxB,OAAAC,OAAA8xB,CACA,QAAAK,GAAA,EAAuBA,EAAAjC,IAAWiC,EAAA,CAGlC,GAAAC,GAAAD,EAAAL,EAAAG,EACAI,EAAAF,EAAAL,EAAAI,EACAI,EAAAR,EACAS,EAAAT,EACAU,EAAA,EACAC,EAAA,EACAC,EAAAZ,EACAa,EAAAb,CACAT,GAAAQ,UAAAN,EAAAa,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA7yB,EAAA8yB,cAAAnmB,EAAA,MAAA0lB,EAAA7C,EAAA9jB,EAAA6lB,EAAAtxB,QAEAsxB,EAAAtxB,OAAAE,MAAA,EACAoxB,EAAAtxB,OAAAC,OAAA,MAIAF,GAAA4uB,WAAAjiB,EAAA,EAAA0jB,EAAAb,EAAA9jB,EAAA+lB,EAEAjG,GAAAxrB,EAAAqP,GACAA,EAAAyhB,QAAA,GACA9D,EAAAhtB,EAAA0rB,EAAArc,EAAAlP,EAAAD,GAEAurB,EAAAzrB,EAAA0rB,EAAArc,MAwmBA,QACA4M,aAAAjD,EAEApW,gBACAiuB,kBACAV,sBACApB,qBACAE,wBACAjC,6BACAvB,uBACAb,yBACAqG,iBACAF,gBACApB,+BAqCAld,EAAA,qBACA,aACA,WACA,SACAqN,EACAjH,GA2FA,QAAAka,GAAAvD,GACA,MAAAwD,GAAAxD,GAYA,QAAAyD,GAAAzD,GACA,MAAA0D,GAAA1D,GA8CA,QAAA7sB,GAAA3C,EAAAsB,EAAAnB,EAAAD,GACA,GAAAyM,GAAA3M,EAAAmzB,YACAC,EAAApzB,EAAAqzB,mBACArzB,GAAAszB,gBAAA3mB,EAAAymB,GACAjzB,KAAAH,EAAAuzB,mBACArzB,KAAAF,EAAAwzB,oBACAlyB,KAAAmyB,CACA,IAAAC,GAAA,EACAryB,GACAsyB,YAAAP,EACA9xB,eACAnB,QACAD,SA0CA,OAxCAoB,GAAAsW,QAAA,SAAAgc,GACA,GAAAC,GAAAD,EAAAC,WACArE,EAAAoE,EAAApE,OACAsE,EAAAf,EAAAvD,EAIA,IAHAsE,IACAA,EAAAC,EAAAL,MAEAG,EACA,GAAAZ,EAAAzD,GACAqE,EAAA7zB,EAAAg0B,qBACAh0B,EAAAi0B,iBAAAj0B,EAAAk0B,aAAAL,GACA7zB,EAAAm0B,oBAAAn0B,EAAAk0B,aAAA1E,EAAArvB,EAAAD,OACS,CACT,GAAA+sB,GAAApU,EAAAnB,YAAAkc,EACA3G,GAAA9sB,QACA8sB,EAAA/sB,SACA+G,SAAAgmB,EAAA6D,OACA7D,EAAA6D,MAAA,EACA7D,EAAAtB,IAAAsB,EAAAtB,KAAA3rB,EAAAmtB,OACAF,EAAAnB,IAAAmB,EAAAnB,KAAA9rB,EAAAmtB,OACAF,EAAAb,MAAAa,EAAAb,OAAAa,EAAAnqB,MAAA9C,EAAA+C,cACAkqB,EAAAZ,MAAAY,EAAAZ,OAAAY,EAAAnqB,MAAA9C,EAAA+C,eAEA8wB,EAAA/T,EAAAld,cAAA5C,EAAAitB,GAGA,GAAA4G,YAAAO,mBACAp0B,EAAAq0B,wBAAA1nB,EAAAmnB,EAAA9zB,EAAAk0B,aAAAL,OACO,MAAAA,YAAAS,eAQP,8BAPAt0B,GAAAu0B,qBACA5nB,EACAmnB,EACAF,EAAAY,WAAAx0B,EAAA6pB,WACAgK,EACAD,EAAAa,OAAA,GAIApzB,EAAAC,YAAA2E,KAAA4tB,KAEAxyB,EA8CA,QAAAqzB,GAAA10B,EAAAqB,EAAAC,EAAAnB,EAAAD,GACAC,KAAAH,EAAAuzB,mBACArzB,KAAAF,EAAAwzB,oBACAnyB,EAAAlB,QACAkB,EAAAnB,SACAoB,KAAAmyB,EACAnyB,EAAAsW,QAAA,SAAAgc,EAAA1T,GACA,GAAA2T,GAAAxyB,EAAAC,YAAA4e,GACAsP,EAAAoE,EAAApE,MACA,IAAAqE,YAAAO,mBACAp0B,EAAAi0B,iBAAAj0B,EAAAk0B,aAAAL,GACA7zB,EAAAm0B,oBAAAn0B,EAAAk0B,aAAA1E,EAAArvB,EAAAD,OACO,MAAA2zB,YAAAS,eAGP,8BAFAxU,GAAAiR,cAAA/wB,EAAA6zB,EAAAD,EAAAzzB,EAAAD,MA2BA,QAAAwB,GAAA1B,EAAAqB,EAAAsL,GACAA,KAAA3M,EAAAmzB,YACA9xB,GACArB,EAAAszB,gBAAA3mB,EAAAtL,EAAAsyB,aACA3zB,EAAA20B,SAAA,IAAAtzB,EAAAlB,MAAAkB,EAAAnB,UAEAF,EAAAszB,gBAAA3mB,EAAA,MACA3M,EAAA20B,SAAA,IAAA30B,EAAAuzB,mBAAAvzB,EAAAwzB,sBA3RA,GAEA9c,GAAA,KAGAke,EAAA,KACA/F,EAAA,KAGAgG,EAAA,MACAC,EAAA,MACAC,EAAA,MACAC,EAAA,MACAC,EAAA,KACAC,EAAA,MACAC,EAAA,MACApB,EAAA,MACAqB,EAAA,MACAC,EAAA,MACAC,EAAA,MAIAvyB,EAAA,MAKAoqB,EAAA,KAoCAsG,IACKjE,OAAAX,EAAAnjB,KAAAgL,EAAAiV,IAAAwB,EAAArqB,KAAAC,IACAysB,OAAA2F,IAGLnC,IACAA,GAAAmC,GAAAG,EACAtC,EAAAiC,GAAAI,EACArC,EAAAkC,GAAAG,EACArC,EAAA4B,GAAAQ,EACApC,EAAAgC,GAAAI,CAMA,IAAAlC,KAiNA,OAhNAA,GAAA2B,IAAA,EACA3B,EAAA4B,IAAA,EACA5B,EAAA6B,IAAA,EACA7B,EAAAiC,IAAA,EACAjC,EAAA8B,IAAA,EACA9B,EAAA+B,IAAA,EACA/B,EAAAgC,IAAA,GA2MAxzB,sBACAiB,wBACA+xB,2BAoCAjiB,EAAA,aACA,eACA,SACA,iBACA,aACA,aACA,gBACA,WACA,SACA8iB,EACAC,EACAC,EACAxL,EACAnK,EACAlH,EACAC,GAgHA,QAAAG,GAAAC,GACAJ,EAAAd,uBAAAkB,EAAAlM,GACAwoB,EAAAtZ,aAAAhD,GACA6G,EAAA7D,aAAAhD,GAOA,QAAAyc,GAAA11B,GACA,GAAAA,GAAA+M,EAAA4oB,0BAGA9c,EAAAP,SAAAtY,GAAA,CACA,GAAA41B,GAAA51B,EAAA61B,aAAA,0BACAD,KACA51B,EAAA4b,kBAAA,WACA,MAAAga,GAAAE,wBAEA91B,EAAA+1B,kBAAA,SAAAplB,GACAilB,EAAAI,qBAAArlB,IAEA3Q,EAAAi2B,cAAA,SAAAtlB,GACA,MAAAilB,GAAAM,iBAAAvlB,IAEA3Q,EAAA6b,gBAAA,SAAAlL,GACAilB,EAAAO,mBAAAxlB,IAEA3Q,EAAAo2B,qBAAAR,EAAAS,2BAYA,QAAAC,GAAAr2B,EAAAmhB,GAGA,OAFAtJ,IAAA,8BACAye,EAAA,KACAva,EAAA,EAAoBA,EAAAlE,EAAAlY,SAAmBoc,EAAA,CACvC,IACAua,EAAAt2B,EAAAuxB,WAAA1Z,EAAAkE,GAAAoF,GACO,MAAA5S,IACP,GAAA+nB,EACA,MAGA,MAAAA,GASA,QAAA/zB,GAAAvC,EAAAmhB,GACA,GAAAphB,GAAAs2B,EAAAr2B,EAAAmhB,EAEA,OADAsU,GAAA11B,GACAA,EAiBA,QAAAw2B,GAAAv2B,EAAAmhB,GAGA,OAFAtJ,IAAA,6DACAye,EAAA,KACAva,EAAA,EAAoBA,EAAAlE,EAAAlY,SAAmBoc,EAAA,CACvC,IACAua,EAAAt2B,EAAAuxB,WAAA1Z,EAAAkE,GAAAoF,GACO,MAAA5S,IACP,GAAA+nB,EACA,MAGA,MAAAA,GAiBA,QAAA/E,GAAAvxB,EAAAmhB,GACA,GAAAphB,GAAAw2B,EAAAv2B,EAAAmhB,EAEA,OADAsU,GAAA11B,GACAA,EAUA,QAAAyB,GAAAxB,EAAAw2B,GACAA,KAAA,EACAA,EAAAp2B,KAAA6xB,IAAA,EAAAuE,EACA,IAAAt2B,GAAAF,EAAAy2B,YAAAD,EAAA,EACAv2B,EAAAD,EAAA02B,aAAAF,EAAA,CACA,QAAAx2B,EAAAE,WACAF,EAAAC,cACAD,EAAAE,QACAF,EAAAC,UACA,GAgBA,QAAA02B,GAAArzB,GACA,YAAAA,IAAA3D,OAAA,GAGA,QAAAi3B,GAAAh0B,EAAA8U,GAIA,MAHAnT,QAAAiI,KAAA5J,GAAAi0B,OAAAF,GAAAhf,QAAA,SAAA/K,GACA8K,EAAA9K,GAAAhK,EAAAgK,KAEA8K,EA3OA,GACA5K,IACA4oB,0BAAA,GAwNAoB,GACAvF,aACAhvB,kBACA8V,SAAAO,EAAAP,SACAD,SAAAQ,EAAAR,SACA5W,4BACAuX,eAcAge,GACAzB,aACAC,OACAC,eACAxL,WACAnK,WACAlH,cAQA,OANApU,QAAAiI,KAAAuqB,GAAApf,QAAA,SAAArU,GACA,GAAA0zB,GAAAD,EAAAzzB,EACAszB,GAAAI,EAAAF,GACAA,EAAAxzB,GAAAszB,EAAAI,QAGAF,IAKAtkB,EAAA,QACA,aACA,SACAH,GAEA,MAAAA,KAGAE,GAAA,iBAAAqC,GACA,MAAAA,IACC5N,QAAA,GAMDwL,EAAA,uCAEAD,EAAA,WT0qCM,SAAS5U,EAAQD","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\tmodule.exports = __webpack_require__(9);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _classCallCheck2 = __webpack_require__(2);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\t__webpack_require__(3);\n\t\n\tvar _noise = __webpack_require__(4);\n\t\n\tvar _noise2 = _interopRequireDefault(_noise);\n\t\n\tvar _main = __webpack_require__(5);\n\t\n\tvar _main2 = _interopRequireDefault(_main);\n\t\n\tvar _main3 = __webpack_require__(6);\n\t\n\tvar _main4 = _interopRequireDefault(_main3);\n\t\n\tvar _midday = __webpack_require__(7);\n\t\n\tvar _midday2 = _interopRequireDefault(_midday);\n\t\n\tvar _twglBase = __webpack_require__(8);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar arrays = {\n\t  position: { numComponents: 2, data: [1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1] }\n\t};\n\t\n\tvar AnimatedBackground = function AnimatedBackground() {\n\t  var _this = this;\n\t\n\t  (0, _classCallCheck3.default)(this, AnimatedBackground);\n\t\n\t  this.updateMouse = function (event) {\n\t    if (event.touches && event.touches.length > 1) {\n\t      return;\n\t    }\n\t    var touches = event.touches;\n\t    if (!touches) {\n\t      touches = [{ clientX: event.clientX, clientY: event.clientY }];\n\t    }\n\t    var pos = [touches[0].clientY / _this.gl.canvas.height, touches[0].clientX / _this.gl.canvas.width];\n\t    var delta = _this.delta + Math.round(_this.subsideScale * (Math.abs(_this.pos[0] - pos[0]) + Math.abs(_this.pos[1] - pos[1])));\n\t    if (delta > _this.subsideScale) delta = _this.delta;\n\t    _this.delta = delta;\n\t    _this.pos = pos;\n\t  };\n\t\n\t  this.render = function (time) {\n\t    if (_this.delta > 0) _this.delta -= 1;\n\t    var noiseUniforms = {\n\t      time: time,\n\t      Period: 0.0001,\n\t      resolution: [_this.gl.canvas.width, _this.gl.canvas.height]\n\t    };\n\t    var uniforms = {\n\t      Frequency: 1,\n\t      Amplitude: 1,\n\t      Intensity: _this.delta / _this.subsideScale,\n\t      u_texSampler: _this.texture,\n\t      u_noiseSampler: _this.framebufferInfo.attachments[0],\n\t      resolution: [_this.gl.canvas.width, _this.gl.canvas.height]\n\t    };\n\t    if (document.hasFocus()) {\n\t      (0, _twglBase.resizeCanvasToDisplaySize)(_this.gl.canvas);\n\t      (0, _twglBase.bindFramebufferInfo)(_this.gl, _this.framebufferInfo);\n\t\n\t      _this.gl.useProgram(_this.noiseProgramInfo.program);\n\t      (0, _twglBase.setBuffersAndAttributes)(_this.gl, _this.noiseProgramInfo, _this.bufferInfo);\n\t      (0, _twglBase.setUniforms)(_this.noiseProgramInfo, noiseUniforms);\n\t      (0, _twglBase.drawBufferInfo)(_this.gl, _this.bufferInfo);\n\t\n\t      (0, _twglBase.bindFramebufferInfo)(_this.gl, null);\n\t      _this.gl.useProgram(_this.programInfo.program);\n\t      (0, _twglBase.setBuffersAndAttributes)(_this.gl, _this.programInfo, _this.bufferInfo);\n\t      (0, _twglBase.setUniforms)(_this.programInfo, uniforms);\n\t      (0, _twglBase.drawBufferInfo)(_this.gl, _this.bufferInfo);\n\t    }\n\t    requestAnimationFrame(_this.render);\n\t  };\n\t\n\t  var canvas = document.createElement('canvas');\n\t  document.body.appendChild(canvas);\n\t  this.pos = [0, 0];\n\t  this.delta = 0;\n\t  this.subsideScale = 500;\n\t  canvas.addEventListener('mousemove', this.updateMouse);\n\t  canvas.addEventListener('touchmove', this.updateMouse);\n\t  this.gl = (0, _twglBase.getWebGLContext)(canvas);\n\t  this.programInfo = (0, _twglBase.createProgramInfo)(this.gl, [_main4.default, _main2.default]);\n\t  this.noiseProgramInfo = (0, _twglBase.createProgramInfo)(this.gl, [_main4.default, _noise2.default]);\n\t  this.bufferInfo = (0, _twglBase.createBufferInfoFromArrays)(this.gl, arrays);\n\t  this.framebufferInfo = (0, _twglBase.createFramebufferInfo)(this.gl);\n\t  this.texture = (0, _twglBase.createTexture)(this.gl, { src: _midday2.default, wrap: this.gl.CLAMP_TO_EDGE }, function () {\n\t    _this.render();\n\t  });\n\t};\n\t\n\tnew AnimatedBackground();\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\texports.default = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/*!\n\tCopyright (C) 2013-2015 by Andrea Giammarchi - @WebReflection\n\t\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\t\n\tThe above copyright notice and this permission notice shall be included in\n\tall copies or substantial portions of the Software.\n\t\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\tTHE SOFTWARE.\n\t\n\t*/\n\t(function(window){'use strict';\n\t  /* jshint loopfunc: true, noempty: false*/\n\t  // http://www.w3.org/TR/dom/#element\n\t\n\t  function createDocumentFragment() {\n\t    return document.createDocumentFragment();\n\t  }\n\t\n\t  function createElement(nodeName) {\n\t    return document.createElement(nodeName);\n\t  }\n\t\n\t  function enoughArguments(length, name) {\n\t    if (!length) throw new Error(\n\t      'Failed to construct ' +\n\t        name +\n\t      ': 1 argument required, but only 0 present.'\n\t    );\n\t  }\n\t\n\t  function mutationMacro(nodes) {\n\t    if (nodes.length === 1) {\n\t      return textNodeIfString(nodes[0]);\n\t    }\n\t    for (var\n\t      fragment = createDocumentFragment(),\n\t      list = slice.call(nodes),\n\t      i = 0; i < nodes.length; i++\n\t    ) {\n\t      fragment.appendChild(textNodeIfString(list[i]));\n\t    }\n\t    return fragment;\n\t  }\n\t\n\t  function textNodeIfString(node) {\n\t    return typeof node === 'string' ? document.createTextNode(node) : node;\n\t  }\n\t\n\t  for(var\n\t    head,\n\t    property,\n\t    TemporaryPrototype,\n\t    TemporaryTokenList,\n\t    wrapVerifyToken,\n\t    document = window.document,\n\t    hOP = Object.prototype.hasOwnProperty,\n\t    defineProperty = Object.defineProperty || function (object, property, descriptor) {\n\t      if (hOP.call(descriptor, 'value')) {\n\t        object[property] = descriptor.value;\n\t      } else {\n\t        if (hOP.call(descriptor, 'get'))\n\t          object.__defineGetter__(property, descriptor.get);\n\t        if (hOP.call(descriptor, 'set'))\n\t          object.__defineSetter__(property, descriptor.set);\n\t      }\n\t      return object;\n\t    },\n\t    indexOf = [].indexOf || function indexOf(value){\n\t      var length = this.length;\n\t      while(length--) {\n\t        if (this[length] === value) {\n\t          break;\n\t        }\n\t      }\n\t      return length;\n\t    },\n\t    // http://www.w3.org/TR/domcore/#domtokenlist\n\t    verifyToken = function (token) {\n\t      if (!token) {\n\t        throw 'SyntaxError';\n\t      } else if (spaces.test(token)) {\n\t        throw 'InvalidCharacterError';\n\t      }\n\t      return token;\n\t    },\n\t    DOMTokenList = function (node) {\n\t      var\n\t        noClassName = typeof node.className === 'undefined',\n\t        className = noClassName ?\n\t          (node.getAttribute('class') || '') : node.className,\n\t        isSVG = noClassName || typeof className === 'object',\n\t        value = (isSVG ?\n\t          (noClassName ? className : className.baseVal) :\n\t          className\n\t        ).replace(trim, '')\n\t      ;\n\t      if (value.length) {\n\t        properties.push.apply(\n\t          this,\n\t          value.split(spaces)\n\t        );\n\t      }\n\t      this._isSVG = isSVG;\n\t      this._ = node;\n\t    },\n\t    classListDescriptor = {\n\t      get: function get() {\n\t        return new DOMTokenList(this);\n\t      },\n\t      set: function(){}\n\t    },\n\t    uid = 'dom4-tmp-'.concat(Math.random() * +new Date()).replace('.','-'),\n\t    trim = /^\\s+|\\s+$/g,\n\t    spaces = /\\s+/,\n\t    SPACE = '\\x20',\n\t    CLASS_LIST = 'classList',\n\t    toggle = function toggle(token, force) {\n\t      if (this.contains(token)) {\n\t        if (!force) {\n\t          // force is not true (either false or omitted)\n\t          this.remove(token);\n\t        }\n\t      } else if(force === undefined || force) {\n\t        force = true;\n\t        this.add(token);\n\t      }\n\t      return !!force;\n\t    },\n\t    DocumentFragmentPrototype = window.DocumentFragment && DocumentFragment.prototype,\n\t    Node = window.Node,\n\t    NodePrototype = (Node || Element).prototype,\n\t    CharacterData = window.CharacterData || Node,\n\t    CharacterDataPrototype = CharacterData && CharacterData.prototype,\n\t    DocumentType = window.DocumentType,\n\t    DocumentTypePrototype = DocumentType && DocumentType.prototype,\n\t    ElementPrototype = (window.Element || Node || window.HTMLElement).prototype,\n\t    HTMLSelectElement = window.HTMLSelectElement || createElement('select').constructor,\n\t    selectRemove = HTMLSelectElement.prototype.remove,\n\t    ShadowRoot = window.ShadowRoot,\n\t    SVGElement = window.SVGElement,\n\t    // normalizes multiple ids as CSS query\n\t    idSpaceFinder = / /g,\n\t    idSpaceReplacer = '\\\\ ',\n\t    createQueryMethod = function (methodName) {\n\t      var createArray = methodName === 'querySelectorAll';\n\t      return function (css) {\n\t        var a, i, id, query, nl, selectors, node = this.parentNode;\n\t        if (node) {\n\t          for (\n\t            id = this.getAttribute('id') || uid,\n\t            query = id === uid ? id : id.replace(idSpaceFinder, idSpaceReplacer),\n\t            selectors = css.split(','),\n\t            i = 0; i < selectors.length; i++\n\t          ) {\n\t            selectors[i] = '#' + query + ' ' + selectors[i];\n\t          }\n\t          css = selectors.join(',');\n\t        }\n\t        if (id === uid) this.setAttribute('id', id);\n\t        nl = (node || this)[methodName](css);\n\t        if (id === uid) this.removeAttribute('id');\n\t        // return a list\n\t        if (createArray) {\n\t          i = nl.length;\n\t          a = new Array(i);\n\t          while (i--) a[i] = nl[i];\n\t        }\n\t        // return node or null\n\t        else {\n\t          a = nl;\n\t        }\n\t        return a;\n\t      };\n\t    },\n\t    addQueryAndAll = function (where) {\n\t      if (!('query' in where)) {\n\t        where.query = ElementPrototype.query;\n\t      }\n\t      if (!('queryAll' in where)) {\n\t        where.queryAll = ElementPrototype.queryAll;\n\t      }\n\t    },\n\t    properties = [\n\t      'matches', (\n\t        ElementPrototype.matchesSelector ||\n\t        ElementPrototype.webkitMatchesSelector ||\n\t        ElementPrototype.khtmlMatchesSelector ||\n\t        ElementPrototype.mozMatchesSelector ||\n\t        ElementPrototype.msMatchesSelector ||\n\t        ElementPrototype.oMatchesSelector ||\n\t        function matches(selector) {\n\t          var parentNode = this.parentNode;\n\t          return !!parentNode && -1 < indexOf.call(\n\t            parentNode.querySelectorAll(selector),\n\t            this\n\t          );\n\t        }\n\t      ),\n\t      'closest', function closest(selector) {\n\t        var parentNode = this, matches;\n\t        while (\n\t          // document has no .matches\n\t          (matches = parentNode && parentNode.matches) &&\n\t          !parentNode.matches(selector)\n\t        ) {\n\t          parentNode = parentNode.parentNode;\n\t        }\n\t        return matches ? parentNode : null;\n\t      },\n\t      'prepend', function prepend() {\n\t        var firstChild = this.firstChild,\n\t            node = mutationMacro(arguments);\n\t        if (firstChild) {\n\t          this.insertBefore(node, firstChild);\n\t        } else {\n\t          this.appendChild(node);\n\t        }\n\t      },\n\t      'append', function append() {\n\t        this.appendChild(mutationMacro(arguments));\n\t      },\n\t      'before', function before() {\n\t        var parentNode = this.parentNode;\n\t        if (parentNode) {\n\t          parentNode.insertBefore(\n\t            mutationMacro(arguments), this\n\t          );\n\t        }\n\t      },\n\t      'after', function after() {\n\t        var parentNode = this.parentNode,\n\t            nextSibling = this.nextSibling,\n\t            node = mutationMacro(arguments);\n\t        if (parentNode) {\n\t          if (nextSibling) {\n\t            parentNode.insertBefore(node, nextSibling);\n\t          } else {\n\t            parentNode.appendChild(node);\n\t          }\n\t        }\n\t      },\n\t      // WARNING - DEPRECATED - use .replaceWith() instead\n\t      'replace', function replace() {\n\t        this.replaceWith.apply(this, arguments);\n\t      },\n\t      'replaceWith', function replaceWith() {\n\t        var parentNode = this.parentNode;\n\t        if (parentNode) {\n\t          parentNode.replaceChild(\n\t            mutationMacro(arguments),\n\t            this\n\t          );\n\t        }\n\t      },\n\t      'remove', function remove() {\n\t        var parentNode = this.parentNode;\n\t        if (parentNode) {\n\t          parentNode.removeChild(this);\n\t        }\n\t      },\n\t      'query', createQueryMethod('querySelector'),\n\t      'queryAll', createQueryMethod('querySelectorAll')\n\t    ],\n\t    slice = properties.slice,\n\t    i = properties.length; i; i -= 2\n\t  ) {\n\t    property = properties[i - 2];\n\t    if (!(property in ElementPrototype)) {\n\t      ElementPrototype[property] = properties[i - 1];\n\t    }\n\t    if (property === 'remove') {\n\t      // see https://github.com/WebReflection/dom4/issues/19\n\t      HTMLSelectElement.prototype[property] = function () {\n\t        return 0 < arguments.length ?\n\t          selectRemove.apply(this, arguments) :\n\t          ElementPrototype.remove.call(this);\n\t      };\n\t    }\n\t    // see https://github.com/WebReflection/dom4/issues/18\n\t    if (/^(?:before|after|replace|replaceWith|remove)$/.test(property)) {\n\t      if (CharacterData && !(property in CharacterDataPrototype)) {\n\t        CharacterDataPrototype[property] = properties[i - 1];\n\t      }\n\t      if (DocumentType && !(property in DocumentTypePrototype)) {\n\t        DocumentTypePrototype[property] = properties[i - 1];\n\t      }\n\t    }\n\t    // see https://github.com/WebReflection/dom4/pull/26\n\t    if (/^(?:append|prepend)$/.test(property)) {\n\t      if (DocumentFragmentPrototype) {\n\t        if (!(property in DocumentFragmentPrototype)) {\n\t          DocumentFragmentPrototype[property] = properties[i - 1];\n\t        }\n\t      } else {\n\t        try {\n\t          createDocumentFragment().constructor.prototype[property] = properties[i - 1];\n\t        } catch(o_O) {}\n\t      }\n\t    }\n\t  }\n\t\n\t  // bring query and queryAll to the document too\n\t  addQueryAndAll(document);\n\t\n\t  // brings query and queryAll to fragments as well\n\t  if (DocumentFragmentPrototype) {\n\t    addQueryAndAll(DocumentFragmentPrototype);\n\t  } else {\n\t    try {\n\t      addQueryAndAll(createDocumentFragment().constructor.prototype);\n\t    } catch(o_O) {}\n\t  }\n\t\n\t  // bring query and queryAll to the ShadowRoot too\n\t  if (ShadowRoot) {\n\t    addQueryAndAll(ShadowRoot.prototype);\n\t  }\n\t\n\t  // most likely an IE9 only issue\n\t  // see https://github.com/WebReflection/dom4/issues/6\n\t  if (!createElement('a').matches('a')) {\n\t    ElementPrototype[property] = function(matches){\n\t      return function (selector) {\n\t        return matches.call(\n\t          this.parentNode ?\n\t            this :\n\t            createDocumentFragment().appendChild(this),\n\t          selector\n\t        );\n\t      };\n\t    }(ElementPrototype[property]);\n\t  }\n\t\n\t  // used to fix both old webkit and SVG\n\t  DOMTokenList.prototype = {\n\t    length: 0,\n\t    add: function add() {\n\t      for(var j = 0, token; j < arguments.length; j++) {\n\t        token = arguments[j];\n\t        if(!this.contains(token)) {\n\t          properties.push.call(this, property);\n\t        }\n\t      }\n\t      if (this._isSVG) {\n\t        this._.setAttribute('class', '' + this);\n\t      } else {\n\t        this._.className = '' + this;\n\t      }\n\t    },\n\t    contains: (function(indexOf){\n\t      return function contains(token) {\n\t        i = indexOf.call(this, property = verifyToken(token));\n\t        return -1 < i;\n\t      };\n\t    }([].indexOf || function (token) {\n\t      i = this.length;\n\t      while(i-- && this[i] !== token){}\n\t      return i;\n\t    })),\n\t    item: function item(i) {\n\t      return this[i] || null;\n\t    },\n\t    remove: function remove() {\n\t      for(var j = 0, token; j < arguments.length; j++) {\n\t        token = arguments[j];\n\t        if(this.contains(token)) {\n\t          properties.splice.call(this, i, 1);\n\t        }\n\t      }\n\t      if (this._isSVG) {\n\t        this._.setAttribute('class', '' + this);\n\t      } else {\n\t        this._.className = '' + this;\n\t      }\n\t    },\n\t    toggle: toggle,\n\t    toString: function toString() {\n\t      return properties.join.call(this, SPACE);\n\t    }\n\t  };\n\t\n\t  if (SVGElement && !(CLASS_LIST in SVGElement.prototype)) {\n\t    defineProperty(SVGElement.prototype, CLASS_LIST, classListDescriptor);\n\t  }\n\t\n\t  // http://www.w3.org/TR/dom/#domtokenlist\n\t  // iOS 5.1 has completely screwed this property\n\t  // classList in ElementPrototype is false\n\t  // but it's actually there as getter\n\t  if (!(CLASS_LIST in document.documentElement)) {\n\t    defineProperty(ElementPrototype, CLASS_LIST, classListDescriptor);\n\t  } else {\n\t    // iOS 5.1 and Nokia ASHA do not support multiple add or remove\n\t    // trying to detect and fix that in here\n\t    TemporaryTokenList = createElement('div')[CLASS_LIST];\n\t    TemporaryTokenList.add('a', 'b', 'a');\n\t    if ('a\\x20b' != TemporaryTokenList) {\n\t      // no other way to reach original methods in iOS 5.1\n\t      TemporaryPrototype = TemporaryTokenList.constructor.prototype;\n\t      if (!('add' in TemporaryPrototype)) {\n\t        // ASHA double fails in here\n\t        TemporaryPrototype = window.TemporaryTokenList.prototype;\n\t      }\n\t      wrapVerifyToken = function (original) {\n\t        return function () {\n\t          var i = 0;\n\t          while (i < arguments.length) {\n\t            original.call(this, arguments[i++]);\n\t          }\n\t        };\n\t      };\n\t      TemporaryPrototype.add = wrapVerifyToken(TemporaryPrototype.add);\n\t      TemporaryPrototype.remove = wrapVerifyToken(TemporaryPrototype.remove);\n\t      // toggle is broken too ^_^ ... let's fix it\n\t      TemporaryPrototype.toggle = toggle;\n\t    }\n\t  }\n\t\n\t  if (!('contains' in NodePrototype)) {\n\t    defineProperty(NodePrototype, 'contains', {\n\t      value: function (el) {\n\t        while (el && el !== this) el = el.parentNode;\n\t        return this === el;\n\t      }\n\t    });\n\t  }\n\t\n\t  if (!('head' in document)) {\n\t    defineProperty(document, 'head', {\n\t      get: function () {\n\t        return head || (\n\t          head = document.getElementsByTagName('head')[0]\n\t        );\n\t      }\n\t    });\n\t  }\n\t\n\t  // requestAnimationFrame partial polyfill\n\t  (function () {\n\t    for (var\n\t      raf,\n\t      rAF = window.requestAnimationFrame,\n\t      cAF = window.cancelAnimationFrame,\n\t      prefixes = ['o', 'ms', 'moz', 'webkit'],\n\t      i = prefixes.length;\n\t      !cAF && i--;\n\t    ) {\n\t      rAF = rAF || window[prefixes[i] + 'RequestAnimationFrame'];\n\t      cAF = window[prefixes[i] + 'CancelAnimationFrame'] ||\n\t            window[prefixes[i] + 'CancelRequestAnimationFrame'];\n\t    }\n\t    if (!cAF) {\n\t      // some FF apparently implemented rAF but no cAF \n\t      if (rAF) {\n\t        raf = rAF;\n\t        rAF = function (callback) {\n\t          var goOn = true;\n\t          raf(function () {\n\t            if (goOn) callback.apply(this, arguments);\n\t          });\n\t          return function () {\n\t            goOn = false;\n\t          };\n\t        };\n\t        cAF = function (id) {\n\t          id();\n\t        };\n\t      } else {\n\t        rAF = function (callback) {\n\t          return setTimeout(callback, 15, 15);\n\t        };\n\t        cAF = function (id) {\n\t          clearTimeout(id);\n\t        };\n\t      }\n\t    }\n\t    window.requestAnimationFrame = rAF;\n\t    window.cancelAnimationFrame = cAF;\n\t  }());\n\t\n\t  // http://www.w3.org/TR/dom/#customevent\n\t  try{new window.CustomEvent('?');}catch(o_O){\n\t    window.CustomEvent = function(\n\t      eventName,\n\t      defaultInitDict\n\t    ){\n\t\n\t      // the infamous substitute\n\t      function CustomEvent(type, eventInitDict) {\n\t        /*jshint eqnull:true */\n\t        var event = document.createEvent(eventName);\n\t        if (typeof type != 'string') {\n\t          throw new Error('An event name must be provided');\n\t        }\n\t        if (eventName == 'Event') {\n\t          event.initCustomEvent = initCustomEvent;\n\t        }\n\t        if (eventInitDict == null) {\n\t          eventInitDict = defaultInitDict;\n\t        }\n\t        event.initCustomEvent(\n\t          type,\n\t          eventInitDict.bubbles,\n\t          eventInitDict.cancelable,\n\t          eventInitDict.detail\n\t        );\n\t        return event;\n\t      }\n\t\n\t      // attached at runtime\n\t      function initCustomEvent(\n\t        type, bubbles, cancelable, detail\n\t      ) {\n\t        /*jshint validthis:true*/\n\t        this.initEvent(type, bubbles, cancelable);\n\t        this.detail = detail;\n\t      }\n\t\n\t      // that's it\n\t      return CustomEvent;\n\t    }(\n\t      // is this IE9 or IE10 ?\n\t      // where CustomEvent is there\n\t      // but not usable as construtor ?\n\t      window.CustomEvent ?\n\t        // use the CustomEvent interface in such case\n\t        'CustomEvent' : 'Event',\n\t        // otherwise the common compatible one\n\t      {\n\t        bubbles: false,\n\t        cancelable: false,\n\t        detail: null\n\t      }\n\t    );\n\t  }\n\t\n\t  // window.Event as constructor\n\t  try { new Event('_'); } catch (o_O) {\n\t    /* jshint -W022 */\n\t    o_O = (function ($Event) {\n\t      function Event(type, init) {\n\t        enoughArguments(arguments.length, 'Event');\n\t        var out = document.createEvent('Event');\n\t        if (!init) init = {};\n\t        out.initEvent(\n\t          type,\n\t          !!init.bubbles,\n\t          !!init.cancelable\n\t        );\n\t        return out;\n\t      }\n\t      Event.prototype = $Event.prototype;\n\t      return Event;\n\t    }(window.Event || function Event() {}));\n\t    defineProperty(window, 'Event', {value: o_O});\n\t    // Android 4 gotcha\n\t    if (Event !== o_O) Event = o_O;\n\t  }\n\t\n\t  // window.KeyboardEvent as constructor\n\t  try { new KeyboardEvent('_', {}); } catch (o_O) {\n\t    /* jshint -W022 */\n\t    o_O = (function ($KeyboardEvent) {\n\t      // code inspired by https://gist.github.com/termi/4654819\n\t      var\n\t        initType = 0,\n\t        defaults = {\n\t          char: '',\n\t          key: '',\n\t          location: 0,\n\t          ctrlKey: false,\n\t          shiftKey: false,\n\t          altKey: false,\n\t          metaKey: false,\n\t          altGraphKey: false,\n\t          repeat: false,\n\t          locale: navigator.language,\n\t          detail: 0,\n\t          bubbles: false,\n\t          cancelable: false,\n\t          keyCode: 0,\n\t          charCode: 0,\n\t          which: 0\n\t        },\n\t        eventType\n\t      ;\n\t      try {\n\t        var e = document.createEvent('KeyboardEvent');\n\t        e.initKeyboardEvent(\n\t          'keyup', false, false, window, '+', 3,\n\t          true, false, true, false, false\n\t        );\n\t        initType = (\n\t          (e.keyIdentifier || e.key) == '+' &&\n\t          (e.keyLocation || e.location) == 3\n\t        ) && (\n\t          e.ctrlKey ? e.altKey ? 1 : 3 : e.shiftKey ? 2 : 4\n\t        ) || 9;\n\t      } catch(o_O) {}\n\t      eventType = 0 < initType ? 'KeyboardEvent' : 'Event';\n\t\n\t      function getModifier(init) {\n\t        for (var\n\t          out = [],\n\t          keys = [\n\t            'ctrlKey',\n\t            'Control',\n\t            'shiftKey',\n\t            'Shift',\n\t            'altKey',\n\t            'Alt',\n\t            'metaKey',\n\t            'Meta',\n\t            'altGraphKey',\n\t            'AltGraph'\n\t          ],\n\t          i = 0; i < keys.length; i += 2\n\t        ) {\n\t          if (init[keys[i]])\n\t            out.push(keys[i + 1]);\n\t        }\n\t        return out.join(' ');\n\t      }\n\t\n\t      function withDefaults(target, source) {\n\t        for (var key in source) {\n\t          if (\n\t            source.hasOwnProperty(key) &&\n\t            !source.hasOwnProperty.call(target, key)\n\t          ) target[key] = source[key];\n\t        }\n\t        return target;\n\t      }\n\t\n\t      function withInitValues(key, out, init) {\n\t        try {\n\t          out[key] = init[key];\n\t        } catch(o_O) {}\n\t      }\n\t\n\t      function KeyboardEvent(type, init) {\n\t        enoughArguments(arguments.length, 'KeyboardEvent');\n\t        init = withDefaults(init || {}, defaults);\n\t        var\n\t          out = document.createEvent(eventType),\n\t          ctrlKey = init.ctrlKey,\n\t          shiftKey = init.shiftKey,\n\t          altKey = init.altKey,\n\t          metaKey = init.metaKey,\n\t          altGraphKey = init.altGraphKey,\n\t          modifiers = initType > 3 ? getModifier(init) : null,\n\t          key = String(init.key),\n\t          chr = String(init.char),\n\t          location = init.location,\n\t          keyCode = init.keyCode || (\n\t            (init.keyCode = key) &&\n\t            key.charCodeAt(0)\n\t          ) || 0,\n\t          charCode = init.charCode || (\n\t            (init.charCode = chr) &&\n\t            chr.charCodeAt(0)\n\t          ) || 0,\n\t          bubbles = init.bubbles,\n\t          cancelable = init.cancelable,\n\t          repeat = init.repeat,\n\t          locale = init.locale,\n\t          view = init.view || window,\n\t          args\n\t        ;\n\t        if (!init.which) init.which = init.keyCode;\n\t        if ('initKeyEvent' in out) {\n\t          out.initKeyEvent(\n\t            type, bubbles, cancelable, view,\n\t            ctrlKey, altKey, shiftKey, metaKey, keyCode, charCode\n\t          );\n\t        } else if (0 < initType && 'initKeyboardEvent' in out) {\n\t          args = [type, bubbles, cancelable, view];\n\t          switch (initType) {\n\t            case 1:\n\t              args.push(key, location, ctrlKey, shiftKey, altKey, metaKey, altGraphKey);\n\t              break;\n\t            case 2:\n\t              args.push(ctrlKey, altKey, shiftKey, metaKey, keyCode, charCode);\n\t              break;\n\t            case 3:\n\t              args.push(key, location, ctrlKey, altKey, shiftKey, metaKey, altGraphKey);\n\t              break;\n\t            case 4:\n\t              args.push(key, location, modifiers, repeat, locale);\n\t              break;\n\t            default:\n\t              args.push(char, key, location, modifiers, repeat, locale);\n\t          }\n\t          out.initKeyboardEvent.apply(out, args);\n\t        } else {\n\t          out.initEvent(type, bubbles, cancelable);\n\t        }\n\t        for (key in out) {\n\t          if (defaults.hasOwnProperty(key) && out[key] !== init[key]) {\n\t            withInitValues(key, out, init);\n\t          }\n\t        }\n\t        return out;\n\t      }\n\t      KeyboardEvent.prototype = $KeyboardEvent.prototype;\n\t      return KeyboardEvent;\n\t    }(window.KeyboardEvent || function KeyboardEvent() {}));\n\t    defineProperty(window, 'KeyboardEvent', {value: o_O});\n\t    // Android 4 gotcha\n\t    if (KeyboardEvent !== o_O) KeyboardEvent = o_O;\n\t  }\n\t\n\t  // window.MouseEvent as constructor\n\t  try { new MouseEvent('_', {}); } catch (o_O) {\n\t    /* jshint -W022 */\n\t    o_O = (function ($MouseEvent) {\n\t      function MouseEvent(type, init) {\n\t        enoughArguments(arguments.length, 'MouseEvent');\n\t        var out = document.createEvent('MouseEvent');\n\t        if (!init) init = {};\n\t        out.initMouseEvent(\n\t          type,\n\t          !!init.bubbles,\n\t          !!init.cancelable,\n\t          init.view || window,\n\t          init.detail || 1,\n\t          init.screenX || 0,\n\t          init.screenY || 0,\n\t          init.clientX || 0,\n\t          init.clientY || 0,\n\t          !!init.ctrlKey,\n\t          !!init.altKey,\n\t          !!init.shiftKey,\n\t          !!init.metaKey,\n\t          init.button || 0,\n\t          init.relatedTarget || null\n\t        );\n\t        return out;\n\t      }\n\t      MouseEvent.prototype = $MouseEvent.prototype;\n\t      return MouseEvent;\n\t    }(window.MouseEvent || function MouseEvent() {}));\n\t    defineProperty(window, 'MouseEvent', {value: o_O});\n\t    // Android 4 gotcha\n\t    if (MouseEvent !== o_O) MouseEvent = o_O;\n\t  }\n\t\n\t}(window));(function (global){'use strict';\n\t\n\t  // a WeakMap fallback for DOM nodes only used as key\n\t  var DOMMap = global.WeakMap || (function () {\n\t\n\t    var\n\t      counter = 0,\n\t      dispatched = false,\n\t      drop = false,\n\t      value\n\t    ;\n\t\n\t    function dispatch(key, ce, shouldDrop) {\n\t      drop = shouldDrop;\n\t      dispatched = false;\n\t      value = undefined;\n\t      key.dispatchEvent(ce);\n\t    }\n\t\n\t    function Handler(value) {\n\t      this.value = value;\n\t    }\n\t\n\t    Handler.prototype.handleEvent = function handleEvent(e) {\n\t      dispatched = true;\n\t      if (drop) {\n\t        e.currentTarget.removeEventListener(e.type, this, false);\n\t      } else {\n\t        value = this.value;\n\t      }\n\t    };\n\t\n\t    function DOMMap() {\n\t      counter++;  // make id clashing highly improbable\n\t      this.__ce__ = new Event(('@DOMMap:' + counter) + Math.random());\n\t    }\n\t\n\t    DOMMap.prototype = {\n\t      'constructor': DOMMap,\n\t      'delete': function del(key) {\n\t        return dispatch(key, this.__ce__, true), dispatched;\n\t      },\n\t      'get': function get(key) {\n\t        dispatch(key, this.__ce__, false);\n\t        var v = value;\n\t        value = undefined;\n\t        return v;\n\t      },\n\t      'has': function has(key) {\n\t        return dispatch(key, this.__ce__, false), dispatched;\n\t      },\n\t      'set': function set(key, value) {\n\t        dispatch(key, this.__ce__, true);\n\t        key.addEventListener(this.__ce__.type, new Handler(value), false);\n\t        return this;\n\t      },\n\t    };\n\t\n\t    return DOMMap;\n\t\n\t  }());\n\t\n\t  function Dict() {}\n\t  Dict.prototype = (Object.create || Object)(null);\n\t\n\t  // https://dom.spec.whatwg.org/#interface-eventtarget\n\t\n\t  function createEventListener(type, callback, options) {\n\t    function eventListener(e) {\n\t      if (eventListener.once) {\n\t        e.currentTarget.removeEventListener(\n\t          e.type,\n\t          callback,\n\t          eventListener\n\t        );\n\t        eventListener.removed = true;\n\t      }\n\t      if (eventListener.passive) {\n\t        e.preventDefault = createEventListener.preventDefault;\n\t      }\n\t      if (typeof eventListener.callback === 'function') {\n\t        /* jshint validthis: true */\n\t        eventListener.callback.call(this, e);\n\t      } else if (eventListener.callback) {\n\t        eventListener.callback.handleEvent(e);\n\t      }\n\t      if (eventListener.passive) {\n\t        delete e.preventDefault;\n\t      }\n\t    }\n\t    eventListener.type = type;\n\t    eventListener.callback = callback;\n\t    eventListener.capture = !!options.capture;\n\t    eventListener.passive = !!options.passive;\n\t    eventListener.once = !!options.once;\n\t    // currently pointless but specs say to use it, so ...\n\t    eventListener.removed = false;\n\t    return eventListener;\n\t  }\n\t\n\t  createEventListener.preventDefault = function preventDefault() {};\n\t\n\t  var\n\t    Event = global.CustomEvent,\n\t    hOP = Object.prototype.hasOwnProperty,\n\t    dE = global.dispatchEvent,\n\t    aEL = global.addEventListener,\n\t    rEL = global.removeEventListener,\n\t    counter = 0,\n\t    increment = function () { counter++; },\n\t    indexOf = [].indexOf || function indexOf(value){\n\t      var length = this.length;\n\t      while(length--) {\n\t        if (this[length] === value) {\n\t          break;\n\t        }\n\t      }\n\t      return length;\n\t    },\n\t    getListenerKey = function (options) {\n\t      return ''.concat(\n\t        options.capture ? '1' : '0',\n\t        options.passive ? '1' : '0',\n\t        options.once ? '1' : '0'\n\t      );\n\t    },\n\t    augment, proto\n\t  ;\n\t\n\t  try {\n\t    aEL('_', increment, {once: true});\n\t    dE(new Event('_'));\n\t    dE(new Event('_'));\n\t    rEL('_', increment, {once: true});\n\t  } catch(o_O) {}\n\t\n\t  if (counter !== 1) {\n\t    (function () {\n\t      var dm = new DOMMap();\n\t      function createAEL(aEL) {\n\t        return function addEventListener(type, handler, options) {\n\t          if (options && typeof options !== 'boolean') {\n\t            var\n\t              info = dm.get(this),\n\t              key = getListenerKey(options),\n\t              i, tmp, wrap\n\t            ;\n\t            if (!info) dm.set(this, (info = new Dict()));\n\t            if (!(type in info)) info[type] = {\n\t              handler: [],\n\t              wrap: []\n\t            };\n\t            tmp = info[type];\n\t            i = indexOf.call(tmp.handler, handler);\n\t            if (i < 0) {\n\t              i = tmp.handler.push(handler) - 1;\n\t              tmp.wrap[i] = (wrap = new Dict());\n\t            } else {\n\t              wrap = tmp.wrap[i];\n\t            }\n\t            if (!(key in wrap)) {\n\t              wrap[key] = createEventListener(type, handler, options);\n\t              aEL.call(this, type, wrap[key], wrap[key].capture);\n\t            }\n\t          } else {\n\t            aEL.call(this, type, handler, options);\n\t          }\n\t        };\n\t      }\n\t      function createREL(rEL) {\n\t        return function removeEventListener(type, handler, options) {\n\t          if (options && typeof options !== 'boolean') {\n\t            var\n\t              info = dm.get(this),\n\t              key, i, tmp, wrap\n\t            ;\n\t            if (info && (type in info)) {\n\t              tmp = info[type];\n\t              i = indexOf.call(tmp.handler, handler);\n\t              if (-1 < i) {\n\t                key = getListenerKey(options);\n\t                wrap = tmp.wrap[i];\n\t                if (key in wrap) {\n\t                  rEL.call(this, type, wrap[key], wrap[key].capture);\n\t                  delete wrap[key];\n\t                  // return if there are other wraps\n\t                  for (key in wrap) return;\n\t                  // otherwise remove all the things\n\t                  tmp.handler.splice(i, 1);\n\t                  tmp.wrap.splice(i, 1);\n\t                  // if there are no other handlers\n\t                  if (tmp.handler.length === 0)\n\t                    // drop the info[type] entirely\n\t                    delete info[type];\n\t                }\n\t              }\n\t            }\n\t          } else {\n\t            rEL.call(this, type, handler, options);\n\t          }\n\t        };\n\t      }\n\t\n\t      augment = function (Constructor) {\n\t        if (!Constructor) return;\n\t        var proto = Constructor.prototype;\n\t        proto.addEventListener = createAEL(proto.addEventListener);\n\t        proto.removeEventListener = createREL(proto.removeEventListener);\n\t      };\n\t\n\t      if (global.EventTarget) {\n\t        augment(EventTarget);\n\t      } else {\n\t        augment(global.Text);\n\t        augment(global.Element || global.HTMLElement);\n\t        augment(global.HTMLDocument);\n\t        augment(global.Window || {prototype:global});\n\t        augment(global.XMLHttpRequest);\n\t      }\n\t\n\t    }());\n\t  }\n\t\n\t}(self));\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"precision highp float;\\n#define GLSLIFY 1\\nuniform vec2 resolution;\\nuniform sampler2D u_mySampler;\\nuniform float time;\\nuniform float Period;\\n\\nvarying vec2 v_position;\\n\\n// http://www.nutty.ca/?page_id=352&link=refraction\\n// Description : Array and textureless GLSL 3D simplex noise function.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\\nfloat snoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n  // First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n  // Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n  // Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n  //Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n  // Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\\n\\nvoid main() {\\n  float z = time * Period;\\n  vec2 uv = v_position * 1.5;\\n  float value = (snoise(vec3(uv, z)) + 1.0) * 0.5;\\n  vec4 greyscale = vec4(value, value, value, 1.0);\\n  gl_FragColor = greyscale;\\n}\\n\"\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"precision highp float;\\n#define GLSLIFY 1\\nuniform vec2 resolution;\\nuniform sampler2D u_noiseSampler;\\nuniform sampler2D u_texSampler;\\nuniform float Amplitude;\\nuniform float Frequency;\\nuniform float Intensity;\\n\\nvarying vec2 v_position;\\nvarying vec2 v_texcoord;\\n\\nvec3 GetNormal () {\\n  float sobelX[9];\\n  sobelX[0] = 1.0; sobelX[1] = 0.0; sobelX[2] = -1.0;\\n  sobelX[3] = 2.0; sobelX[4] = 0.0; sobelX[5] = -2.0;\\n  sobelX[6] = 1.0; sobelX[7] = 0.0; sobelX[8] = -1.0;\\n\\n  float sobelY[9];\\n  sobelY[0] = 1.0; sobelY[1] = 2.0; sobelY[2] =  1.0;\\n  sobelY[3] = 0.0; sobelY[4] = 0.0; sobelY[5] =  0.0;\\n  sobelY[6] = -1.0; sobelY[7] = -2.0; sobelY[8] = -1.0;\\n\\n  float texelX[9];\\n  float texelY[9];\\n  vec2 uv = v_texcoord * Frequency;\\n  for (int i = 0; i < 9; i++)\\n  {\\n      vec4 otherTexel = texture2D(u_noiseSampler, uv);\\n      float average = (otherTexel.x + otherTexel.y + otherTexel.z) / 3.0;\\n      texelX[i] = average  * sobelX[i];\\n      texelY[i] = average  * sobelY[i];\\n  }\\n  vec3 normal = vec3(\\n    (texelX[0] + texelX[3] + texelX[6]) +\\n    (texelX[2] + texelX[5] + texelX[8]),\\n    (texelY[1] + texelY[2] + texelY[3]) +\\n    (texelY[6] + texelY[7] + texelY[8]),\\n    1.0 / Amplitude);\\n\\n  return normalize(normal);\\n}\\n\\nvoid main() {\\n  vec3 normal = GetNormal();\\n  vec2 offset = (normal.xy + vec2(0, 0.5)) * Intensity;\\n  vec2 uv = v_position * vec2(1.0, -0.5) + vec2(0, 0.5);\\n  // gl_FragColor.xyz = normal;\\n  // gl_FragColor.xyz = texture2D(u_noiseSampler, v_texcoord).xyz;\\n  gl_FragColor.xyz = texture2D(u_texSampler, uv + offset).xyz;\\n  gl_FragColor.w = 1.0;\\n}\\n\"\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"#define GLSLIFY 1\\nattribute vec2 position;\\nvarying vec2 v_position;\\nvarying vec2 v_texcoord;\\n\\nvoid main() {\\n  gl_Position = vec4(position, 0, 1);\\n  v_position = position;\\n  v_texcoord = position.xy * 0.5 + 0.5;\\n}\\n\"\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"266c6946415c3f1d47a8b2d96471bc0c.jpg\";\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n\t * @license twgl.js 2.1.0 Copyright (c) 2015, Gregg Tavares All Rights Reserved.\n\t * Available via the MIT license.\n\t * see: http://github.com/greggman/twgl.js for details\n\t */\n\t/**\n\t * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n\t * Available via the MIT or new BSD license.\n\t * see: http://github.com/jrburke/almond for details\n\t */\n\t(function (root, factory) {\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } if (typeof module !== 'undefined' && module.exports) {\n\t        module.exports = factory();\n\t    } else {\n\t        root.twgl = factory();\n\t    }\n\t}(this, function () {\n\t\n\t/**\n\t * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n\t * Available via the MIT or new BSD license.\n\t * see: http://github.com/jrburke/almond for details\n\t */\n\t//Going sloppy to avoid 'use strict' string cost, but strict practices should\n\t//be followed.\n\t/*jslint sloppy: true */\n\t/*global setTimeout: false */\n\t\n\tvar notrequirebecasebrowserifymessesupjs, notrequirebecasebrowserifymessesup, define;\n\t(function (undef) {\n\t    var main, req, makeMap, handlers,\n\t        defined = {},\n\t        waiting = {},\n\t        config = {},\n\t        defining = {},\n\t        hasOwn = Object.prototype.hasOwnProperty,\n\t        aps = [].slice,\n\t        jsSuffixRegExp = /\\.js$/;\n\t\n\t    function hasProp(obj, prop) {\n\t        return hasOwn.call(obj, prop);\n\t    }\n\t\n\t    /**\n\t     * Given a relative module name, like ./something, normalize it to\n\t     * a real name that can be mapped to a path.\n\t     * @param {String} name the relative name\n\t     * @param {String} baseName a real name that the name arg is relative\n\t     * to.\n\t     * @returns {String} normalized name\n\t     */\n\t    function normalize(name, baseName) {\n\t        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n\t            foundI, foundStarMap, starI, i, j, part,\n\t            baseParts = baseName && baseName.split(\"/\"),\n\t            map = config.map,\n\t            starMap = (map && map['*']) || {};\n\t\n\t        //Adjust any relative paths.\n\t        if (name && name.charAt(0) === \".\") {\n\t            //If have a base name, try to normalize against it,\n\t            //otherwise, assume it is a top-level notrequirebecasebrowserifymessesup that will\n\t            //be relative to baseUrl in the end.\n\t            if (baseName) {\n\t                name = name.split('/');\n\t                lastIndex = name.length - 1;\n\t\n\t                // Node .js allowance:\n\t                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n\t                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n\t                }\n\t\n\t                //Lop off the last part of baseParts, so that . matches the\n\t                //\"directory\" and not name of the baseName's module. For instance,\n\t                //baseName of \"one/two/three\", maps to \"one/two/three.js\", but we\n\t                //want the directory, \"one/two\" for this normalization.\n\t                name = baseParts.slice(0, baseParts.length - 1).concat(name);\n\t\n\t                //start trimDots\n\t                for (i = 0; i < name.length; i += 1) {\n\t                    part = name[i];\n\t                    if (part === \".\") {\n\t                        name.splice(i, 1);\n\t                        i -= 1;\n\t                    } else if (part === \"..\") {\n\t                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n\t                            //End of the line. Keep at least one non-dot\n\t                            //path segment at the front so it can be mapped\n\t                            //correctly to disk. Otherwise, there is likely\n\t                            //no path mapping for a path starting with '..'.\n\t                            //This can still fail, but catches the most reasonable\n\t                            //uses of ..\n\t                            break;\n\t                        } else if (i > 0) {\n\t                            name.splice(i - 1, 2);\n\t                            i -= 2;\n\t                        }\n\t                    }\n\t                }\n\t                //end trimDots\n\t\n\t                name = name.join(\"/\");\n\t            } else if (name.indexOf('./') === 0) {\n\t                // No baseName, so this is ID is resolved relative\n\t                // to baseUrl, pull off the leading dot.\n\t                name = name.substring(2);\n\t            }\n\t        }\n\t\n\t        //Apply map config if available.\n\t        if ((baseParts || starMap) && map) {\n\t            nameParts = name.split('/');\n\t\n\t            for (i = nameParts.length; i > 0; i -= 1) {\n\t                nameSegment = nameParts.slice(0, i).join(\"/\");\n\t\n\t                if (baseParts) {\n\t                    //Find the longest baseName segment match in the config.\n\t                    //So, do joins on the biggest to smallest lengths of baseParts.\n\t                    for (j = baseParts.length; j > 0; j -= 1) {\n\t                        mapValue = map[baseParts.slice(0, j).join('/')];\n\t\n\t                        //baseName segment has  config, find if it has one for\n\t                        //this name.\n\t                        if (mapValue) {\n\t                            mapValue = mapValue[nameSegment];\n\t                            if (mapValue) {\n\t                                //Match, update name to the new value.\n\t                                foundMap = mapValue;\n\t                                foundI = i;\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t\n\t                if (foundMap) {\n\t                    break;\n\t                }\n\t\n\t                //Check for a star map match, but just hold on to it,\n\t                //if there is a shorter segment match later in a matching\n\t                //config, then favor over this star map.\n\t                if (!foundStarMap && starMap && starMap[nameSegment]) {\n\t                    foundStarMap = starMap[nameSegment];\n\t                    starI = i;\n\t                }\n\t            }\n\t\n\t            if (!foundMap && foundStarMap) {\n\t                foundMap = foundStarMap;\n\t                foundI = starI;\n\t            }\n\t\n\t            if (foundMap) {\n\t                nameParts.splice(0, foundI, foundMap);\n\t                name = nameParts.join('/');\n\t            }\n\t        }\n\t\n\t        return name;\n\t    }\n\t\n\t    function makeRequire(relName, forceSync) {\n\t        return function () {\n\t            //A version of a notrequirebecasebrowserifymessesup function that passes a moduleName\n\t            //value for items that may need to\n\t            //look up paths relative to the moduleName\n\t            var args = aps.call(arguments, 0);\n\t\n\t            //If first arg is not notrequirebecasebrowserifymessesup('string'), and there is only\n\t            //one arg, it is the array form without a callback. Insert\n\t            //a null so that the following concat is correct.\n\t            if (typeof args[0] !== 'string' && args.length === 1) {\n\t                args.push(null);\n\t            }\n\t            return req.apply(undef, args.concat([relName, forceSync]));\n\t        };\n\t    }\n\t\n\t    function makeNormalize(relName) {\n\t        return function (name) {\n\t            return normalize(name, relName);\n\t        };\n\t    }\n\t\n\t    function makeLoad(depName) {\n\t        return function (value) {\n\t            defined[depName] = value;\n\t        };\n\t    }\n\t\n\t    function callDep(name) {\n\t        if (hasProp(waiting, name)) {\n\t            var args = waiting[name];\n\t            delete waiting[name];\n\t            defining[name] = true;\n\t            main.apply(undef, args);\n\t        }\n\t\n\t        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n\t            throw new Error('No ' + name);\n\t        }\n\t        return defined[name];\n\t    }\n\t\n\t    //Turns a plugin!resource to [plugin, resource]\n\t    //with the plugin being undefined if the name\n\t    //did not have a plugin prefix.\n\t    function splitPrefix(name) {\n\t        var prefix,\n\t            index = name ? name.indexOf('!') : -1;\n\t        if (index > -1) {\n\t            prefix = name.substring(0, index);\n\t            name = name.substring(index + 1, name.length);\n\t        }\n\t        return [prefix, name];\n\t    }\n\t\n\t    /**\n\t     * Makes a name map, normalizing the name, and using a plugin\n\t     * for normalization if necessary. Grabs a ref to plugin\n\t     * too, as an optimization.\n\t     */\n\t    makeMap = function (name, relName) {\n\t        var plugin,\n\t            parts = splitPrefix(name),\n\t            prefix = parts[0];\n\t\n\t        name = parts[1];\n\t\n\t        if (prefix) {\n\t            prefix = normalize(prefix, relName);\n\t            plugin = callDep(prefix);\n\t        }\n\t\n\t        //Normalize according\n\t        if (prefix) {\n\t            if (plugin && plugin.normalize) {\n\t                name = plugin.normalize(name, makeNormalize(relName));\n\t            } else {\n\t                name = normalize(name, relName);\n\t            }\n\t        } else {\n\t            name = normalize(name, relName);\n\t            parts = splitPrefix(name);\n\t            prefix = parts[0];\n\t            name = parts[1];\n\t            if (prefix) {\n\t                plugin = callDep(prefix);\n\t            }\n\t        }\n\t\n\t        //Using ridiculous property names for space reasons\n\t        return {\n\t            f: prefix ? prefix + '!' + name : name, //fullName\n\t            n: name,\n\t            pr: prefix,\n\t            p: plugin\n\t        };\n\t    };\n\t\n\t    function makeConfig(name) {\n\t        return function () {\n\t            return (config && config.config && config.config[name]) || {};\n\t        };\n\t    }\n\t\n\t    handlers = {\n\t        notrequirebecasebrowserifymessesup: function (name) {\n\t            return makeRequire(name);\n\t        },\n\t        exports: function (name) {\n\t            var e = defined[name];\n\t            if (typeof e !== 'undefined') {\n\t                return e;\n\t            } else {\n\t                return (defined[name] = {});\n\t            }\n\t        },\n\t        module: function (name) {\n\t            return {\n\t                id: name,\n\t                uri: '',\n\t                exports: defined[name],\n\t                config: makeConfig(name)\n\t            };\n\t        }\n\t    };\n\t\n\t    main = function (name, deps, callback, relName) {\n\t        var cjsModule, depName, ret, map, i,\n\t            args = [],\n\t            callbackType = typeof callback,\n\t            usingExports;\n\t\n\t        //Use name if no relName\n\t        relName = relName || name;\n\t\n\t        //Call the callback to define the module, if necessary.\n\t        if (callbackType === 'undefined' || callbackType === 'function') {\n\t            //Pull out the defined dependencies and pass the ordered\n\t            //values to the callback.\n\t            //Default to [notrequirebecasebrowserifymessesup, exports, module] if no deps\n\t            deps = !deps.length && callback.length ? ['notrequirebecasebrowserifymessesup', 'exports', 'module'] : deps;\n\t            for (i = 0; i < deps.length; i += 1) {\n\t                map = makeMap(deps[i], relName);\n\t                depName = map.f;\n\t\n\t                //Fast path CommonJS standard dependencies.\n\t                if (depName === \"notrequirebecasebrowserifymessesup\") {\n\t                    args[i] = handlers.notrequirebecasebrowserifymessesup(name);\n\t                } else if (depName === \"exports\") {\n\t                    //CommonJS module spec 1.1\n\t                    args[i] = handlers.exports(name);\n\t                    usingExports = true;\n\t                } else if (depName === \"module\") {\n\t                    //CommonJS module spec 1.1\n\t                    cjsModule = args[i] = handlers.module(name);\n\t                } else if (hasProp(defined, depName) ||\n\t                           hasProp(waiting, depName) ||\n\t                           hasProp(defining, depName)) {\n\t                    args[i] = callDep(depName);\n\t                } else if (map.p) {\n\t                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n\t                    args[i] = defined[depName];\n\t                } else {\n\t                    throw new Error(name + ' missing ' + depName);\n\t                }\n\t            }\n\t\n\t            ret = callback ? callback.apply(defined[name], args) : undefined;\n\t\n\t            if (name) {\n\t                //If setting exports via \"module\" is in play,\n\t                //favor that over return value and exports. After that,\n\t                //favor a non-undefined return value over exports use.\n\t                if (cjsModule && cjsModule.exports !== undef &&\n\t                        cjsModule.exports !== defined[name]) {\n\t                    defined[name] = cjsModule.exports;\n\t                } else if (ret !== undef || !usingExports) {\n\t                    //Use the return value from the function.\n\t                    defined[name] = ret;\n\t                }\n\t            }\n\t        } else if (name) {\n\t            //May just be an object definition for the module. Only\n\t            //worry about defining if have a module name.\n\t            defined[name] = callback;\n\t        }\n\t    };\n\t\n\t    notrequirebecasebrowserifymessesupjs = notrequirebecasebrowserifymessesup = req = function (deps, callback, relName, forceSync, alt) {\n\t        if (typeof deps === \"string\") {\n\t            if (handlers[deps]) {\n\t                //callback in this case is really relName\n\t                return handlers[deps](callback);\n\t            }\n\t            //Just return the module wanted. In this scenario, the\n\t            //deps arg is the module name, and second arg (if passed)\n\t            //is just the relName.\n\t            //Normalize module name, if it contains . or ..\n\t            return callDep(makeMap(deps, callback).f);\n\t        } else if (!deps.splice) {\n\t            //deps is a config object, not an array.\n\t            config = deps;\n\t            if (config.deps) {\n\t                req(config.deps, config.callback);\n\t            }\n\t            if (!callback) {\n\t                return;\n\t            }\n\t\n\t            if (callback.splice) {\n\t                //callback is an array, which means it is a dependency list.\n\t                //Adjust args if there are dependencies\n\t                deps = callback;\n\t                callback = relName;\n\t                relName = null;\n\t            } else {\n\t                deps = undef;\n\t            }\n\t        }\n\t\n\t        //Support notrequirebecasebrowserifymessesup(['a'])\n\t        callback = callback || function () {};\n\t\n\t        //If relName is a function, it is an errback handler,\n\t        //so remove it.\n\t        if (typeof relName === 'function') {\n\t            relName = forceSync;\n\t            forceSync = alt;\n\t        }\n\t\n\t        //Simulate async callback;\n\t        if (forceSync) {\n\t            main(undef, deps, callback, relName);\n\t        } else {\n\t            //Using a non-zero value because of concern for what old browsers\n\t            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n\t            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n\t            //If want a value immediately, use notrequirebecasebrowserifymessesup('id') instead -- something\n\t            //that works in almond on the global level, but not guaranteed and\n\t            //unlikely to work in other AMD implementations.\n\t            setTimeout(function () {\n\t                main(undef, deps, callback, relName);\n\t            }, 4);\n\t        }\n\t\n\t        return req;\n\t    };\n\t\n\t    /**\n\t     * Just drops the config on the floor, but returns req in case\n\t     * the config return value is used.\n\t     */\n\t    req.config = function (cfg) {\n\t        return req(cfg);\n\t    };\n\t\n\t    /**\n\t     * Expose module registry for debugging and tooling\n\t     */\n\t    notrequirebecasebrowserifymessesupjs._defined = defined;\n\t\n\t    define = function (name, deps, callback) {\n\t        if (typeof name !== 'string') {\n\t            throw new Error('See almond README: incorrect module build, no module name');\n\t        }\n\t\n\t        //This module may not have dependencies\n\t        if (!deps.splice) {\n\t            //deps is not an array, so probably means\n\t            //an object literal or factory function for\n\t            //the value. Adjust args.\n\t            callback = deps;\n\t            deps = [];\n\t        }\n\t\n\t        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n\t            waiting[name] = [name, deps, callback];\n\t        }\n\t    };\n\t\n\t    define.amd = {\n\t        jQuery: true\n\t    };\n\t}());\n\t\n\tdefine(\"node_modules/almond/almond.js\", function(){});\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\tdefine('twgl/typedarrays',[], function() {\n\t  \n\t\n\t  /**\n\t   * Low level shader typed array related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.typedArray` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/typedArray\n\t   */\n\t\n\t\n\t  // make sure we don't see a global gl\n\t  var gl = undefined;  // eslint-disable-line\n\t\n\t  /* DataType */\n\t  var BYTE                           = 0x1400;\n\t  var UNSIGNED_BYTE                  = 0x1401;\n\t  var SHORT                          = 0x1402;\n\t  var UNSIGNED_SHORT                 = 0x1403;\n\t  var INT                            = 0x1404;\n\t  var UNSIGNED_INT                   = 0x1405;\n\t  var FLOAT                          = 0x1406;\n\t\n\t  /**\n\t   * Get the GL type for a typedArray\n\t   * @param {ArrayBuffer|ArrayBufferView} typedArray a typedArray\n\t   * @return {number} the GL type for array. For example pass in an `Int8Array` and `gl.BYTE` will\n\t   *   be returned. Pass in a `Uint32Array` and `gl.UNSIGNED_INT` will be returned\n\t   * @memberOf module:twgl/typedArray\n\t   */\n\t  function getGLTypeForTypedArray(typedArray) {\n\t    if (typedArray instanceof Int8Array)         { return BYTE; }           // eslint-disable-line\n\t    if (typedArray instanceof Uint8Array)        { return UNSIGNED_BYTE; }  // eslint-disable-line\n\t    if (typedArray instanceof Uint8ClampedArray) { return UNSIGNED_BYTE; }  // eslint-disable-line\n\t    if (typedArray instanceof Int16Array)        { return SHORT; }          // eslint-disable-line\n\t    if (typedArray instanceof Uint16Array)       { return UNSIGNED_SHORT; } // eslint-disable-line\n\t    if (typedArray instanceof Int32Array)        { return INT; }            // eslint-disable-line\n\t    if (typedArray instanceof Uint32Array)       { return UNSIGNED_INT; }   // eslint-disable-line\n\t    if (typedArray instanceof Float32Array)      { return FLOAT; }          // eslint-disable-line\n\t    throw \"unsupported typed array type\";\n\t  }\n\t\n\t  /**\n\t   * Get the typed array constructor for a given GL type\n\t   * @param {number} type the GL type. (eg: `gl.UNSIGNED_INT`)\n\t   * @return {function} the constructor for a the corresponding typed array. (eg. `Uint32Array`).\n\t   * @memberOf module:twgl/typedArray\n\t   */\n\t  function getTypedArrayTypeForGLType(type) {\n\t    switch (type) {\n\t      case BYTE:           return Int8Array;     // eslint-disable-line\n\t      case UNSIGNED_BYTE:  return Uint8Array;    // eslint-disable-line\n\t      case SHORT:          return Int16Array;    // eslint-disable-line\n\t      case UNSIGNED_SHORT: return Uint16Array;   // eslint-disable-line\n\t      case INT:            return Int32Array;    // eslint-disable-line\n\t      case UNSIGNED_INT:   return Uint32Array;   // eslint-disable-line\n\t      case FLOAT:          return Float32Array;  // eslint-disable-line\n\t      default:\n\t        throw \"unknown gl type\";\n\t    }\n\t  }\n\t\n\t  function isArrayBuffer(a) {\n\t    return a && a.buffer && a.buffer instanceof ArrayBuffer;\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  return {\n\t    \"getGLTypeForTypedArray\": getGLTypeForTypedArray,\n\t    \"getTypedArrayTypeForGLType\": getTypedArrayTypeForGLType,\n\t    \"isArrayBuffer\": isArrayBuffer,\n\t  };\n\t});\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/utils',[], function() {\n\t  \n\t\n\t  /**\n\t   * Copy an object 1 level deep\n\t   * @param {object} src object to copy\n\t   * @return {object} the copy\n\t   */\n\t  function shallowCopy(src) {\n\t    var dst = {};\n\t    Object.keys(src).forEach(function(key) {\n\t      dst[key] = src[key];\n\t    });\n\t    return dst;\n\t  }\n\t\n\t  /**\n\t   * Copy named properties\n\t   *\n\t   * @param {string[]} names names of properties to copy\n\t   * @param {object} src object to copy properties from\n\t   * @param {object} dst object to copy properties to\n\t   */\n\t  function copyNamedProperties(names, src, dst) {\n\t    names.forEach(function(name) {\n\t      var value = src[name];\n\t      if (value !== undefined) {\n\t        dst[name] = value;\n\t      }\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Copies properties from source to dest only if a matching key is in dest\n\t   *\n\t   * @param {Object.<string, ?>} src the source\n\t   * @param {Object.<string, ?>} dst the dest\n\t   */\n\t  function copyExistingProperties(src, dst) {\n\t    Object.keys(dst).forEach(function(key) {\n\t      if (dst.hasOwnProperty(key) && src.hasOwnProperty(key)) {\n\t        dst[key] = src[key];\n\t      }\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Gets the gl version as a number\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @return {number} version of gl\n\t   */\n\t  function getVersionAsNumber(gl) {\n\t    return parseFloat(gl.getParameter(gl.VERSION).substr(6));\n\t  }\n\t\n\t  /**\n\t   * Check if context is WebGL 2.0\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @return {bool} true if it's WebGL 2.0\n\t   * @memberOf module:twgl\n\t   */\n\t  function isWebGL2(gl) {\n\t    return gl.getParameter(gl.VERSION).indexOf(\"WebGL 2.0\") === 0;\n\t  }\n\t\n\t  /**\n\t   * Check if context is WebGL 1.0\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @return {bool} true if it's WebGL 1.0\n\t   * @memberOf module:twgl\n\t   */\n\t  function isWebGL1(gl) {\n\t    var version = getVersionAsNumber(gl);\n\t    return version <= 1.0 && version > 0.0;  // because as of 2016/5 Edge returns 0.96\n\t  }\n\t\n\t  var error =\n\t      (    window.console\n\t        && window.console.error\n\t        && typeof window.console.error === \"function\"\n\t      )\n\t      ? window.console.error.bind(window.console)\n\t      : function() { };\n\t\n\t  var warn =\n\t      (    window.console\n\t        && window.console.warn\n\t        && typeof window.console.warn === \"function\"\n\t      )\n\t      ? window.console.warn.bind(window.console)\n\t      : function() { };\n\t\n\t  return {\n\t    copyExistingProperties: copyExistingProperties,\n\t    copyNamedProperties: copyNamedProperties,\n\t    shallowCopy: shallowCopy,\n\t    isWebGL1: isWebGL1,\n\t    isWebGL2: isWebGL2,\n\t    error: error,\n\t    warn: warn,\n\t  };\n\t});\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/attributes',[\n\t    './typedarrays',\n\t    './utils',\n\t  ], function(\n\t    typedArrays,\n\t    utils) {\n\t  \n\t\n\t  /**\n\t   * Low level attribute and buffer related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.attributes` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/attributes\n\t   */\n\t\n\t  // make sure we don't see a global gl\n\t  var gl = undefined;  // eslint-disable-line\n\t  var defaults = {\n\t    attribPrefix: \"\",\n\t  };\n\t\n\t  /**\n\t   * Sets the default attrib prefix\n\t   *\n\t   * When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`\n\t   * as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.\n\t   *\n\t   * In otherwords I'll create arrays of geometry like this\n\t   *\n\t   *     var arrays = {\n\t   *       position: ...\n\t   *       normal: ...\n\t   *       texcoord: ...\n\t   *     };\n\t   *\n\t   * But need those mapped to attributes and my attributes start with `a_`.\n\t   *\n\t   * @deprecated see {@link module:twgl.setDefaults}\n\t   * @param {string} prefix prefix for attribs\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function setAttributePrefix(prefix) {\n\t    defaults.attribPrefix = prefix;\n\t  }\n\t\n\t  function setDefaults(newDefaults) {\n\t    utils.copyExistingProperties(newDefaults, defaults);\n\t  }\n\t\n\t  function setBufferFromTypedArray(gl, type, buffer, array, drawType) {\n\t    gl.bindBuffer(type, buffer);\n\t    gl.bufferData(type, array, drawType || gl.STATIC_DRAW);\n\t  }\n\t\n\t  /**\n\t   * Given typed array creates a WebGLBuffer and copies the typed array\n\t   * into it.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {ArrayBuffer|ArrayBufferView|WebGLBuffer} typedArray the typed array. Note: If a WebGLBuffer is passed in it will just be returned. No action will be taken\n\t   * @param {number} [type] the GL bind type for the buffer. Default = `gl.ARRAY_BUFFER`.\n\t   * @param {number} [drawType] the GL draw type for the buffer. Default = 'gl.STATIC_DRAW`.\n\t   * @return {WebGLBuffer} the created WebGLBuffer\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBufferFromTypedArray(gl, typedArray, type, drawType) {\n\t    if (typedArray instanceof WebGLBuffer) {\n\t      return typedArray;\n\t    }\n\t    type = type || gl.ARRAY_BUFFER;\n\t    var buffer = gl.createBuffer();\n\t    setBufferFromTypedArray(gl, type, buffer, typedArray, drawType);\n\t    return buffer;\n\t  }\n\t\n\t  function isIndices(name) {\n\t    return name === \"indices\";\n\t  }\n\t\n\t  // This is really just a guess. Though I can't really imagine using\n\t  // anything else? Maybe for some compression?\n\t  function getNormalizationForTypedArray(typedArray) {\n\t    if (typedArray instanceof Int8Array)    { return true; }  // eslint-disable-line\n\t    if (typedArray instanceof Uint8Array)   { return true; }  // eslint-disable-line\n\t    return false;\n\t  }\n\t\n\t  function getArray(array) {\n\t    return array.length ? array : array.data;\n\t  }\n\t\n\t  var texcoordRE = /coord|texture/i;\n\t  var colorRE = /color|colour/i;\n\t\n\t  function guessNumComponentsFromName(name, length) {\n\t    var numComponents;\n\t    if (texcoordRE.test(name)) {\n\t      numComponents = 2;\n\t    } else if (colorRE.test(name)) {\n\t      numComponents = 4;\n\t    } else {\n\t      numComponents = 3;  // position, normals, indices ...\n\t    }\n\t\n\t    if (length % numComponents > 0) {\n\t      throw \"Can not guess numComponents for attribute '\" + name + \"'. Tried \" +\n\t            numComponents + \" but \" + length +\n\t            \" values is not evenly divisible by \" + numComponents +\n\t            \". You should specify it.\";\n\t    }\n\t\n\t    return numComponents;\n\t  }\n\t\n\t  function getNumComponents(array, arrayName) {\n\t    return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);\n\t  }\n\t\n\t  function makeTypedArray(array, name) {\n\t    if (typedArrays.isArrayBuffer(array)) {\n\t      return array;\n\t    }\n\t\n\t    if (typedArrays.isArrayBuffer(array.data)) {\n\t      return array.data;\n\t    }\n\t\n\t    if (Array.isArray(array)) {\n\t      array = {\n\t        data: array,\n\t      };\n\t    }\n\t\n\t    var Type = array.type;\n\t    if (!Type) {\n\t      if (isIndices(name)) {\n\t        Type = Uint16Array;\n\t      } else {\n\t        Type = Float32Array;\n\t      }\n\t    }\n\t    return new Type(array.data);\n\t  }\n\t\n\t  /**\n\t   * The info for an attribute. This is effectively just the arguments to `gl.vertexAttribPointer` plus the WebGLBuffer\n\t   * for the attribute.\n\t   *\n\t   * @typedef {Object} AttribInfo\n\t   * @property {number} [numComponents] the number of components for this attribute.\n\t   * @property {number} [size] synonym for `numComponents`.\n\t   * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`\n\t   * @property {boolean} [normalized] whether or not to normalize the data. Default = false\n\t   * @property {number} [offset] offset into buffer in bytes. Default = 0\n\t   * @property {number} [stride] the stride in bytes per element. Default = 0\n\t   * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute\n\t   * @property {number} [drawType] the draw type passed to gl.bufferData. Default = gl.STATIC_DRAW\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Use this type of array spec when TWGL can't guess the type or number of compoments of an array\n\t   * @typedef {Object} FullArraySpec\n\t   * @property {(number[]|ArrayBuffer)} data The data of the array.\n\t   * @property {number} [numComponents] number of components for `vertexAttribPointer`. Default is based on the name of the array.\n\t   *    If `coord` is in the name assumes `numComponents = 2`.\n\t   *    If `color` is in the name assumes `numComponents = 4`.\n\t   *    otherwise assumes `numComponents = 3`\n\t   * @property {constructor} type The type. This is only used if `data` is a JavaScript array. It is the constructor for the typedarray. (eg. `Uint8Array`).\n\t   * For example if you want colors in a `Uint8Array` you might have a `FullArraySpec` like `{ type: Uint8Array, data: [255,0,255,255, ...], }`.\n\t   * @property {number} [size] synonym for `numComponents`.\n\t   * @property {boolean} [normalize] normalize for `vertexAttribPointer`. Default is true if type is `Int8Array` or `Uint8Array` otherwise false.\n\t   * @property {number} [stride] stride for `vertexAttribPointer`. Default = 0\n\t   * @property {number} [offset] offset for `vertexAttribPointer`. Default = 0\n\t   * @property {string} [attrib] name of attribute this array maps to. Defaults to same name as array prefixed by the default attribPrefix.\n\t   * @property {string} [name] synonym for `attrib`.\n\t   * @property {string} [attribName] synonym for `attrib`.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * An individual array in {@link module:twgl.Arrays}\n\t   *\n\t   * When passed to {@link module:twgl.createBufferInfoFromArrays} if an ArraySpec is `number[]` or `ArrayBuffer`\n\t   * the types will be guessed based on the name. `indices` will be `Uint16Array`, everything else will\n\t   * be `Float32Array`\n\t   *\n\t   * @typedef {(number[]|ArrayBuffer|module:twgl.FullArraySpec)} ArraySpec\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * This is a JavaScript object of arrays by name. The names should match your shader's attributes. If your\n\t   * attributes have a common prefix you can specify it by calling {@link module:twgl.setAttributePrefix}.\n\t   *\n\t   *     Bare JavaScript Arrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: [-1, 1, 0],\n\t   *            normal: [0, 1, 0],\n\t   *            ...\n\t   *         }\n\t   *\n\t   *     Bare TypedArrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: new Float32Array([-1, 1, 0]),\n\t   *            color: new Uint8Array([255, 128, 64, 255]),\n\t   *            ...\n\t   *         }\n\t   *\n\t   * *   Will guess at `numComponents` if not specified based on name.\n\t   *\n\t   *     If `coord` is in the name assumes `numComponents = 2`\n\t   *\n\t   *     If `color` is in the name assumes `numComponents = 4`\n\t   *\n\t   *     otherwise assumes `numComponents = 3`\n\t   *\n\t   * Objects with various fields. See {@link module:twgl.FullArraySpec}.\n\t   *\n\t   *     var arrays = {\n\t   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n\t   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n\t   *     };\n\t   *\n\t   * @typedef {Object.<string, module:twgl.ArraySpec>} Arrays\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t\n\t  /**\n\t   * Creates a set of attribute data and WebGLBuffers from set of arrays\n\t   *\n\t   * Given\n\t   *\n\t   *      var arrays = {\n\t   *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n\t   *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },\n\t   *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n\t   *      };\n\t   *\n\t   * returns something like\n\t   *\n\t   *      var attribs = {\n\t   *        position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n\t   *        texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n\t   *        normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n\t   *        color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },\n\t   *      };\n\t   *\n\t   * notes:\n\t   *\n\t   * *   Arrays can take various forms\n\t   *\n\t   *     Bare JavaScript Arrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: [-1, 1, 0],\n\t   *            normal: [0, 1, 0],\n\t   *            ...\n\t   *         }\n\t   *\n\t   *     Bare TypedArrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: new Float32Array([-1, 1, 0]),\n\t   *            color: new Uint8Array([255, 128, 64, 255]),\n\t   *            ...\n\t   *         }\n\t   *\n\t   * *   Will guess at `numComponents` if not specified based on name.\n\t   *\n\t   *     If `coord` is in the name assumes `numComponents = 2`\n\t   *\n\t   *     If `color` is in the name assumes `numComponents = 4`\n\t   *\n\t   *     otherwise assumes `numComponents = 3`\n\t   *\n\t   * @param {WebGLRenderingContext} gl The webgl rendering context.\n\t   * @param {module:twgl.Arrays} arrays The arrays\n\t   * @return {Object.<string, module:twgl.AttribInfo>} the attribs\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createAttribsFromArrays(gl, arrays) {\n\t    var attribs = {};\n\t    Object.keys(arrays).forEach(function(arrayName) {\n\t      if (!isIndices(arrayName)) {\n\t        var array = arrays[arrayName];\n\t        var attribName = array.attrib || array.name || array.attribName || (defaults.attribPrefix + arrayName);\n\t        var typedArray = makeTypedArray(array, arrayName);\n\t        attribs[attribName] = {\n\t          buffer:        createBufferFromTypedArray(gl, typedArray, undefined, array.drawType),\n\t          numComponents: getNumComponents(array, arrayName),\n\t          type:          typedArrays.getGLTypeForTypedArray(typedArray),\n\t          normalize:     array.normalize !== undefined ? array.normalize : getNormalizationForTypedArray(typedArray),\n\t          stride:        array.stride || 0,\n\t          offset:        array.offset || 0,\n\t          drawType:      array.drawType,\n\t        };\n\t      }\n\t    });\n\t    return attribs;\n\t  }\n\t\n\t  /**\n\t   * Sets the contents of a buffer attached to an attribInfo\n\t   *\n\t   * This is helper function to dynamically update a buffer.\n\t   *\n\t   * Let's say you make a bufferInfo\n\t   *\n\t   *     var arrays = {\n\t   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n\t   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n\t   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n\t   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n\t   *     };\n\t   *     var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\n\t   *\n\t   *  And you want to dynamically upate the positions. You could do this\n\t   *\n\t   *     // assuming arrays.position has already been updated with new data.\n\t   *     twgl.setAttribInfoBufferFromArray(gl, bufferInfo.attribs.position, arrays.position);\n\t   *\n\t   * @param {WebGLRenderingContext} gl\n\t   * @param {AttribInfo} attribInfo The attribInfo who's buffer contents to set. NOTE: If you have an attribute prefix\n\t   *   the name of the attribute will include the prefix.\n\t   * @param {ArraySpec} array Note: it is arguably ineffient to pass in anything but a typed array because anything\n\t   *    else will have to be converted to a typed array before it can be used by WebGL. During init time that\n\t   *    inefficiency is usually not important but if you're updating data dynamically best to be efficient.\n\t   * @param {number} [offset] an optional offset into the buffer. This is only an offset into the WebGL buffer\n\t   *    not the array. To pass in an offset into the array itself use a typed array and create an `ArrayBufferView`\n\t   *    for the portion of the array you want to use.\n\t   *\n\t   *        var someArray = new Float32Array(1000); // an array with 1000 floats\n\t   *        var someSubArray = new Float32Array(someArray.buffer, offsetInBytes, sizeInUnits); // a view into someArray\n\t   *\n\t   *    Now you can pass `someSubArray` into setAttribInfoBufferFromArray`\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function setAttribInfoBufferFromArray(gl, attribInfo, array, offset) {\n\t    array = makeTypedArray(array);\n\t    if (offset) {\n\t      gl.bindBuffer(gl.ARRAY_BUFFER, attribInfo.buffer);\n\t      gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);\n\t    } else {\n\t      setBufferFromTypedArray(gl, gl.ARRAY_BUFFER, attribInfo.buffer, array, attribInfo.drawType);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * tries to get the number of elements from a set of arrays.\n\t   */\n\t\n\t  var getNumElementsFromNonIndexedArrays = (function() {\n\t    var positionKeys = ['position', 'positions', 'a_position'];\n\t\n\t    return function getNumElementsFromNonIndexedArrays(arrays) {\n\t      var key;\n\t      for (var ii = 0; ii < positionKeys.length; ++ii) {\n\t        key = positionKeys[ii];\n\t        if (key in arrays) {\n\t          break;\n\t        }\n\t      }\n\t      if (ii === positionKeys.length) {\n\t        key = Object.keys(arrays)[0];\n\t      }\n\t      var array = arrays[key];\n\t      var length = getArray(array).length;\n\t      var numComponents = getNumComponents(array, key);\n\t      var numElements = length / numComponents;\n\t      if (length % numComponents > 0) {\n\t        throw \"numComponents \" + numComponents + \" not correct for length \" + length;\n\t      }\n\t      return numElements;\n\t    };\n\t  }());\n\t\n\t  /**\n\t   * @typedef {Object} BufferInfo\n\t   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n\t   * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..\n\t   * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.\n\t   * @property {Object.<string, module:twgl.AttribInfo>} [attribs] The attribs approriate to call `setAttributes`\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * @typedef {Object} VertexArrayInfo\n\t   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n\t   * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..\n\t   * @property {WebGLVertexArrayObject> [vertexArrayObject] a vertex array object\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Creates a BufferInfo from an object of arrays.\n\t   *\n\t   * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to\n\t   * {@link module:twgl:drawBufferInfo}.\n\t   *\n\t   * Given an object like\n\t   *\n\t   *     var arrays = {\n\t   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n\t   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n\t   *     };\n\t   *\n\t   *  Creates an BufferInfo like this\n\t   *\n\t   *     bufferInfo = {\n\t   *       numElements: 4,        // or whatever the number of elements is\n\t   *       indices: WebGLBuffer,  // this property will not exist if there are no indices\n\t   *       attribs: {\n\t   *         a_position: { buffer: WebGLBuffer, numComponents: 3, },\n\t   *         a_normal:   { buffer: WebGLBuffer, numComponents: 3, },\n\t   *         a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },\n\t   *       },\n\t   *     };\n\t   *\n\t   *  The properties of arrays can be JavaScript arrays in which case the number of components\n\t   *  will be guessed.\n\t   *\n\t   *     var arrays = {\n\t   *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],\n\t   *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],\n\t   *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],\n\t   *        indices:  [0, 1, 2, 1, 2, 3],\n\t   *     };\n\t   *\n\t   *  They can also by TypedArrays\n\t   *\n\t   *     var arrays = {\n\t   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n\t   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n\t   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n\t   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n\t   *     };\n\t   *\n\t   *  Or augmentedTypedArrays\n\t   *\n\t   *     var positions = createAugmentedTypedArray(3, 4);\n\t   *     var texcoords = createAugmentedTypedArray(2, 4);\n\t   *     var normals   = createAugmentedTypedArray(3, 4);\n\t   *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);\n\t   *\n\t   *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);\n\t   *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);\n\t   *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);\n\t   *     indices.push([0, 1, 2, 1, 2, 3]);\n\t   *\n\t   *     var arrays = {\n\t   *        position: positions,\n\t   *        texcoord: texcoords,\n\t   *        normal:   normals,\n\t   *        indices:  indices,\n\t   *     };\n\t   *\n\t   * For the last example it is equivalent to\n\t   *\n\t   *     var bufferInfo = {\n\t   *       attribs: {\n\t   *         a_position: { numComponents: 3, buffer: gl.createBuffer(), },\n\t   *         a_texcoods: { numComponents: 2, buffer: gl.createBuffer(), },\n\t   *         a_normals: { numComponents: 3, buffer: gl.createBuffer(), },\n\t   *       },\n\t   *       indices: gl.createBuffer(),\n\t   *       numElements: 6,\n\t   *     };\n\t   *\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_position.buffer);\n\t   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_texcoord.buffer);\n\t   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_normal.buffer);\n\t   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);\n\t   *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);\n\t   *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {module:twgl.Arrays} arrays Your data\n\t   * @return {module:twgl.BufferInfo} A BufferInfo\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBufferInfoFromArrays(gl, arrays) {\n\t    var bufferInfo = {\n\t      attribs: createAttribsFromArrays(gl, arrays),\n\t    };\n\t    var indices = arrays.indices;\n\t    if (indices) {\n\t      indices = makeTypedArray(indices, \"indices\");\n\t      bufferInfo.indices = createBufferFromTypedArray(gl, indices, gl.ELEMENT_ARRAY_BUFFER);\n\t      bufferInfo.numElements = indices.length;\n\t      bufferInfo.elementType = typedArrays.getGLTypeForTypedArray(indices);\n\t    } else {\n\t      bufferInfo.numElements = getNumElementsFromNonIndexedArrays(arrays);\n\t    }\n\t\n\t    return bufferInfo;\n\t  }\n\t\n\t  /**\n\t   * Creates a buffer from an array, typed array, or array spec\n\t   *\n\t   * Given something like this\n\t   *\n\t   *     [1, 2, 3],\n\t   *\n\t   * or\n\t   *\n\t   *     new Uint16Array([1,2,3]);\n\t   *\n\t   * or\n\t   *\n\t   *     {\n\t   *        data: [1, 2, 3],\n\t   *        type: Uint8Array,\n\t   *     }\n\t   *\n\t   * returns a WebGLBuffer that constains the given data.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n\t   * @param {module:twgl.ArraySpec} array an array, typed array, or array spec.\n\t   * @param {string} arrayName name of array. Used to guess the type if type can not be dervied other wise.\n\t   * @return {WebGLBuffer} a WebGLBuffer containing the data in array.\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBufferFromArray(gl, array, arrayName) {\n\t    var type = arrayName === \"indices\" ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n\t    var typedArray = makeTypedArray(array, arrayName);\n\t    return createBufferFromTypedArray(gl, typedArray, type);\n\t  }\n\t\n\t  /**\n\t   * Creates buffers from arrays or typed arrays\n\t   *\n\t   * Given something like this\n\t   *\n\t   *     var arrays = {\n\t   *        positions: [1, 2, 3],\n\t   *        normals: [0, 0, 1],\n\t   *     }\n\t   *\n\t   * returns something like\n\t   *\n\t   *     buffers = {\n\t   *       positions: WebGLBuffer,\n\t   *       normals: WebGLBuffer,\n\t   *     }\n\t   *\n\t   * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n\t   * @param {module:twgl.Arrays} arrays\n\t   * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBuffersFromArrays(gl, arrays) {\n\t    var buffers = { };\n\t    Object.keys(arrays).forEach(function(key) {\n\t      buffers[key] = createBufferFromArray(gl, arrays[key], key);\n\t    });\n\t\n\t    return buffers;\n\t  }\n\t\n\t  /**\n\t   * Creates a BufferInfo from an object of arrays.\n\t   *\n\t   * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to\n\t   * {@link module:twgl:drawBufferInfo}.\n\t   *\n\t   * > **IMPORTANT:** Vertex Array Objects are **not** a direct analog for a BufferInfo. Vertex Array Objects\n\t   *   assign buffers to specific attributes at creation time. That means they can only be used with programs\n\t   *   who's attributes use the same attribute locations for the same purposes.\n\t   *\n\t   * > Bind your attribute locations by passing an array of attribute names to {@link module:twgl.createProgramInfo}\n\t   *   or use WebGL 2's GLSL ES 3's `layout(location = <num>)` to make sure locations match.\n\t   *\n\t   * also\n\t   *\n\t   * > **IMPORTANT:** After calling twgl.setBuffersAndAttribute with a BufferInfo that uses a Vertex Array Object\n\t   *   that Vertex Array Object will be bound. That means **ANY MANIPULATION OF ELEMENT_ARRAY_BUFFER or ATTRIBUTES**\n\t   *   will affect the Vertex Array Object state.\n\t   *\n\t   * > Call `gl.bindVertexArray(null)` to get back manipulating the global attributes and ELEMENT_ARRAY_BUFFER.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {module:twgl.ProgramInfo|module:twgl.ProgramInfo[]} programInfo a programInfo or array of programInfos\n\t   *\n\t   *    You need to make sure every attribute that will be used is bound. So for example assume shader 1\n\t   *    uses attributes A, B, C and shader 2 uses attributes A, B, D. If you only pass in the programInfo\n\t   *    for shader 1 then only attributes A, B, and C will have their attributes set because TWGL doesn't\n\t   *    now attribute D's location.\n\t   *\n\t   *    So, you can pass in both shader 1 and shader 2's programInfo\n\t   *\n\t   * @return {module:twgl.VertexArrayInfo} The created VertexArrayInfo\n\t   *\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createVertexArrayInfo(gl, programInfos, bufferInfo) {\n\t    var vao = gl.createVertexArray();\n\t    gl.bindVertexArray(vao);\n\t    if (!programInfos.length) {\n\t      programInfos = [programInfos];\n\t    }\n\t    programInfos.forEach(function(programInfo) {\n\t      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n\t    });\n\t    gl.bindVertexArray(null);\n\t    return {\n\t      numElements: bufferInfo.numElements,\n\t      elementType: bufferInfo.elementType,\n\t      vertexArrayObject: vao,\n\t    };\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"createAttribsFromArrays\": createAttribsFromArrays,\n\t    \"createBuffersFromArrays\": createBuffersFromArrays,\n\t    \"createBufferFromArray\": createBufferFromArray,\n\t    \"createBufferFromTypedArray\": createBufferFromTypedArray,\n\t    \"createBufferInfoFromArrays\": createBufferInfoFromArrays,\n\t    \"setAttribInfoBufferFromArray\": setAttribInfoBufferFromArray,\n\t\n\t    \"createVertexArrayInfo\": createVertexArrayInfo,\n\t\n\t    \"setAttributePrefix\": setAttributePrefix,\n\t\n\t    \"setDefaults_\": setDefaults,\n\t    \"getNumComponents_\": getNumComponents,\n\t    \"getArray_\": getArray,\n\t  };\n\t\n\t});\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/programs',[\n\t    './utils',\n\t  ], function(\n\t    utils) {\n\t  \n\t\n\t  /**\n\t   * Low level shader program related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.programs` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/programs\n\t   */\n\t\n\t  var error = utils.error;\n\t  var warn = utils.warn;\n\t\n\t  var FLOAT                         = 0x1406;\n\t  var FLOAT_VEC2                    = 0x8B50;\n\t  var FLOAT_VEC3                    = 0x8B51;\n\t  var FLOAT_VEC4                    = 0x8B52;\n\t  var INT                           = 0x1404;\n\t  var INT_VEC2                      = 0x8B53;\n\t  var INT_VEC3                      = 0x8B54;\n\t  var INT_VEC4                      = 0x8B55;\n\t  var BOOL                          = 0x8B56;\n\t  var BOOL_VEC2                     = 0x8B57;\n\t  var BOOL_VEC3                     = 0x8B58;\n\t  var BOOL_VEC4                     = 0x8B59;\n\t  var FLOAT_MAT2                    = 0x8B5A;\n\t  var FLOAT_MAT3                    = 0x8B5B;\n\t  var FLOAT_MAT4                    = 0x8B5C;\n\t  var SAMPLER_2D                    = 0x8B5E;\n\t  var SAMPLER_CUBE                  = 0x8B60;\n\t  var SAMPLER_3D                    = 0x8B5F;\n\t  var SAMPLER_2D_SHADOW             = 0x8B62;\n\t  var FLOAT_MAT2x3                  = 0x8B65;\n\t  var FLOAT_MAT2x4                  = 0x8B66;\n\t  var FLOAT_MAT3x2                  = 0x8B67;\n\t  var FLOAT_MAT3x4                  = 0x8B68;\n\t  var FLOAT_MAT4x2                  = 0x8B69;\n\t  var FLOAT_MAT4x3                  = 0x8B6A;\n\t  var SAMPLER_2D_ARRAY              = 0x8DC1;\n\t  var SAMPLER_2D_ARRAY_SHADOW       = 0x8DC4;\n\t  var SAMPLER_CUBE_SHADOW           = 0x8DC5;\n\t  var UNSIGNED_INT                  = 0x1405;\n\t  var UNSIGNED_INT_VEC2             = 0x8DC6;\n\t  var UNSIGNED_INT_VEC3             = 0x8DC7;\n\t  var UNSIGNED_INT_VEC4             = 0x8DC8;\n\t  var INT_SAMPLER_2D                = 0x8DCA;\n\t  var INT_SAMPLER_3D                = 0x8DCB;\n\t  var INT_SAMPLER_CUBE              = 0x8DCC;\n\t  var INT_SAMPLER_2D_ARRAY          = 0x8DCF;\n\t  var UNSIGNED_INT_SAMPLER_2D       = 0x8DD2;\n\t  var UNSIGNED_INT_SAMPLER_3D       = 0x8DD3;\n\t  var UNSIGNED_INT_SAMPLER_CUBE     = 0x8DD4;\n\t  var UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;\n\t\n\t  var TEXTURE_2D                    = 0x0DE1;\n\t  var TEXTURE_CUBE_MAP              = 0x8513;\n\t  var TEXTURE_3D                    = 0x806F;\n\t  var TEXTURE_2D_ARRAY              = 0x8C1A;\n\t\n\t  var typeMap = {};\n\t\n\t  /**\n\t   * Returns the corresponding bind point for a given sampler type\n\t   */\n\t  function getBindPointForSamplerType(gl, type) {\n\t    return typeMap[type].bindPoint;\n\t  }\n\t\n\t  // This kind of sucks! If you could compose functions as in `var fn = gl[name];`\n\t  // this code could be a lot smaller but that is sadly really slow (T_T)\n\t\n\t  function floatSetter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform1f(location, v);\n\t    };\n\t  }\n\t\n\t  function floatArraySetter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform1fv(location, v);\n\t    };\n\t  }\n\t\n\t  function floatVec2Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform2fv(location, v);\n\t    };\n\t  }\n\t\n\t  function floatVec3Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform3fv(location, v);\n\t    };\n\t  }\n\t\n\t  function floatVec4Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform4fv(location, v);\n\t    };\n\t  }\n\t\n\t  function intSetter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform1i(location, v);\n\t    };\n\t  }\n\t\n\t  function intArraySetter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform1iv(location, v);\n\t    };\n\t  }\n\t\n\t  function intVec2Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform2iv(location, v);\n\t    };\n\t  }\n\t\n\t  function intVec3Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform3iv(location, v);\n\t    };\n\t  }\n\t\n\t  function intVec4Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform4iv(location, v);\n\t    };\n\t  }\n\t\n\t  function uintSetter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform1ui(location, v);\n\t    };\n\t  }\n\t\n\t  function uintArraySetter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform1uiv(location, v);\n\t    };\n\t  }\n\t\n\t  function uintVec2Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform2uiv(location, v);\n\t    };\n\t  }\n\t\n\t  function uintVec3Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform3uiv(location, v);\n\t    };\n\t  }\n\t\n\t  function uintVec4Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform4uiv(location, v);\n\t    };\n\t  }\n\t\n\t  function floatMat2Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix2fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat3Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix3fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat4Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix4fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat23Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix2x3fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat32Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix3x2fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat24Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix2x4fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat42Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix4x2fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat34Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix3x4fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat43Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix4x3fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function samplerSetter(gl, type, unit, location) {\n\t    var bindPoint = getBindPointForSamplerType(gl, type);\n\t    return function(texture) {\n\t      gl.uniform1i(location, unit);\n\t      gl.activeTexture(gl.TEXTURE0 + unit);\n\t      gl.bindTexture(bindPoint, texture);\n\t    };\n\t  }\n\t\n\t  function samplerArraySetter(gl, type, unit, location, size) {\n\t    var bindPoint = getBindPointForSamplerType(gl, type);\n\t    var units = new Int32Array(size);\n\t    for (var ii = 0; ii < size; ++ii) {\n\t      units[ii] = unit + ii;\n\t    }\n\t\n\t    return function(textures) {\n\t      gl.uniform1iv(location, units);\n\t      textures.forEach(function(texture, index) {\n\t        gl.activeTexture(gl.TEXTURE0 + units[index]);\n\t        gl.bindTexture(bindPoint, texture);\n\t      });\n\t    };\n\t  }\n\t\n\t  typeMap[FLOAT]                         = { Type: Float32Array, size:  4, setter: floatSetter,      arraySetter: floatArraySetter, };\n\t  typeMap[FLOAT_VEC2]                    = { Type: Float32Array, size:  8, setter: floatVec2Setter,  };\n\t  typeMap[FLOAT_VEC3]                    = { Type: Float32Array, size: 12, setter: floatVec3Setter,  };\n\t  typeMap[FLOAT_VEC4]                    = { Type: Float32Array, size: 16, setter: floatVec4Setter,  };\n\t  typeMap[INT]                           = { Type: Int32Array,   size:  4, setter: intSetter,        arraySetter: intArraySetter, };\n\t  typeMap[INT_VEC2]                      = { Type: Int32Array,   size:  8, setter: intVec2Setter,    };\n\t  typeMap[INT_VEC3]                      = { Type: Int32Array,   size: 12, setter: intVec3Setter,    };\n\t  typeMap[INT_VEC4]                      = { Type: Int32Array,   size: 16, setter: intVec4Setter,    };\n\t  typeMap[UNSIGNED_INT]                  = { Type: Uint32Array,  size:  4, setter: uintSetter,       arraySetter: uintArraySetter, };\n\t  typeMap[UNSIGNED_INT_VEC2]             = { Type: Uint32Array,  size:  8, setter: uintVec2Setter,   };\n\t  typeMap[UNSIGNED_INT_VEC3]             = { Type: Uint32Array,  size: 12, setter: uintVec3Setter,   };\n\t  typeMap[UNSIGNED_INT_VEC4]             = { Type: Uint32Array,  size: 16, setter: uintVec4Setter,   };\n\t  typeMap[BOOL]                          = { Type: Uint32Array,  size:  4, setter: intSetter,        arraySetter: intArraySetter, };\n\t  typeMap[BOOL_VEC2]                     = { Type: Uint32Array,  size:  8, setter: intVec2Setter,    };\n\t  typeMap[BOOL_VEC3]                     = { Type: Uint32Array,  size: 12, setter: intVec3Setter,    };\n\t  typeMap[BOOL_VEC4]                     = { Type: Uint32Array,  size: 16, setter: intVec4Setter,    };\n\t  typeMap[FLOAT_MAT2]                    = { Type: Float32Array, size: 16, setter: floatMat2Setter,  };\n\t  typeMap[FLOAT_MAT3]                    = { Type: Float32Array, size: 36, setter: floatMat3Setter,  };\n\t  typeMap[FLOAT_MAT4]                    = { Type: Float32Array, size: 64, setter: floatMat4Setter,  };\n\t  typeMap[FLOAT_MAT2x3]                  = { Type: Float32Array, size: 24, setter: floatMat23Setter, };\n\t  typeMap[FLOAT_MAT2x4]                  = { Type: Float32Array, size: 32, setter: floatMat24Setter, };\n\t  typeMap[FLOAT_MAT3x2]                  = { Type: Float32Array, size: 24, setter: floatMat32Setter, };\n\t  typeMap[FLOAT_MAT3x4]                  = { Type: Float32Array, size: 48, setter: floatMat34Setter, };\n\t  typeMap[FLOAT_MAT4x2]                  = { Type: Float32Array, size: 32, setter: floatMat42Setter, };\n\t  typeMap[FLOAT_MAT4x3]                  = { Type: Float32Array, size: 48, setter: floatMat43Setter, };\n\t  typeMap[SAMPLER_2D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n\t  typeMap[SAMPLER_CUBE]                  = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n\t  typeMap[SAMPLER_3D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };\n\t  typeMap[SAMPLER_2D_SHADOW]             = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n\t  typeMap[SAMPLER_2D_ARRAY]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n\t  typeMap[SAMPLER_2D_ARRAY_SHADOW]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n\t  typeMap[SAMPLER_CUBE_SHADOW]           = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n\t  typeMap[INT_SAMPLER_2D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n\t  typeMap[INT_SAMPLER_3D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };\n\t  typeMap[INT_SAMPLER_CUBE]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n\t  typeMap[INT_SAMPLER_2D_ARRAY]          = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n\t  typeMap[UNSIGNED_INT_SAMPLER_2D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n\t  typeMap[UNSIGNED_INT_SAMPLER_3D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };\n\t  typeMap[UNSIGNED_INT_SAMPLER_CUBE]     = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n\t  typeMap[UNSIGNED_INT_SAMPLER_2D_ARRAY] = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n\t\n\t  var attrTypeMap = {};\n\t  attrTypeMap[FLOAT_MAT2] = { size:  4, count: 2, };\n\t  attrTypeMap[FLOAT_MAT3] = { size:  9, count: 3, };\n\t  attrTypeMap[FLOAT_MAT4] = { size: 16, count: 4, };\n\t\n\t  // make sure we don't see a global gl\n\t  var gl = undefined;  // eslint-disable-line\n\t\n\t  /**\n\t   * Error Callback\n\t   * @callback ErrorCallback\n\t   * @param {string} msg error message.\n\t   * @param {number} [lineOffset] amount to add to line number\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  function addLineNumbers(src, lineOffset) {\n\t    lineOffset = lineOffset || 0;\n\t    ++lineOffset;\n\t\n\t    return src.split(\"\\n\").map(function(line, ndx) {\n\t      return (ndx + lineOffset) + \": \" + line;\n\t    }).join(\"\\n\");\n\t  }\n\t\n\t  var spaceRE = /^[ \\t]*\\n/;\n\t\n\t  /**\n\t   * Loads a shader.\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {string} shaderSource The shader source.\n\t   * @param {number} shaderType The type of shader.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors.\n\t   * @return {WebGLShader} The created shader.\n\t   */\n\t  function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\n\t    var errFn = opt_errorCallback || error;\n\t    // Create the shader object\n\t    var shader = gl.createShader(shaderType);\n\t\n\t    // Remove the first end of line because WebGL 2.0 notrequirebecasebrowserifymessesups\n\t    // #version 300 es\n\t    // as the first line. No whitespace allowed before that line\n\t    // so\n\t    //\n\t    // <script>\n\t    // #version 300 es\n\t    // </script>\n\t    //\n\t    // Has one line before it which is invalid according to GLSL ES 3.00\n\t    //\n\t    var lineOffset = 0;\n\t    if (spaceRE.test(shaderSource)) {\n\t      lineOffset = 1;\n\t      shaderSource = shaderSource.replace(spaceRE, '');\n\t    }\n\t\n\t    // Load the shader source\n\t    gl.shaderSource(shader, shaderSource);\n\t\n\t    // Compile the shader\n\t    gl.compileShader(shader);\n\t\n\t    // Check the compile status\n\t    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\t    if (!compiled) {\n\t      // Something went wrong during compilation; get the error\n\t      var lastError = gl.getShaderInfoLog(shader);\n\t      errFn(addLineNumbers(shaderSource, lineOffset) + \"\\n*** Error compiling shader: \" + lastError);\n\t      gl.deleteShader(shader);\n\t      return null;\n\t    }\n\t\n\t    return shader;\n\t  }\n\t\n\t  /**\n\t   * Creates a program, attaches shaders, binds attrib locations, links the\n\t   * program and calls useProgram.\n\t   *\n\t   * NOTE: There are 3 signatures for this function\n\t   *\n\t   *     twgl.createProgram(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLShader[]} shaders The shaders to attach\n\t   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {WebGLProgram?} the created program or null if error.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgram(\n\t      gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {\n\t    if (typeof opt_locations === 'function') {\n\t      opt_errorCallback = opt_locations;\n\t      opt_locations = undefined;\n\t    }\n\t    if (typeof opt_attribs === 'function') {\n\t      opt_errorCallback = opt_attribs;\n\t      opt_attribs = undefined;\n\t    }\n\t    var errFn = opt_errorCallback || error;\n\t    var program = gl.createProgram();\n\t    shaders.forEach(function(shader) {\n\t      gl.attachShader(program, shader);\n\t    });\n\t    if (opt_attribs) {\n\t      opt_attribs.forEach(function(attrib,  ndx) {\n\t        gl.bindAttribLocation(\n\t            program,\n\t            opt_locations ? opt_locations[ndx] : ndx,\n\t            attrib);\n\t      });\n\t    }\n\t    gl.linkProgram(program);\n\t\n\t    // Check the link status\n\t    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\t    if (!linked) {\n\t        // something went wrong with the link\n\t        var lastError = gl.getProgramInfoLog(program);\n\t        errFn(\"Error in program linking:\" + lastError);\n\t\n\t        gl.deleteProgram(program);\n\t        return null;\n\t    }\n\t    return program;\n\t  }\n\t\n\t  /**\n\t   * Loads a shader from a script tag.\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {string} scriptId The id of the script tag.\n\t   * @param {number} [opt_shaderType] The type of shader. If not passed in it will\n\t   *     be derived from the type of the script tag.\n\t   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors.\n\t   * @return {WebGLShader?} The created shader or null if error.\n\t   */\n\t  function createShaderFromScript(\n\t      gl, scriptId, opt_shaderType, opt_errorCallback) {\n\t    var shaderSource = \"\";\n\t    var shaderType;\n\t    var shaderScript = document.getElementById(scriptId);\n\t    if (!shaderScript) {\n\t      throw \"*** Error: unknown script element\" + scriptId;\n\t    }\n\t    shaderSource = shaderScript.text;\n\t\n\t    if (!opt_shaderType) {\n\t      if (shaderScript.type === \"x-shader/x-vertex\") {\n\t        shaderType = gl.VERTEX_SHADER;\n\t      } else if (shaderScript.type === \"x-shader/x-fragment\") {\n\t        shaderType = gl.FRAGMENT_SHADER;\n\t      } else if (shaderType !== gl.VERTEX_SHADER && shaderType !== gl.FRAGMENT_SHADER) {\n\t        throw \"*** Error: unknown shader type\";\n\t      }\n\t    }\n\t\n\t    return loadShader(\n\t        gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,\n\t        opt_errorCallback);\n\t  }\n\t\n\t  var defaultShaderType = [\n\t    \"VERTEX_SHADER\",\n\t    \"FRAGMENT_SHADER\",\n\t  ];\n\t\n\t  /**\n\t   * Creates a program from 2 script tags.\n\t   *\n\t   * NOTE: There are 3 signatures for this function\n\t   *\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {string[]} shaderScriptIds Array of ids of the script\n\t   *        tags for the shaders. The first is assumed to be the\n\t   *        vertex shader, the second the fragment shader.\n\t   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {WebGLProgram} The created program.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramFromScripts(\n\t      gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {\n\t    var shaders = [];\n\t    for (var ii = 0; ii < shaderScriptIds.length; ++ii) {\n\t      var shader = createShaderFromScript(\n\t          gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], opt_errorCallback);\n\t      if (!shader) {\n\t        return null;\n\t      }\n\t      shaders.push(shader);\n\t    }\n\t    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n\t  }\n\t\n\t  /**\n\t   * Creates a program from 2 sources.\n\t   *\n\t   * NOTE: There are 3 signatures for this function\n\t   *\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {string[]} shaderSourcess Array of sources for the\n\t   *        shaders. The first is assumed to be the vertex shader,\n\t   *        the second the fragment shader.\n\t   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {WebGLProgram} The created program.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramFromSources(\n\t      gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n\t    var shaders = [];\n\t    for (var ii = 0; ii < shaderSources.length; ++ii) {\n\t      var shader = loadShader(\n\t          gl, shaderSources[ii], gl[defaultShaderType[ii]], opt_errorCallback);\n\t      if (!shader) {\n\t        return null;\n\t      }\n\t      shaders.push(shader);\n\t    }\n\t    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n\t  }\n\t\n\t  /**\n\t   * Creates setter functions for all uniforms of a shader\n\t   * program.\n\t   *\n\t   * @see {@link module:twgl.setUniforms}\n\t   *\n\t   * @param {WebGLProgram} program the program to create setters for.\n\t   * @returns {Object.<string, function>} an object with a setter by name for each uniform\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformSetters(gl, program) {\n\t    var textureUnit = 0;\n\t\n\t    /**\n\t     * Creates a setter for a uniform of the given program with it's\n\t     * location embedded in the setter.\n\t     * @param {WebGLProgram} program\n\t     * @param {WebGLUniformInfo} uniformInfo\n\t     * @returns {function} the created setter.\n\t     */\n\t    function createUniformSetter(program, uniformInfo) {\n\t      var location = gl.getUniformLocation(program, uniformInfo.name);\n\t      var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === \"[0]\");\n\t      var type = uniformInfo.type;\n\t      var typeInfo = typeMap[type];\n\t      if (!typeInfo) {\n\t        throw (\"unknown type: 0x\" + type.toString(16)); // we should never get here.\n\t      }\n\t      if (typeInfo.bindPoint) {\n\t        // it's a sampler\n\t        var unit = textureUnit;\n\t        textureUnit += uniformInfo.size;\n\t\n\t        if (isArray) {\n\t          return typeInfo.arraySetter(gl, type, unit, location, uniformInfo.size);\n\t        } else {\n\t          return typeInfo.setter(gl, type, unit, location, uniformInfo.size);\n\t        }\n\t      } else {\n\t        if (typeInfo.arraySetter && isArray) {\n\t          return typeInfo.arraySetter(gl, location);\n\t        } else {\n\t          return typeInfo.setter(gl, location);\n\t        }\n\t      }\n\t    }\n\t\n\t    var uniformSetters = { };\n\t    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\t\n\t    for (var ii = 0; ii < numUniforms; ++ii) {\n\t      var uniformInfo = gl.getActiveUniform(program, ii);\n\t      if (!uniformInfo) {\n\t        break;\n\t      }\n\t      var name = uniformInfo.name;\n\t      // remove the array suffix.\n\t      if (name.substr(-3) === \"[0]\") {\n\t        name = name.substr(0, name.length - 3);\n\t      }\n\t      var setter = createUniformSetter(program, uniformInfo);\n\t      uniformSetters[name] = setter;\n\t    }\n\t    return uniformSetters;\n\t  }\n\t\n\t  /**\n\t   * @typedef {Object} UniformData\n\t   * @property {number} type The WebGL type enum for this uniform\n\t   * @property {number} size The number of elements for this uniform\n\t   * @property {number} blockNdx The block index this uniform appears in\n\t   * @property {number} offset The byte offset in the block for this uniform's value\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * The specification for one UniformBlockObject\n\t   *\n\t   * @typedef {Object} BlockSpec\n\t   * @property {number} index The index of the block.\n\t   * @property {number} size The size in bytes needed for the block\n\t   * @property {number[]} uniformIndices The indices of the uniforms used by the block. These indices\n\t   *    correspond to entries in a UniformData array in the {@link module:twgl.UniformBlockSpec}.\n\t   * @property {bool} usedByVertexShader Self explanitory\n\t   * @property {bool} usedByFragmentShader Self explanitory\n\t   * @property {bool} used Self explanitory\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * A `UniformBlockSpec` represents the data needed to create and bind\n\t   * UniformBlockObjects for a given program\n\t   *\n\t   * @typedef {Object} UniformBlockSpec\n\t   * @property {Object.<string, module:twgl.BlockSpec> blockSpecs The BlockSpec for each block by block name\n\t   * @property {UniformData[]} uniformData An array of data for each uniform by uniform index.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Creates a UniformBlockSpec for the given program.\n\t   *\n\t   * A UniformBlockSpec represents the data needed to create and bind\n\t   * UniformBlockObjects\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL2 Rendering Context\n\t   * @param {WebGLProgram} program A WebGLProgram for a successfully linked program\n\t   * @return {module:twgl.UniformBlockSpec} The created UniformBlockSpec\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformBlockSpecFromProgram(gl, program) {\n\t    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\t    var uniformData = [];\n\t    var uniformIndices = [];\n\t\n\t    for (var ii = 0; ii < numUniforms; ++ii) {\n\t      uniformIndices.push(ii);\n\t      uniformData.push({});\n\t      var uniformInfo = gl.getActiveUniform(program, ii);\n\t      if (!uniformInfo) {\n\t        break;\n\t      }\n\t      // REMOVE [0]?\n\t      uniformData[ii].name = uniformInfo.name;\n\t    }\n\t\n\t    [\n\t      [ \"UNIFORM_TYPE\", \"type\" ],\n\t      [ \"UNIFORM_SIZE\", \"size\" ],  // num elements\n\t      [ \"UNIFORM_BLOCK_INDEX\", \"blockNdx\" ],\n\t      [ \"UNIFORM_OFFSET\", \"offset\", ],\n\t    ].forEach(function(pair) {\n\t      var pname = pair[0];\n\t      var key = pair[1];\n\t      gl.getActiveUniforms(program, uniformIndices, gl[pname]).forEach(function(value, ndx) {\n\t        uniformData[ndx][key] = value;\n\t      });\n\t    });\n\t\n\t    var blockSpecs = {};\n\t\n\t    var numUniformBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n\t    for (ii = 0; ii < numUniformBlocks; ++ii) {\n\t      var name = gl.getActiveUniformBlockName(program, ii);\n\t      var blockSpec = {\n\t        index: ii,\n\t        usedByVertexShader: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),\n\t        usedByFragmentShader: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),\n\t        size: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_DATA_SIZE),\n\t        uniformIndices: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),\n\t      };\n\t      blockSpec.used = blockSpec.usedByVertexSahder || blockSpec.usedByFragmentShader;\n\t      blockSpecs[name] = blockSpec;\n\t    }\n\t\n\t    return {\n\t      blockSpecs: blockSpecs,\n\t      uniformData: uniformData,\n\t    };\n\t  }\n\t\n\t  var arraySuffixRE = /\\[\\d+\\]\\.$/;  // better way to check?\n\t\n\t  /**\n\t   * Represents a UniformBlockObject including an ArrayBuffer with all the uniform values\n\t   * and a corresponding WebGLBuffer to hold those values on the GPU\n\t   *\n\t   * @typedef {Object} UniformBlockInfo\n\t   * @property {string} name The name of the block\n\t   * @property {ArrayBuffer} array The array buffer that contains the uniform values\n\t   * @property {Float32Array} asFloat A float view on the array buffer. This is useful\n\t   *    inspecting the contents of the buffer in the debugger.\n\t   * @property {WebGLBuffer} buffer A WebGL buffer that will hold a copy of the uniform values for rendering.\n\t   * @property {number} [offset] offset into buffer\n\t   * @property {Object.<string, ArrayBufferView>} uniforms A uniform name to ArrayBufferView map.\n\t   *   each Uniform has a correctly typed `ArrayBufferView` into array at the correct offset\n\t   *   and length of that uniform. So for example a float uniform would have a 1 float `Float32Array`\n\t   *   view. A single mat4 would have a 16 element `Float32Array` view. An ivec2 would have an\n\t   *   `Int32Array` view, etc.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Creates a `UniformBlockInfo` for the specified block\n\t   *\n\t   * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy\n\t   * `UniformBlockInfo` is returned**. This is because when debugging GLSL\n\t   * it is common to comment out large portions of a shader or for example set\n\t   * the final output to a constant. When that happens blocks get optimized out.\n\t   * If this function did not create dummy blocks your code would crash when debugging.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext\n\t   * @param {WebGLProgram} program A WebGLProgram\n\t   * @param {module:twgl.UniformBlockSpec} uinformBlockSpec. A UniformBlockSpec as returned\n\t   *     from {@link module:twgl.createUniformBlockSpecFromProgram}.\n\t   * @param {string} blockName The name of the block.\n\t   * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformBlockInfoFromProgram(gl, program, uniformBlockSpec, blockName) {\n\t    var blockSpecs = uniformBlockSpec.blockSpecs;\n\t    var uniformData = uniformBlockSpec.uniformData;\n\t    var blockSpec = blockSpecs[blockName];\n\t    if (!blockSpec) {\n\t      warn(\"no uniform block object named:\", blockName);\n\t      return {\n\t        name: blockName,\n\t        uniforms: {},\n\t      };\n\t    }\n\t    var array = new ArrayBuffer(blockSpec.size);\n\t    var buffer = gl.createBuffer();\n\t    var uniformBufferIndex = blockSpec.index;\n\t    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);\n\t    gl.uniformBlockBinding(program, blockSpec.index, uniformBufferIndex);\n\t\n\t    var prefix = blockName + \".\";\n\t    if (arraySuffixRE.test(prefix)) {\n\t      prefix = prefix.replace(arraySuffixRE, \".\");\n\t    }\n\t    var uniforms = {};\n\t    blockSpec.uniformIndices.forEach(function(uniformNdx) {\n\t      var data = uniformData[uniformNdx];\n\t      var typeInfo = typeMap[data.type];\n\t      var Type = typeInfo.Type;\n\t      var length = data.size * typeInfo.size;\n\t      var name = data.name;\n\t      if (name.substr(0, prefix.length) === prefix) {\n\t        name = name.substr(prefix.length);\n\t      }\n\t      uniforms[name] = new Type(array, data.offset, length / Type.BYTES_PER_ELEMENT);\n\t    });\n\t    return {\n\t      name: blockName,\n\t      array: array,\n\t      asFloat: new Float32Array(array),  // for debugging\n\t      buffer: buffer,\n\t      uniforms: uniforms,\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a `UniformBlockInfo` for the specified block\n\t   *\n\t   * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy\n\t   * `UniformBlockInfo` is returned**. This is because when debugging GLSL\n\t   * it is common to comment out large portions of a shader or for example set\n\t   * the final output to a constant. When that happens blocks get optimized out.\n\t   * If this function did not create dummy blocks your code would crash when debugging.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext\n\t   * @param {module:twgl.ProgramInfo} programInfo a `ProgramInfo`\n\t   *     as returned from {@link module:twgl.createProgramInfo}\n\t   * @param {string} blockName The name of the block.\n\t   * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformBlockInfo(gl, programInfo, blockName) {\n\t    return createUniformBlockInfoFromProgram(gl, programInfo.program, programInfo.uniformBlockSpec, blockName);\n\t  }\n\t\n\t  /**\n\t   * Binds a unform block to the matching uniform block point.\n\t   * Matches by blocks by name so blocks must have the same name not just the same\n\t   * structure.\n\t   *\n\t   * If you have changed any values and you upload the valus into the corresponding WebGLBuffer\n\t   * call {@link module:twgl.setUniformBlock} instead.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.\n\t   * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`\n\t   *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as\n\t   *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.\n\t   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from\n\t   *     {@link module:twgl.createUniformBlockInfo}.\n\t   * @return {bool} true if buffer was bound. If the programInfo has no block with the same block name\n\t   *     no buffer is bound.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function bindUniformBlock(gl, programInfo, uniformBlockInfo) {\n\t    var uniformBlockSpec = programInfo.uniformBlockSpec || programInfo;\n\t    var blockSpec = uniformBlockSpec.blockSpecs[uniformBlockInfo.name];\n\t    if (blockSpec) {\n\t      var bufferBindIndex = blockSpec.index;\n\t      gl.bindBufferRange(gl.UNIFORM_BUFFER, bufferBindIndex, uniformBlockInfo.buffer, uniformBlockInfo.offset || 0, uniformBlockInfo.array.byteLength);\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  /**\n\t   * Uploads the current uniform values to the corresponding WebGLBuffer\n\t   * and binds that buffer to the program's corresponding bind point for the uniform block object.\n\t   *\n\t   * If you haven't changed any values and you only need to bind the uniform block object\n\t   * call {@link module:twgl.bindUniformBlock} instead.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.\n\t   * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`\n\t   *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as\n\t   *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.\n\t   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from\n\t   *     {@link module:twgl.createUniformBlockInfo}.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setUniformBlock(gl, programInfo, uniformBlockInfo) {\n\t    if (bindUniformBlock(gl, programInfo, uniformBlockInfo)) {\n\t      gl.bufferData(gl.UNIFORM_BUFFER, uniformBlockInfo.array, gl.DYNAMIC_DRAW);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Sets values of a uniform block object\n\t   *\n\t   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo A UniformBlockInfo as returned by {@link module:twgl.createUniformBlockInfo}.\n\t   * @param {Object.<string, ?>} values A uniform name to value map where the value is correct for the given\n\t   *    type of uniform. So for example given a block like\n\t   *\n\t   *       uniform SomeBlock {\n\t   *         float someFloat;\n\t   *         vec2 someVec2;\n\t   *         vec3 someVec3Array[2];\n\t   *         int someInt;\n\t   *       }\n\t   *\n\t   *  You can set the values of the uniform block with\n\t   *\n\t   *       twgl.setBlockUniforms(someBlockInfo, {\n\t   *          someFloat: 12.3,\n\t   *          someVec2: [1, 2],\n\t   *          someVec3Array: [1, 2, 3, 4, 5, 6],\n\t   *          someInt: 5,\n\t   *       }\n\t   *\n\t   *  Arrays can be JavaScript arrays or typed arrays\n\t   *\n\t   *  Any name that doesn't match will be ignored\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setBlockUniforms(uniformBlockInfo, values) {\n\t    var uniforms = uniformBlockInfo.uniforms;\n\t    for (var name in values) {\n\t      var array = uniforms[name];\n\t      if (array) {\n\t        var value = values[name];\n\t        if (value.length) {\n\t          array.set(value);\n\t        } else {\n\t          array[0] = value;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Set uniforms and binds related textures.\n\t   *\n\t   * example:\n\t   *\n\t   *     var programInfo = createProgramInfo(\n\t   *         gl, [\"some-vs\", \"some-fs\"]);\n\t   *\n\t   *     var tex1 = gl.createTexture();\n\t   *     var tex2 = gl.createTexture();\n\t   *\n\t   *     ... assume we setup the textures with data ...\n\t   *\n\t   *     var uniforms = {\n\t   *       u_someSampler: tex1,\n\t   *       u_someOtherSampler: tex2,\n\t   *       u_someColor: [1,0,0,1],\n\t   *       u_somePosition: [0,1,1],\n\t   *       u_someMatrix: [\n\t   *         1,0,0,0,\n\t   *         0,1,0,0,\n\t   *         0,0,1,0,\n\t   *         0,0,0,0,\n\t   *       ],\n\t   *     };\n\t   *\n\t   *     gl.useProgram(program);\n\t   *\n\t   * This will automatically bind the textures AND set the\n\t   * uniforms.\n\t   *\n\t   *     twgl.setUniforms(programInfo, uniforms);\n\t   *\n\t   * For the example above it is equivalent to\n\t   *\n\t   *     var texUnit = 0;\n\t   *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n\t   *     gl.bindTexture(gl.TEXTURE_2D, tex1);\n\t   *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n\t   *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n\t   *     gl.bindTexture(gl.TEXTURE_2D, tex2);\n\t   *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n\t   *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);\n\t   *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);\n\t   *     gl.uniformMatrix4fv(u_someMatrix, false, [\n\t   *         1,0,0,0,\n\t   *         0,1,0,0,\n\t   *         0,0,1,0,\n\t   *         0,0,0,0,\n\t   *       ]);\n\t   *\n\t   * Note it is perfectly reasonable to call `setUniforms` multiple times. For example\n\t   *\n\t   *     var uniforms = {\n\t   *       u_someSampler: tex1,\n\t   *       u_someOtherSampler: tex2,\n\t   *     };\n\t   *\n\t   *     var moreUniforms {\n\t   *       u_someColor: [1,0,0,1],\n\t   *       u_somePosition: [0,1,1],\n\t   *       u_someMatrix: [\n\t   *         1,0,0,0,\n\t   *         0,1,0,0,\n\t   *         0,0,1,0,\n\t   *         0,0,0,0,\n\t   *       ],\n\t   *     };\n\t   *\n\t   *     twgl.setUniforms(programInfo, uniforms);\n\t   *     twgl.setUniforms(programInfo, moreUniforms);\n\t   *\n\t   * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from\n\t   *        `createUniformSetters`.\n\t   * @param {Object.<string, ?>} values an object with values for the\n\t   *        uniforms.\n\t   *   You can pass multiple objects by putting them in an array or by calling with more arguments.For example\n\t   *\n\t   *     var sharedUniforms = {\n\t   *       u_fogNear: 10,\n\t   *       u_projection: ...\n\t   *       ...\n\t   *     };\n\t   *\n\t   *     var localUniforms = {\n\t   *       u_world: ...\n\t   *       u_diffuseColor: ...\n\t   *     };\n\t   *\n\t   *     twgl.setUniforms(programInfo, sharedUniforms, localUniforms);\n\t   *\n\t   *     // is the same as\n\t   *\n\t   *     twgl.setUniforms(programInfo, [sharedUniforms, localUniforms]);\n\t   *\n\t   *     // is the same as\n\t   *\n\t   *     twgl.setUniforms(programInfo, sharedUniforms);\n\t   *     twgl.setUniforms(programInfo, localUniforms};\n\t   *\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setUniforms(setters, values) {  // eslint-disable-line\n\t    var actualSetters = setters.uniformSetters || setters;\n\t    var numArgs = arguments.length;\n\t    for (var andx = 1; andx < numArgs; ++andx) {\n\t      var vals = arguments[andx];\n\t      if (Array.isArray(vals)) {\n\t        var numValues = vals.length;\n\t        for (var ii = 0; ii < numValues; ++ii) {\n\t          setUniforms(actualSetters, vals[ii]);\n\t        }\n\t      } else {\n\t        for (var name in vals) {\n\t          var setter = actualSetters[name];\n\t          if (setter) {\n\t            setter(vals[name]);\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Creates setter functions for all attributes of a shader\n\t   * program. You can pass this to {@link module:twgl.setBuffersAndAttributes} to set all your buffers and attributes.\n\t   *\n\t   * @see {@link module:twgl.setAttributes} for example\n\t   * @param {WebGLProgram} program the program to create setters for.\n\t   * @return {Object.<string, function>} an object with a setter for each attribute by name.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createAttributeSetters(gl, program) {\n\t    var attribSetters = {\n\t    };\n\t\n\t    function createAttribSetter(index) {\n\t      return function(b) {\n\t        gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n\t        gl.enableVertexAttribArray(index);\n\t        gl.vertexAttribPointer(\n\t            index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);\n\t      };\n\t    }\n\t\n\t    function createMatAttribSetter(index, typeInfo) {\n\t      var defaultSize = typeInfo.size;\n\t      var count = typeInfo.count;\n\t\n\t      return function(b) {\n\t        gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n\t        var numComponents = b.size || b.numComponents || defaultSize;\n\t        var size = numComponents / count;\n\t        var type = b.type || gl.FLOAT;\n\t        var typeInfo = typeMap[type];\n\t        var stride = typeInfo.size * numComponents;\n\t        var normalize = b.normalize || false;\n\t        var offset = b.offset || 0;\n\t        var rowOffset = stride / count;\n\t        for (var i = 0; i < count; ++i) {\n\t          gl.enableVertexAttribArray(index + i);\n\t          gl.vertexAttribPointer(\n\t              index + i, size, type, normalize, stride, offset + rowOffset * i);\n\t        }\n\t      };\n\t    }\n\t\n\t    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\t    for (var ii = 0; ii < numAttribs; ++ii) {\n\t      var attribInfo = gl.getActiveAttrib(program, ii);\n\t      if (!attribInfo) {\n\t        break;\n\t      }\n\t      var index = gl.getAttribLocation(program, attribInfo.name);\n\t      var typeInfo = attrTypeMap[attribInfo.type];\n\t      if (typeInfo) {\n\t        attribSetters[attribInfo.name] = createMatAttribSetter(index, typeInfo);\n\t      } else {\n\t        attribSetters[attribInfo.name] = createAttribSetter(index);\n\t      }\n\t    }\n\t\n\t    return attribSetters;\n\t  }\n\t\n\t  /**\n\t   * Sets attributes and binds buffers (deprecated... use {@link module:twgl.setBuffersAndAttributes})\n\t   *\n\t   * Example:\n\t   *\n\t   *     var program = createProgramFromScripts(\n\t   *         gl, [\"some-vs\", \"some-fs\");\n\t   *\n\t   *     var attribSetters = createAttributeSetters(program);\n\t   *\n\t   *     var positionBuffer = gl.createBuffer();\n\t   *     var texcoordBuffer = gl.createBuffer();\n\t   *\n\t   *     var attribs = {\n\t   *       a_position: {buffer: positionBuffer, numComponents: 3},\n\t   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n\t   *     };\n\t   *\n\t   *     gl.useProgram(program);\n\t   *\n\t   * This will automatically bind the buffers AND set the\n\t   * attributes.\n\t   *\n\t   *     setAttributes(attribSetters, attribs);\n\t   *\n\t   * Properties of attribs. For each attrib you can add\n\t   * properties:\n\t   *\n\t   * *   type: the type of data in the buffer. Default = gl.FLOAT\n\t   * *   normalize: whether or not to normalize the data. Default = false\n\t   * *   stride: the stride. Default = 0\n\t   * *   offset: offset into the buffer. Default = 0\n\t   *\n\t   * For example if you had 3 value float positions, 2 value\n\t   * float texcoord and 4 value uint8 colors you'd setup your\n\t   * attribs like this\n\t   *\n\t   *     var attribs = {\n\t   *       a_position: {buffer: positionBuffer, numComponents: 3},\n\t   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n\t   *       a_color: {\n\t   *         buffer: colorBuffer,\n\t   *         numComponents: 4,\n\t   *         type: gl.UNSIGNED_BYTE,\n\t   *         normalize: true,\n\t   *       },\n\t   *     };\n\t   *\n\t   * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters\n\t   * @param {Object.<string, module:twgl.AttribInfo>} buffers AttribInfos mapped by attribute name.\n\t   * @memberOf module:twgl/programs\n\t   * @deprecated use {@link module:twgl.setBuffersAndAttributes}\n\t   */\n\t  function setAttributes(setters, buffers) {\n\t    for (var name in buffers) {\n\t      var setter = setters[name];\n\t      if (setter) {\n\t        setter(buffers[name]);\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate\n\t   *\n\t   * Example:\n\t   *\n\t   *     var programInfo = createProgramInfo(\n\t   *         gl, [\"some-vs\", \"some-fs\");\n\t   *\n\t   *     var arrays = {\n\t   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *     };\n\t   *\n\t   *     var bufferInfo = createBufferInfoFromArrays(gl, arrays);\n\t   *\n\t   *     gl.useProgram(programInfo.program);\n\t   *\n\t   * This will automatically bind the buffers AND set the\n\t   * attributes.\n\t   *\n\t   *     setBuffersAndAttributes(gl, programInfo, bufferInfo);\n\t   *\n\t   * For the example above it is equivilent to\n\t   *\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\t   *     gl.enableVertexAttribArray(a_positionLocation);\n\t   *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n\t   *     gl.enableVertexAttribArray(a_texcoordLocation);\n\t   *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n\t   * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters A `ProgramInfo` as returned from {@link module:twgl.createProgrmaInfo} or Attribute setters as returned from {@link module:twgl.createAttributeSetters}\n\t   * @param {(module:twgl.BufferInfo|module:twgl.vertexArrayInfo)} buffers a `BufferInfo` as returned from {@link module:twgl.createBufferInfoFromArrays}.\n\t   *   or a `VertexArrayInfo` as returned from {@link module:twgl.createVertexArrayInfo}\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setBuffersAndAttributes(gl, programInfo, buffers) {\n\t    if (buffers.vertexArrayObject) {\n\t      gl.bindVertexArray(buffers.vertexArrayObject);\n\t    } else {\n\t      setAttributes(programInfo.attribSetters || programInfo, buffers.attribs);\n\t      if (buffers.indices) {\n\t        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * @typedef {Object} ProgramInfo\n\t   * @property {WebGLProgram} program A shader program\n\t   * @property {Object<string, function>} uniformSetters object of setters as returned from createUniformSetters,\n\t   * @property {Object<string, function>} attribSetters object of setters as returned from createAttribSetters,\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Creates a ProgramInfo from an existing program.\n\t   *\n\t   * A ProgramInfo contains\n\t   *\n\t   *     programInfo = {\n\t   *        program: WebGLProgram,\n\t   *        uniformSetters: object of setters as returned from createUniformSetters,\n\t   *        attribSetters: object of setters as returned from createAttribSetters,\n\t   *     }\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {WebGLProgram} program an existing WebGLProgram.\n\t   * @return {module:twgl.ProgramInfo} The created ProgramInfo.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramInfoFromProgram(gl, program) {\n\t    var uniformSetters = createUniformSetters(gl, program);\n\t    var attribSetters = createAttributeSetters(gl, program);\n\t    var programInfo = {\n\t      program: program,\n\t      uniformSetters: uniformSetters,\n\t      attribSetters: attribSetters,\n\t    };\n\t\n\t    if (utils.isWebGL2(gl)) {\n\t      programInfo.uniformBlockSpec = createUniformBlockSpecFromProgram(gl, program);\n\t    }\n\t\n\t    return programInfo;\n\t  }\n\t\n\t  /**\n\t   * Creates a ProgramInfo from 2 sources.\n\t   *\n\t   * A ProgramInfo contains\n\t   *\n\t   *     programInfo = {\n\t   *        program: WebGLProgram,\n\t   *        uniformSetters: object of setters as returned from createUniformSetters,\n\t   *        attribSetters: object of setters as returned from createAttribSetters,\n\t   *     }\n\t   *\n\t   * NOTE: There are 3 signatures for this function\n\t   *\n\t   *     twgl.createProgramInfo(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {string[]} shaderSourcess Array of sources for the\n\t   *        shaders or ids. The first is assumed to be the vertex shader,\n\t   *        the second the fragment shader.\n\t   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the attributes. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {module:twgl.ProgramInfo?} The created ProgramInfo or null if it failed to link or compile\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramInfo(\n\t      gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n\t    if (typeof opt_locations === 'function') {\n\t      opt_errorCallback = opt_locations;\n\t      opt_locations = undefined;\n\t    }\n\t    if (typeof opt_attribs === 'function') {\n\t      opt_errorCallback = opt_attribs;\n\t      opt_attribs = undefined;\n\t    }\n\t    var errFn = opt_errorCallback || error;\n\t    var good = true;\n\t    shaderSources = shaderSources.map(function(source) {\n\t      // Lets assume if there is no \\n it's an id\n\t      if (source.indexOf(\"\\n\") < 0) {\n\t        var script = document.getElementById(source);\n\t        if (!script) {\n\t          errFn(\"no element with id: \" + source);\n\t          good = false;\n\t        } else {\n\t          source = script.text;\n\t        }\n\t      }\n\t      return source;\n\t    });\n\t    if (!good) {\n\t      return null;\n\t    }\n\t    var program = createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback);\n\t    if (!program) {\n\t      return null;\n\t    }\n\t    return createProgramInfoFromProgram(gl, program);\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"createAttributeSetters\": createAttributeSetters,\n\t\n\t    \"createProgram\": createProgram,\n\t    \"createProgramFromScripts\": createProgramFromScripts,\n\t    \"createProgramFromSources\": createProgramFromSources,\n\t    \"createProgramInfo\": createProgramInfo,\n\t    \"createProgramInfoFromProgram\": createProgramInfoFromProgram,\n\t    \"createUniformSetters\": createUniformSetters,\n\t    \"createUniformBlockSpecFromProgram\": createUniformBlockSpecFromProgram,\n\t    \"createUniformBlockInfoFromProgram\": createUniformBlockInfoFromProgram,\n\t    \"createUniformBlockInfo\": createUniformBlockInfo,\n\t\n\t    \"setAttributes\": setAttributes,\n\t    \"setBuffersAndAttributes\": setBuffersAndAttributes,\n\t    \"setUniforms\": setUniforms,\n\t    \"setUniformBlock\": setUniformBlock,\n\t    \"setBlockUniforms\": setBlockUniforms,\n\t    \"bindUniformBlock\": bindUniformBlock,\n\t  };\n\t\n\t});\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/draw',[\n\t    './programs',\n\t  ], function(\n\t    programs) {\n\t  \n\t\n\t  /**\n\t   * Drawing related functions\n\t   *\n\t   * For backward compatibily they are available at both `twgl.draw` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/draw\n\t   */\n\t\n\t  /**\n\t   * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate\n\t   *\n\t   * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself\n\t   * but calling this means if you switch from indexed data to non-indexed\n\t   * data you don't have to remember to update your draw call.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} bufferInfo A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays} or\n\t   *   a VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}\n\t   * @param {enum} [type] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...). Defaults to `gl.TRIANGLES`\n\t   * @param {number} [count] An optional count. Defaults to bufferInfo.numElements\n\t   * @param {number} [offset] An optional offset. Defaults to 0.\n\t   * @memberOf module:twgl/draw\n\t   */\n\t  function drawBufferInfo(gl, bufferInfo, type, count, offset) {\n\t    type = type === undefined ? gl.TRIANGLES : type;\n\t    var indices = bufferInfo.indices;\n\t    var elementType = bufferInfo.elementType;\n\t    var numElements = count === undefined ? bufferInfo.numElements : count;\n\t    offset = offset === undefined ? 0 : offset;\n\t    if (elementType || indices) {\n\t      gl.drawElements(type, numElements, elementType === undefined ? gl.UNSIGNED_SHORT : bufferInfo.elementType, offset);\n\t    } else {\n\t      gl.drawArrays(type, offset, numElements);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * A DrawObject is useful for putting objects in to an array and passing them to {@link module:twgl.drawObjectList}.\n\t   *\n\t   * You need either a `BufferInfo` or a `VertexArrayInfo`.\n\t   *\n\t   * @typedef {Object} DrawObject\n\t   * @property {boolean} [active] whether or not to draw. Default = `true` (must be `false` to be not true). In otherwords `undefined` = `true`\n\t   * @property {number} [type] type to draw eg. `gl.TRIANGLES`, `gl.LINES`, etc...\n\t   * @property {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}\n\t   * @property {module:twgl.BufferInfo} [bufferInfo] A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays}\n\t   * @property {module:twgl.VertexArrayInfo} [vertexArrayInfo] A VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}\n\t   * @property {Object<string, ?>} uniforms The values for the uniforms.\n\t   *   You can pass multiple objects by putting them in an array. For example\n\t   *\n\t   *     var sharedUniforms = {\n\t   *       u_fogNear: 10,\n\t   *       u_projection: ...\n\t   *       ...\n\t   *     };\n\t   *\n\t   *     var localUniforms = {\n\t   *       u_world: ...\n\t   *       u_diffuseColor: ...\n\t   *     };\n\t   *\n\t   *     var drawObj = {\n\t   *       ...\n\t   *       uniforms: [sharedUniforms, localUniforms],\n\t   *     };\n\t   *\n\t   * @property {number} [offset] the offset to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to 0.\n\t   * @property {number} [count] the count to pass to `gl.drawArrays` or `gl.drawElemnts`. Defaults to bufferInfo.numElements.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Draws a list of objects\n\t   * @param {DrawObject[]} objectsToDraw an array of objects to draw.\n\t   * @memberOf module:twgl/draw\n\t   */\n\t  function drawObjectList(gl, objectsToDraw) {\n\t    var lastUsedProgramInfo = null;\n\t    var lastUsedBufferInfo = null;\n\t\n\t    objectsToDraw.forEach(function(object) {\n\t      if (object.active === false) {\n\t        return;\n\t      }\n\t\n\t      var programInfo = object.programInfo;\n\t      var bufferInfo = object.vertexArrayInfo || object.bufferInfo;\n\t      var bindBuffers = false;\n\t      var type = object.type === undefined ? gl.TRIANGLES : object.type;\n\t\n\t      if (programInfo !== lastUsedProgramInfo) {\n\t        lastUsedProgramInfo = programInfo;\n\t        gl.useProgram(programInfo.program);\n\t\n\t        // We have to rebind buffers when changing programs because we\n\t        // only bind buffers the program uses. So if 2 programs use the same\n\t        // bufferInfo but the 1st one uses only positions the when the\n\t        // we switch to the 2nd one some of the attributes will not be on.\n\t        bindBuffers = true;\n\t      }\n\t\n\t      // Setup all the needed attributes.\n\t      if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {\n\t        if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject && !bufferInfo.vertexArrayObject) {\n\t          gl.bindVertexArray(null);\n\t        }\n\t        lastUsedBufferInfo = bufferInfo;\n\t        programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n\t      }\n\t\n\t      // Set the uniforms.\n\t      programs.setUniforms(programInfo, object.uniforms);\n\t\n\t      // Draw\n\t      drawBufferInfo(gl, bufferInfo, type, object.count, object.offset);\n\t    });\n\t\n\t    if (lastUsedBufferInfo.vertexArrayObject) {\n\t      gl.bindVertexArray(null);\n\t    }\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"drawBufferInfo\": drawBufferInfo,\n\t    \"drawObjectList\": drawObjectList,\n\t  };\n\t\n\t});\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/textures',[\n\t    './typedarrays',\n\t    './utils',\n\t  ], function(\n\t    typedArrays,\n\t    utils) {\n\t  \n\t\n\t  /**\n\t   * Low level texture related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.textures` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/textures\n\t   */\n\t\n\t  // make sure we don't see a global gl\n\t  var gl = undefined;  // eslint-disable-line\n\t  var defaults = {\n\t    textureColor: new Uint8Array([128, 192, 255, 255]),\n\t    textureOptions: {},\n\t    crossOrigin: undefined,\n\t  };\n\t  var isArrayBuffer = typedArrays.isArrayBuffer;\n\t\n\t  /* PixelFormat */\n\t  var ALPHA                          = 0x1906;\n\t  var RGB                            = 0x1907;\n\t  var RGBA                           = 0x1908;\n\t  var LUMINANCE                      = 0x1909;\n\t  var LUMINANCE_ALPHA                = 0x190A;\n\t\n\t  /* TextureWrapMode */\n\t  var REPEAT                         = 0x2901;  // eslint-disable-line\n\t  var MIRRORED_REPEAT                = 0x8370;  // eslint-disable-line\n\t\n\t  /* TextureMagFilter */\n\t  var NEAREST                        = 0x2600;  // eslint-disable-line\n\t\n\t  /* TextureMinFilter */\n\t  var NEAREST_MIPMAP_NEAREST         = 0x2700;  // eslint-disable-line\n\t  var LINEAR_MIPMAP_NEAREST          = 0x2701;  // eslint-disable-line\n\t  var NEAREST_MIPMAP_LINEAR          = 0x2702;  // eslint-disable-line\n\t  var LINEAR_MIPMAP_LINEAR           = 0x2703;  // eslint-disable-line\n\t\n\t  /**\n\t   * Sets the default texture color.\n\t   *\n\t   * The default texture color is used when loading textures from\n\t   * urls. Because the URL will be loaded async we'd like to be\n\t   * able to use the texture immediately. By putting a 1x1 pixel\n\t   * color in the texture we can start using the texture before\n\t   * the URL has loaded.\n\t   *\n\t   * @param {number[]} color Array of 4 values in the range 0 to 1\n\t   * @deprecated see {@link module:twgl.setDefaults}\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setDefaultTextureColor(color) {\n\t    defaults.textureColor = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);\n\t  }\n\t\n\t  function setDefaults(newDefaults) {\n\t    utils.copyExistingProperties(newDefaults, defaults);\n\t    if (newDefaults.textureColor) {\n\t      setDefaultTextureColor(newDefaults.textureColor);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Gets a string for gl enum\n\t   *\n\t   * Note: Several enums are the same. Without more\n\t   * context (which function) it's impossible to always\n\t   * give the correct enum.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {number} value the value of the enum you want to look up.\n\t   */\n\t  var glEnumToString = (function() {\n\t    var enums;\n\t\n\t    function init(gl) {\n\t      if (!enums) {\n\t        enums = {};\n\t        Object.keys(gl).forEach(function(key) {\n\t          if (typeof gl[key] === 'number') {\n\t            enums[gl[key]] = key;\n\t          }\n\t        });\n\t      }\n\t    }\n\t\n\t    return function glEnumToString(gl, value) {\n\t      init();\n\t      return enums[value] || (\"0x\" + value.toString(16));\n\t    };\n\t  }());\n\t\n\t  /**\n\t   * A function to generate the source for a texture.\n\t   * @callback TextureFunc\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} options the texture options\n\t   * @return {*} Returns any of the things documentented for `src` for {@link module:twgl.TextureOptions}.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Texture options passed to most texture functions. Each function will use whatever options\n\t   * are appropriate for its needs. This lets you pass the same options to all functions.\n\t   *\n\t   * @typedef {Object} TextureOptions\n\t   * @property {number} [target] the type of texture `gl.TEXTURE_2D` or `gl.TEXTURE_CUBE_MAP`. Defaults to `gl.TEXTURE_2D`.\n\t   * @property {number} [width] the width of the texture. Only used if src is an array or typed array or null.\n\t   * @property {number} [height] the height of a texture. Only used if src is an array or typed array or null.\n\t   * @property {number} [depth] the depth of a texture. Only used if src is an array or type array or null and target is `TEXTURE_3D` .\n\t   * @property {number} [min] the min filter setting (eg. `gl.LINEAR`). Defaults to `gl.NEAREST_MIPMAP_LINEAR`\n\t   *     or if texture is not a power of 2 on both dimensions then defaults to `gl.LINEAR`.\n\t   * @property {number} [mag] the mag filter setting (eg. `gl.LINEAR`). Defaults to `gl.LINEAR`\n\t   * @property {number} [internalFormat] internal format for texture. Defaults to `gl.RGBA`\n\t   * @property {number} [format] format for texture. Defaults to `gl.RGBA`.\n\t   * @property {number} [type] type for texture. Defaults to `gl.UNSIGNED_BYTE` unless `src` is ArrayBuffer. If `src`\n\t   *     is ArrayBuffer defaults to type that matches ArrayBuffer type.\n\t   * @property {number} [wrap] Texture wrapping for both S and T (and R if TEXTURE_3D). Defaults to `gl.REPEAT` for 2D unless src is WebGL1 and src not npot and `gl.CLAMP_TO_EDGE` for cube\n\t   * @property {number} [wrapS] Texture wrapping for S. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n\t   * @property {number} [wrapT] Texture wrapping for T. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n\t   * @property {number} [wrapR] Texture wrapping for R. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n\t   * @property {number} [minLod] TEXTURE_MIN_LOD setting\n\t   * @property {number} [maxLod] TEXTURE_MAX_LOD setting\n\t   * @property {number} [baseLevel] TEXTURE_BASE_LEVEL setting\n\t   * @property {number} [maxLevel] TEXTURE_MAX_LEVEL setting\n\t   * @property {number} [unpackAlignment] The `gl.UNPACK_ALIGNMENT` used when uploading an array. Defaults to 1.\n\t   * @property {number} [premultiplyAlpha] Whether or not to premultiply alpha. Defaults to whatever the current setting is.\n\t   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n\t   *     the current setting for specific textures.\n\t   * @property {number} [flipY] Whether or not to flip the texture vertically on upload. Defaults to whatever the current setting is.\n\t   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n\t   *     the current setting for specific textures.\n\t   * @property {number} [colorspaceConversion] Whether or not to let the browser do colorspace conversion of the texture on upload. Defaults to whatever the current setting is.\n\t   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n\t   *     the current setting for specific textures.\n\t   * @property {(number[]|ArrayBuffer)} color color used as temporary 1x1 pixel color for textures loaded async when src is a string.\n\t   *    If it's a JavaScript array assumes color is 0 to 1 like most GL colors as in `[1, 0, 0, 1] = red=1, green=0, blue=0, alpha=0`.\n\t   *    Defaults to `[0.5, 0.75, 1, 1]`. See {@link module:twgl.setDefaultTextureColor}. If `false` texture is set. Can be used to re-load a texture\n\t   * @property {boolean} [auto] If not `false` then texture working filtering is set automatically for non-power of 2 images and\n\t   *    mips are generated for power of 2 images.\n\t   * @property {number[]} [cubeFaceOrder] The order that cube faces are pulled out of an img or set of images. The default is\n\t   *\n\t   *     [gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n\t   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n\t   *      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n\t   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n\t   *      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n\t   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]\n\t   *\n\t   * @property {(number[]|ArrayBuffer|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement|string|string[]|module:twgl.TextureFunc)} [src] source for texture\n\t   *\n\t   *    If `string` then it's assumed to be a URL to an image. The image will be downloaded async. A usable\n\t   *    1x1 pixel texture will be returned immediatley. The texture will be updated once the image has downloaded.\n\t   *    If `target` is `gl.TEXTURE_CUBE_MAP` will attempt to divide image into 6 square pieces. 1x6, 6x1, 3x2, 2x3.\n\t   *    The pieces will be uploaded in `cubeFaceOrder`\n\t   *\n\t   *    If `string[]` then it must have 6 entries, one for each face of a cube map. Target must be `gl.TEXTURE_CUBE_MAP`.\n\t   *\n\t   *    If `HTMLElement` then it wil be used immediately to create the contents of the texture. Examples `HTMLImageElement`,\n\t   *    `HTMLCanvasElement`, `HTMLVideoElement`.\n\t   *\n\t   *    If `number[]` or `ArrayBuffer` it's assumed to be data for a texture. If `width` or `height` is\n\t   *    not specified it is guessed as follows. First the number of elements is computed by `src.length / numComponets`\n\t   *    where `numComponents` is derived from `format`. If `target` is `gl.TEXTURE_CUBE_MAP` then `numElements` is divided\n\t   *    by 6. Then\n\t   *\n\t   *    *   If neither `width` nor `height` are specified and `sqrt(numElements)` is an integer then width and height\n\t   *        are set to `sqrt(numElements)`. Otherwise `width = numElements` and `height = 1`.\n\t   *\n\t   *    *   If only one of `width` or `height` is specified then the other equals `numElements / specifiedDimension`.\n\t   *\n\t   * If `number[]` will be converted to `type`.\n\t   *\n\t   * If `src` is a function it will be called with a `WebGLRenderingContext` and these options.\n\t   * Whatever it returns is subject to these rules. So it can return a string url, an `HTMLElement`\n\t   * an array etc...\n\t   *\n\t   * If `src` is undefined then an empty texture will be created of size `width` by `height`.\n\t   *\n\t   * @property {string} [crossOrigin] What to set the crossOrigin property of images when they are downloaded.\n\t   *    default: undefined. Also see {@link module:twgl.setDefaults}.\n\t   *\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  // NOTE: While querying GL is considered slow it's not remotely as slow\n\t  // as uploading a texture. On top of that you're unlikely to call this in\n\t  // a perf critical loop. Even if upload a texture every frame that's unlikely\n\t  // to be more than 1 or 2 textures a frame. In other words, the benefits of\n\t  // making the API easy to use outweigh any supposed perf benefits\n\t  var lastPackState = {};\n\t\n\t  /**\n\t   * Saves any packing state that will be set based on the options.\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   */\n\t  function savePackState(gl, options) {\n\t    if (options.colorspaceConversion !== undefined) {\n\t      lastPackState.colorspaceConversion = gl.getParameter(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL);\n\t      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, options.colorspaceConversion);\n\t    }\n\t    if (options.premultiplyAlpha !== undefined) {\n\t      lastPackState.premultiplyAlpha = gl.getParameter(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL);\n\t      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlpha);\n\t    }\n\t    if (options.flipY !== undefined) {\n\t      lastPackState.flipY = gl.getParameter(gl.UNPACK_FLIP_Y_WEBGL);\n\t      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, options.flipY);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Restores any packing state that was set based on the options.\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   */\n\t  function restorePackState(gl, options) {\n\t    if (options.colorspaceConversion !== undefined) {\n\t      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, lastPackState.colorspaceConversion);\n\t    }\n\t    if (options.premultiplyAlpha !== undefined) {\n\t      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, lastPackState.premultiplyAlpha);\n\t    }\n\t    if (options.flipY !== undefined) {\n\t      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, lastPackState.flipY);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Sets the texture parameters of a texture.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureParameters(gl, tex, options) {\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    if (options.min) {\n\t      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, options.min);\n\t    }\n\t    if (options.mag) {\n\t      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, options.mag);\n\t    }\n\t    if (options.wrap) {\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_S, options.wrap);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_T, options.wrap);\n\t      if (target === gl.TEXTURE_3D) {\n\t        gl.texParameteri(target, gl.TEXTURE_WRAP_R, options.wrap);\n\t      }\n\t    }\n\t    if (options.wrapR) {\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_R, options.wrapR);\n\t    }\n\t    if (options.wrapS) {\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_S, options.wrapS);\n\t    }\n\t    if (options.wrapT) {\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_T, options.wrapT);\n\t    }\n\t    if (options.minLod) {\n\t      gl.texParameteri(target, gl.TEXTURE_MIN_LOD, options.minLod);\n\t    }\n\t    if (options.maxLod) {\n\t      gl.texParameteri(target, gl.TEXTURE_MAX_LOD, options.maxLod);\n\t    }\n\t    if (options.baseLevel) {\n\t      gl.texParameteri(target, gl.TEXTURE_BASE_LEVEL, options.baseLevel);\n\t    }\n\t    if (options.maxLevel) {\n\t      gl.texParameteri(target, gl.TEXTURE_MAX_LEVEL, options.maxLevel);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Makes a 1x1 pixel\n\t   * If no color is passed in uses the default color which can be set by calling `setDefaultTextureColor`.\n\t   * @param {(number[]|ArrayBuffer)} [color] The color using 0-1 values\n\t   * @return {Uint8Array} Unit8Array with color.\n\t   */\n\t  function make1Pixel(color) {\n\t    color = color || defaults.textureColor;\n\t    if (isArrayBuffer(color)) {\n\t      return color;\n\t    }\n\t    return new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);\n\t  }\n\t\n\t  /**\n\t   * Returns true if value is power of 2\n\t   * @param {number} value number to check.\n\t   * @return true if value is power of 2\n\t   */\n\t  function isPowerOf2(value) {\n\t    return (value & (value - 1)) === 0;\n\t  }\n\t\n\t  /**\n\t   * Sets filtering or generates mips for texture based on width or height\n\t   * If width or height is not passed in uses `options.width` and//or `options.height`\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @param {number} [width] width of texture\n\t   * @param {number} [height] height of texture\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureFilteringForSize(gl, tex, options, width, height) {\n\t    options = options || defaults.textureOptions;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    width = width || options.width;\n\t    height = height || options.height;\n\t    gl.bindTexture(target, tex);\n\t    if (!isPowerOf2(width) || !isPowerOf2(height)) {\n\t      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t    } else {\n\t      gl.generateMipmap(target);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Gets an array of cubemap face enums\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @return {number[]} cubemap face enums\n\t   */\n\t  function getCubeFaceOrder(gl, options) {\n\t    options = options || {};\n\t    return options.cubeFaceOrder || [\n\t        gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n\t        gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n\t        gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n\t        gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n\t        gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n\t        gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\n\t      ];\n\t  }\n\t\n\t  /**\n\t   * @typedef {Object} FaceInfo\n\t   * @property {number} face gl enum for texImage2D\n\t   * @property {number} ndx face index (0 - 5) into source data\n\t   * @ignore\n\t   */\n\t\n\t  /**\n\t   * Gets an array of FaceInfos\n\t   * There's a bug in some NVidia drivers that will crash the driver if\n\t   * `gl.TEXTURE_CUBE_MAP_POSITIVE_X` is not uploaded first. So, we take\n\t   * the user's desired order from his faces to WebGL and make sure we\n\t   * do the faces in WebGL order\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @return {FaceInfo[]} cubemap face infos. Arguably the `face` property of each element is redundent but\n\t   *    it's needed internally to sort the array of `ndx` properties by `face`.\n\t   */\n\t  function getCubeFacesWithNdx(gl, options) {\n\t    var faces = getCubeFaceOrder(gl, options);\n\t    // work around bug in NVidia drivers. We have to upload the first face first else the driver crashes :(\n\t    var facesWithNdx = faces.map(function(face, ndx) {\n\t      return { face: face, ndx: ndx };\n\t    });\n\t    facesWithNdx.sort(function(a, b) {\n\t      return a.face - b.face;\n\t    });\n\t    return facesWithNdx;\n\t  }\n\t\n\t  /**\n\t   * Set a texture from the contents of an element. Will also set\n\t   * texture filtering or generate mips based on the dimensions of the element\n\t   * unless `options.auto === false`. If `target === gl.TEXTURE_CUBE_MAP` will\n\t   * attempt to slice image into 1x6, 2x3, 3x2, or 6x1 images, one for each face.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {HTMLElement} element a canvas, img, or video element.\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   * @kind function\n\t   */\n\t  var setTextureFromElement = function() {\n\t    var ctx = document.createElement(\"canvas\").getContext(\"2d\");\n\t    return function setTextureFromElement(gl, tex, element, options) {\n\t      options = options || defaults.textureOptions;\n\t      var target = options.target || gl.TEXTURE_2D;\n\t      var width = element.width;\n\t      var height = element.height;\n\t      var format = options.format || gl.RGBA;\n\t      var internalFormat = options.internalFormat || format;\n\t      var type = options.type || gl.UNSIGNED_BYTE;\n\t      savePackState(gl, options);\n\t      gl.bindTexture(target, tex);\n\t      if (target === gl.TEXTURE_CUBE_MAP) {\n\t        // guess the parts\n\t        var imgWidth  = element.width;\n\t        var imgHeight = element.height;\n\t        var size;\n\t        var slices;\n\t        if (imgWidth / 6 === imgHeight) {\n\t          // It's 6x1\n\t          size = imgHeight;\n\t          slices = [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0];\n\t        } else if (imgHeight / 6 === imgWidth) {\n\t          // It's 1x6\n\t          size = imgWidth;\n\t          slices = [0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5];\n\t        } else if (imgWidth / 3 === imgHeight / 2) {\n\t          // It's 3x2\n\t          size = imgWidth / 3;\n\t          slices = [0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1];\n\t        } else if (imgWidth / 2 === imgHeight / 3) {\n\t          // It's 2x3\n\t          size = imgWidth / 2;\n\t          slices = [0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2];\n\t        } else {\n\t          throw \"can't figure out cube map from element: \" + (element.src ? element.src : element.nodeName);\n\t        }\n\t        ctx.canvas.width = size;\n\t        ctx.canvas.height = size;\n\t        width = size;\n\t        height = size;\n\t        getCubeFacesWithNdx(gl, options).forEach(function(f) {\n\t          var xOffset = slices[f.ndx * 2 + 0] * size;\n\t          var yOffset = slices[f.ndx * 2 + 1] * size;\n\t          ctx.drawImage(element, xOffset, yOffset, size, size, 0, 0, size, size);\n\t          gl.texImage2D(f.face, 0, internalFormat, format, type, ctx.canvas);\n\t        });\n\t        // Free up the canvas memory\n\t        ctx.canvas.width = 1;\n\t        ctx.canvas.height = 1;\n\t      } else if (target === gl.TEXTURE_3D) {\n\t        var smallest = Math.min(element.width, element.height);\n\t        var largest = Math.max(element.width, element.height);\n\t        var depth = largest / smallest;\n\t        if (depth % 1 !== 0) {\n\t          throw \"can not compute 3D dimensions of element\";\n\t        }\n\t        var xMult = element.width  === largest ? 1 : 0;\n\t        var yMult = element.height === largest ? 1 : 0;\n\t        gl.texImage3D(target, 0, internalFormat, smallest, smallest, smallest, 0, format, type, null);\n\t        // remove this is texSubImage3D gets width and height arguments\n\t        ctx.canvas.width = smallest;\n\t        ctx.canvas.height = smallest;\n\t        for (var d = 0; d < depth; ++d) {\n\t//          gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, d * smallest);\n\t//          gl.texSubImage3D(target, 0, 0, 0, d, format, type, element);\n\t            var srcX = d * smallest * xMult;\n\t            var srcY = d * smallest * yMult;\n\t            var srcW = smallest;\n\t            var srcH = smallest;\n\t            var dstX = 0;\n\t            var dstY = 0;\n\t            var dstW = smallest;\n\t            var dstH = smallest;\n\t            ctx.drawImage(element, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);\n\t            gl.texSubImage3D(target, 0, 0, 0, d, format, type, ctx.canvas);\n\t        }\n\t        ctx.canvas.width = 0;\n\t        ctx.canvas.height = 0;\n\t// FIX (save state)\n\t//        gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, 0);\n\t      } else {\n\t        gl.texImage2D(target, 0, internalFormat, format, type, element);\n\t      }\n\t      restorePackState(gl, options);\n\t      if (options.auto !== false) {\n\t        setTextureFilteringForSize(gl, tex, options, width, height);\n\t      }\n\t      setTextureParameters(gl, tex, options);\n\t    };\n\t  }();\n\t\n\t  function noop() {\n\t  }\n\t\n\t  /**\n\t   * Loads an image\n\t   * @param {string} url url to image\n\t   * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null\n\t   *     if there was an error\n\t   * @return {HTMLImageElement} the image being loaded.\n\t   */\n\t  function loadImage(url, crossOrigin, callback) {\n\t    callback = callback || noop;\n\t    var img = new Image();\n\t    crossOrigin = crossOrigin !== undefined ? crossOrigin : defaults.crossOrigin;\n\t    if (crossOrigin !== undefined) {\n\t      img.crossOrigin = crossOrigin;\n\t    }\n\t\n\t    function clearEventHandlers() {\n\t      img.removeEventListener('error', onError);  // eslint-disable-line\n\t      img.removeEventListener('load', onLoad);  // eslint-disable-line\n\t      img = null;\n\t    }\n\t\n\t    function onError() {\n\t      var msg = \"couldn't load image: \" + url;\n\t      utils.error(msg);\n\t      callback(msg, img);\n\t      clearEventHandlers();\n\t    }\n\t\n\t    function onLoad() {\n\t      callback(null, img);\n\t      clearEventHandlers();\n\t    }\n\t\n\t    img.addEventListener('error', onError);\n\t    img.addEventListener('load', onLoad);\n\t    img.src = url;\n\t    return img;\n\t  }\n\t\n\t  /**\n\t   * Sets a texture to a 1x1 pixel color. If `options.color === false` is nothing happens. If it's not set\n\t   * the default texture color is used which can be set by calling `setDefaultTextureColor`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureTo1PixelColor(gl, tex, options) {\n\t    options = options || defaults.textureOptions;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    if (options.color === false) {\n\t      return;\n\t    }\n\t    // Assume it's a URL\n\t    // Put 1x1 pixels in texture. That makes it renderable immediately regardless of filtering.\n\t    var color = make1Pixel(options.color);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      for (var ii = 0; ii < 6; ++ii) {\n\t        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n\t      }\n\t    } else if (target === gl.TEXTURE_3D) {\n\t      gl.texImage3D(target, 0, gl.RGBA, 1, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n\t    } else {\n\t      gl.texImage2D(target, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * The src image(s) used to create a texture.\n\t   *\n\t   * When you call {@link module:twgl.createTexture} or {@link module:twgl.createTextures}\n\t   * you can pass in urls for images to load into the textures. If it's a single url\n\t   * then this will be a single HTMLImageElement. If it's an array of urls used for a cubemap\n\t   * this will be a corresponding array of images for the cubemap.\n\t   *\n\t   * @typedef {HTMLImageElement|HTMLImageElement[]} TextureSrc\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * A callback for when an image finished downloading and been uploaded into a texture\n\t   * @callback TextureReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {WebGLTexture} texture the texture.\n\t   * @param {module:twgl.TextureSrc} souce image(s) used to as the src for the texture\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * A callback for when all images have finished downloading and been uploaded into their respective textures\n\t   * @callback TexturesReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {Object.<string, WebGLTexture>} textures the created textures by name. Same as returned by {@link module:twgl.createTextures}.\n\t   * @param {Object.<string, module:twgl.TextureSrc>} sources the image(s) used for the texture by name.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * A callback for when an image finished downloading and been uploaded into a texture\n\t   * @callback CubemapReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {WebGLTexture} tex the texture.\n\t   * @param {HTMLImageElement[]} imgs the images for each face.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Loads a texture from an image from a Url as specified in `options.src`\n\t   * If `options.color !== false` will set the texture to a 1x1 pixel color so that the texture is\n\t   * immediately useable. It will be updated with the contents of the image once the image has finished\n\t   * downloading. Filtering options will be set as approriate for image unless `options.auto === false`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.TextureReadyCallback} [callback] A function to be called when the image has finished loading. err will\n\t   *    be non null if there was an error.\n\t   * @return {HTMLImageElement} the image being downloaded.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function loadTextureFromUrl(gl, tex, options, callback) {\n\t    callback = callback || noop;\n\t    options = options || defaults.textureOptions;\n\t    setTextureTo1PixelColor(gl, tex, options);\n\t    // Because it's async we need to copy the options.\n\t    options = utils.shallowCopy(options);\n\t    var img = loadImage(options.src, options.crossOrigin, function(err, img) {\n\t      if (err) {\n\t        callback(err, tex, img);\n\t      } else {\n\t        setTextureFromElement(gl, tex, img, options);\n\t        callback(null, tex, img);\n\t      }\n\t    });\n\t    return img;\n\t  }\n\t\n\t  /**\n\t   * Loads a cubemap from 6 urls as specified in `options.src`. Will set the cubemap to a 1x1 pixel color\n\t   * so that it is usable immediately unless `option.color === false`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.CubemapReadyCallback} [callback] A function to be called when all the images have finished loading. err will\n\t   *    be non null if there was an error.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function loadCubemapFromUrls(gl, tex, options, callback) {\n\t    callback = callback || noop;\n\t    var urls = options.src;\n\t    if (urls.length !== 6) {\n\t      throw \"there must be 6 urls for a cubemap\";\n\t    }\n\t    var format = options.format || gl.RGBA;\n\t    var type = options.type || gl.UNSIGNED_BYTE;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    if (target !== gl.TEXTURE_CUBE_MAP) {\n\t      throw \"target must be TEXTURE_CUBE_MAP\";\n\t    }\n\t    setTextureTo1PixelColor(gl, tex, options);\n\t    // Because it's async we need to copy the options.\n\t    options = utils.shallowCopy(options);\n\t    var numToLoad = 6;\n\t    var errors = [];\n\t    var imgs;\n\t    var faces = getCubeFaceOrder(gl, options);\n\t\n\t    function uploadImg(faceTarget) {\n\t      return function(err, img) {\n\t        --numToLoad;\n\t        if (err) {\n\t          errors.push(err);\n\t        } else {\n\t          if (img.width !== img.height) {\n\t            errors.push(\"cubemap face img is not a square: \" + img.src);\n\t          } else {\n\t            savePackState(gl, options);\n\t            gl.bindTexture(target, tex);\n\t\n\t            // So assuming this is the first image we now have one face that's img sized\n\t            // and 5 faces that are 1x1 pixel so size the other faces\n\t            if (numToLoad === 5) {\n\t              // use the default order\n\t              getCubeFaceOrder(gl).forEach(function(otherTarget) {\n\t                // Should we re-use the same face or a color?\n\t                gl.texImage2D(otherTarget, 0, format, format, type, img);\n\t              });\n\t            } else {\n\t              gl.texImage2D(faceTarget, 0, format, format, type, img);\n\t            }\n\t\n\t            restorePackState(gl, options);\n\t            gl.generateMipmap(target);\n\t          }\n\t        }\n\t\n\t        if (numToLoad === 0) {\n\t          callback(errors.length ? errors : undefined, imgs, tex);\n\t        }\n\t      };\n\t    }\n\t\n\t    imgs = urls.map(function(url, ndx) {\n\t      return loadImage(url, options.crossOrigin, uploadImg(faces[ndx]));\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Gets the number of compontents for a given image format.\n\t   * @param {number} format the format.\n\t   * @return {number} the number of components for the format.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function getNumComponentsForFormat(format) {\n\t    switch (format) {\n\t      case ALPHA:\n\t      case LUMINANCE:\n\t        return 1;\n\t      case LUMINANCE_ALPHA:\n\t        return 2;\n\t      case RGB:\n\t        return 3;\n\t      case RGBA:\n\t        return 4;\n\t      default:\n\t        throw \"unknown type: \" + format;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Gets the texture type for a given array type.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @return {number} the gl texture type\n\t   */\n\t  function getTextureTypeForArrayType(gl, src) {\n\t    if (isArrayBuffer(src)) {\n\t      return typedArrays.getGLTypeForTypedArray(src);\n\t    }\n\t    return gl.UNSIGNED_BYTE;\n\t  }\n\t\n\t  function guessDimensions(gl, target, width, height, numElements) {\n\t    if (numElements % 1 !== 0) {\n\t      throw \"can't guess dimensions\";\n\t    }\n\t    if (!width && !height) {\n\t      var size = Math.sqrt(numElements / (target === gl.TEXTURE_CUBE_MAP ? 6 : 1));\n\t      if (size % 1 === 0) {\n\t        width = size;\n\t        height = size;\n\t      } else {\n\t        width = numElements;\n\t        height = 1;\n\t      }\n\t    } else if (!height) {\n\t      height = numElements / width;\n\t      if (height % 1) {\n\t        throw \"can't guess dimensions\";\n\t      }\n\t    } else if (!width) {\n\t      width = numElements / height;\n\t      if (width % 1) {\n\t        throw \"can't guess dimensions\";\n\t      }\n\t    }\n\t    return {\n\t      width: width,\n\t      height: height,\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Sets a texture from an array or typed array. If the width or height is not provided will attempt to\n\t   * guess the size. See {@link module:twgl.TextureOptions}.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {(number[]|ArrayBuffer)} src An array or typed arry with texture data.\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureFromArray(gl, tex, src, options) {\n\t    options = options || defaults.textureOptions;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    var width = options.width;\n\t    var height = options.height;\n\t    var depth = options.depth;\n\t    var format = options.format || gl.RGBA;\n\t    var internalFormat = options.internalFormat || format;\n\t    var type = options.type || getTextureTypeForArrayType(gl, src);\n\t    var numComponents = getNumComponentsForFormat(format);\n\t    var numElements = src.length / numComponents;\n\t    if (numElements % 1) {\n\t      throw \"length wrong size for format: \" + glEnumToString(gl, format);\n\t    }\n\t    var dimensions;\n\t    if (target === gl.TEXTURE_3D) {\n\t      if (!width && !height && !depth) {\n\t        var size = Math.cbrt(numElements);\n\t        if (size % 1 !== 0) {\n\t          throw \"can't guess cube size of array of numElements: \" + numElements;\n\t        }\n\t        width = size;\n\t        height = size;\n\t        depth = size;\n\t      } else if (width && (!height || !depth)) {\n\t        dimensions = guessDimensions(gl, target, height, depth, numElements / width);\n\t        height = dimensions.width;\n\t        depth = dimensions.height;\n\t      } else if (height && (!width || !depth)) {\n\t        dimensions = guessDimensions(gl, target, width, depth, numElements / height);\n\t        width = dimensions.width;\n\t        depth = dimensions.height;\n\t      } else {\n\t        dimensions = guessDimensions(gl, target, width, height, numElements / depth);\n\t        width = dimensions.width;\n\t        height = dimensions.height;\n\t      }\n\t    } else {\n\t      dimensions = guessDimensions(gl, target, width, height, numElements);\n\t      width = dimensions.width;\n\t      height = dimensions.height;\n\t    }\n\t    if (!isArrayBuffer(src)) {\n\t      var Type = typedArrays.getTypedArrayTypeForGLType(type);\n\t      src = new Type(src);\n\t    } else {\n\t      if (src instanceof Uint8ClampedArray) {\n\t        src = new Uint8Array(src.buffer);\n\t      }\n\t    }\n\t    gl.pixelStorei(gl.UNPACK_ALIGNMENT, options.unpackAlignment || 1);\n\t    savePackState(gl, options);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      var faceSize = numElements / 6 * numComponents;\n\t      getCubeFacesWithNdx(gl, options).forEach(function(f) {\n\t        var offset = faceSize * f.ndx;\n\t        var data = src.subarray(offset, offset + faceSize);\n\t        gl.texImage2D(f.face, 0, internalFormat, width, height, 0, format, type, data);\n\t      });\n\t    } else if (target === gl.TEXTURE_3D) {\n\t      gl.texImage3D(target, 0, internalFormat, width, height, depth, 0, format, type, src);\n\t    } else {\n\t      gl.texImage2D(target, 0, internalFormat, width, height, 0, format, type, src);\n\t    }\n\t    restorePackState(gl, options);\n\t    return {\n\t      width: width,\n\t      height: height,\n\t      depth: depth,\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Sets a texture with no contents of a certain size. In other words calls `gl.texImage2D` with `null`.\n\t   * You must set `options.width` and `options.height`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setEmptyTexture(gl, tex, options) {\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    var format = options.format || gl.RGBA;\n\t    var internalFormat = options.internalFormat || format;\n\t    var type = options.type || gl.UNSIGNED_BYTE;\n\t    savePackState(gl, options);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      for (var ii = 0; ii < 6; ++ii) {\n\t        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, internalFormat, options.width, options.height, 0, format, type, null);\n\t      }\n\t    } else if (target === gl.TEXTURE_3D) {\n\t      gl.texImage3D(target, 0, internalFormat, options.width, options.height, options.depth, 0, format, type, null);\n\t    } else {\n\t      gl.texImage2D(target, 0, internalFormat, options.width, options.height, 0, format, type, null);\n\t    }\n\t    restorePackState(gl, options);\n\t  }\n\t\n\t  /**\n\t   * Creates a texture based on the options passed in.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.TextureReadyCallback} [callback] A callback called when an image has been downloaded and uploaded to the texture.\n\t   * @return {WebGLTexture} the created texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function createTexture(gl, options, callback) {\n\t    callback = callback || noop;\n\t    options = options || defaults.textureOptions;\n\t    var tex = gl.createTexture();\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    var width  = options.width  || 1;\n\t    var height = options.height || 1;\n\t    gl.bindTexture(target, tex);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      // this should have been the default for CUBEMAPS :(\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t    }\n\t    var src = options.src;\n\t    if (src) {\n\t      if (typeof src === \"function\") {\n\t        src = src(gl, options);\n\t      }\n\t      if (typeof (src) === \"string\") {\n\t        loadTextureFromUrl(gl, tex, options, callback);\n\t      } else if (isArrayBuffer(src) ||\n\t                 (Array.isArray(src) && (\n\t                      typeof src[0] === 'number' ||\n\t                      Array.isArray(src[0]) ||\n\t                      isArrayBuffer(src[0]))\n\t                 )\n\t                ) {\n\t        var dimensions = setTextureFromArray(gl, tex, src, options);\n\t        width  = dimensions.width;\n\t        height = dimensions.height;\n\t      } else if (Array.isArray(src) && typeof (src[0]) === 'string') {\n\t        loadCubemapFromUrls(gl, tex, options, callback);\n\t      } else if (src instanceof HTMLElement) {\n\t        setTextureFromElement(gl, tex, src, options);\n\t        width  = src.width;\n\t        height = src.height;\n\t      } else {\n\t        throw \"unsupported src type\";\n\t      }\n\t    } else {\n\t      setEmptyTexture(gl, tex, options);\n\t    }\n\t    if (options.auto !== false) {\n\t      setTextureFilteringForSize(gl, tex, options, width, height);\n\t    }\n\t    setTextureParameters(gl, tex, options);\n\t    return tex;\n\t  }\n\t\n\t  /**\n\t   * Resizes a texture based on the options passed in.\n\t   *\n\t   * Note: This is not a generic resize anything function.\n\t   * It's mostly used by {@link module:twgl.resizeFramebufferInfo}\n\t   * It will use `options.src` if it exists to try to determine a `type`\n\t   * otherwise it will assume `gl.UNSIGNED_BYTE`. No data is provided\n\t   * for the texture. Texture parameters will be set accordingly\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the texture to resize\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {number} [width] the new width. If not passed in will use `options.width`\n\t   * @param {number} [height] the new height. If not passed in will use `options.height`\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function resizeTexture(gl, tex, options, width, height) {\n\t    width = width || options.width;\n\t    height = height || options.height;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    var format = options.format || gl.RGBA;\n\t    var type;\n\t    var src = options.src;\n\t    if (!src) {\n\t      type = options.type || gl.UNSIGNED_BYTE;\n\t    } else if (isArrayBuffer(src) || (Array.isArray(src) && typeof (src[0]) === 'number')) {\n\t      type = options.type || getTextureTypeForArrayType(gl, src);\n\t    } else {\n\t      type = options.type || gl.UNSIGNED_BYTE;\n\t    }\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      for (var ii = 0; ii < 6; ++ii) {\n\t        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, format, width, height, 0, format, type, null);\n\t      }\n\t    } else {\n\t      gl.texImage2D(target, 0, format, width, height, 0, format, type, null);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Check if a src is an async request.\n\t   * if src is a string we're going to download an image\n\t   * if src is an array of strings we're going to download cubemap images\n\t   * @param {*} src The src from a TextureOptions\n\t   * @returns {bool} true if src is async.\n\t   */\n\t  function isAsyncSrc(src) {\n\t    return typeof src === 'string' ||\n\t           (Array.isArray(src) && typeof src[0] === 'string');\n\t  }\n\t\n\t  /**\n\t   * Creates a bunch of textures based on the passed in options.\n\t   *\n\t   * Example:\n\t   *\n\t   *     var textures = twgl.createTextures(gl, {\n\t   *       // a power of 2 image\n\t   *       hftIcon: { src: \"images/hft-icon-16.png\", mag: gl.NEAREST },\n\t   *       // a non-power of 2 image\n\t   *       clover: { src: \"images/clover.jpg\" },\n\t   *       // From a canvas\n\t   *       fromCanvas: { src: ctx.canvas },\n\t   *       // A cubemap from 6 images\n\t   *       yokohama: {\n\t   *         target: gl.TEXTURE_CUBE_MAP,\n\t   *         src: [\n\t   *           'images/yokohama/posx.jpg',\n\t   *           'images/yokohama/negx.jpg',\n\t   *           'images/yokohama/posy.jpg',\n\t   *           'images/yokohama/negy.jpg',\n\t   *           'images/yokohama/posz.jpg',\n\t   *           'images/yokohama/negz.jpg',\n\t   *         ],\n\t   *       },\n\t   *       // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)\n\t   *       goldengate: {\n\t   *         target: gl.TEXTURE_CUBE_MAP,\n\t   *         src: 'images/goldengate.jpg',\n\t   *       },\n\t   *       // A 2x2 pixel texture from a JavaScript array\n\t   *       checker: {\n\t   *         mag: gl.NEAREST,\n\t   *         min: gl.LINEAR,\n\t   *         src: [\n\t   *           255,255,255,255,\n\t   *           192,192,192,255,\n\t   *           192,192,192,255,\n\t   *           255,255,255,255,\n\t   *         ],\n\t   *       },\n\t   *       // a 1x2 pixel texture from a typed array.\n\t   *       stripe: {\n\t   *         mag: gl.NEAREST,\n\t   *         min: gl.LINEAR,\n\t   *         format: gl.LUMINANCE,\n\t   *         src: new Uint8Array([\n\t   *           255,\n\t   *           128,\n\t   *           255,\n\t   *           128,\n\t   *           255,\n\t   *           128,\n\t   *           255,\n\t   *           128,\n\t   *         ]),\n\t   *         width: 1,\n\t   *       },\n\t   *     });\n\t   *\n\t   * Now\n\t   *\n\t   * *   `textures.hftIcon` will be a 2d texture\n\t   * *   `textures.clover` will be a 2d texture\n\t   * *   `textures.fromCanvas` will be a 2d texture\n\t   * *   `textures.yohohama` will be a cubemap texture\n\t   * *   `textures.goldengate` will be a cubemap texture\n\t   * *   `textures.checker` will be a 2d texture\n\t   * *   `textures.stripe` will be a 2d texture\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per texture.\n\t   * @param {module:twgl.TexturesReadyCallback} [callback] A callback called when all textures have been downloaded.\n\t   * @return {Object.<string,WebGLTexture>} the created textures by name\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function createTextures(gl, textureOptions, callback) {\n\t    callback = callback || noop;\n\t    var numDownloading = 0;\n\t    var errors = [];\n\t    var textures = {};\n\t    var images = {};\n\t\n\t    function callCallbackIfReady() {\n\t      if (numDownloading === 0) {\n\t        setTimeout(function() {\n\t          callback(errors.length ? errors : undefined, textures, images);\n\t        }, 0);\n\t      }\n\t    }\n\t\n\t    Object.keys(textureOptions).forEach(function(name) {\n\t      var options = textureOptions[name];\n\t      var onLoadFn;\n\t      if (isAsyncSrc(options.src)) {\n\t        onLoadFn = function(err, tex, img) {\n\t          images[name] = img;\n\t          --numDownloading;\n\t          if (err) {\n\t            errors.push(err);\n\t          }\n\t          callCallbackIfReady();\n\t        };\n\t        ++numDownloading;\n\t      }\n\t      textures[name] = createTexture(gl, options, onLoadFn);\n\t    });\n\t\n\t    // queue the callback if there are no images to download.\n\t    // We do this because if your code is structured to wait for\n\t    // images to download but then you comment out all the async\n\t    // images your code would break.\n\t    callCallbackIfReady();\n\t\n\t    return textures;\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"setDefaults_\": setDefaults,\n\t\n\t    \"createTexture\": createTexture,\n\t    \"setEmptyTexture\": setEmptyTexture,\n\t    \"setTextureFromArray\": setTextureFromArray,\n\t    \"loadTextureFromUrl\": loadTextureFromUrl,\n\t    \"setTextureFromElement\": setTextureFromElement,\n\t    \"setTextureFilteringForSize\": setTextureFilteringForSize,\n\t    \"setTextureParameters\": setTextureParameters,\n\t    \"setDefaultTextureColor\": setDefaultTextureColor,\n\t    \"createTextures\": createTextures,\n\t    \"resizeTexture\": resizeTexture,\n\t    \"getNumComponentsForFormat\": getNumComponentsForFormat,\n\t  };\n\t});\n\t\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/framebuffers',[\n\t    './textures',\n\t    './utils',\n\t  ], function(\n\t    textures,\n\t    utils) {\n\t  \n\t\n\t  /**\n\t   * Framebuffer related functions\n\t   *\n\t   * For backward compatibily they are available at both `twgl.framebuffer` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/framebuffers\n\t   */\n\t\n\t  // make sure we don't see a global gl\n\t  var gl = undefined;  // eslint-disable-line\n\t\n\t  var UNSIGNED_BYTE                  = 0x1401;\n\t\n\t  /* PixelFormat */\n\t  var DEPTH_COMPONENT                = 0x1902;\n\t  var RGBA                           = 0x1908;\n\t\n\t  /* Framebuffer Object. */\n\t  var RGBA4                          = 0x8056;\n\t  var RGB5_A1                        = 0x8057;\n\t  var RGB565                         = 0x8D62;\n\t  var DEPTH_COMPONENT16              = 0x81A5;\n\t  var STENCIL_INDEX                  = 0x1901;\n\t  var STENCIL_INDEX8                 = 0x8D48;\n\t  var DEPTH_STENCIL                  = 0x84F9;\n\t  var COLOR_ATTACHMENT0              = 0x8CE0;\n\t  var DEPTH_ATTACHMENT               = 0x8D00;\n\t  var STENCIL_ATTACHMENT             = 0x8D20;\n\t  var DEPTH_STENCIL_ATTACHMENT       = 0x821A;\n\t\n\t  /* TextureWrapMode */\n\t  var REPEAT                         = 0x2901;  // eslint-disable-line\n\t  var CLAMP_TO_EDGE                  = 0x812F;\n\t  var MIRRORED_REPEAT                = 0x8370;  // eslint-disable-line\n\t\n\t  /* TextureMagFilter */\n\t  var NEAREST                        = 0x2600;  // eslint-disable-line\n\t  var LINEAR                         = 0x2601;\n\t\n\t  /* TextureMinFilter */\n\t  var NEAREST_MIPMAP_NEAREST         = 0x2700;  // eslint-disable-line\n\t  var LINEAR_MIPMAP_NEAREST          = 0x2701;  // eslint-disable-line\n\t  var NEAREST_MIPMAP_LINEAR          = 0x2702;  // eslint-disable-line\n\t  var LINEAR_MIPMAP_LINEAR           = 0x2703;  // eslint-disable-line\n\t\n\t  /**\n\t   * The options for a framebuffer attachment.\n\t   *\n\t   * Note: For a `format` that is a texture include all the texture\n\t   * options from {@link module:twgl.TextureOptions} for example\n\t   * `min`, `mag`, `clamp`, etc... Note that unlike {@link module:twgl.TextureOptions}\n\t   * `auto` defaults to `false` for attachment textures but `min` and `mag` default\n\t   * to `gl.LINEAR` and `wrap` defaults to `CLAMP_TO_EDGE`\n\t   *\n\t   * @typedef {Object} AttachmentOptions\n\t   * @property {number} [attach] The attachment point. Defaults\n\t   *   to `gl.COLOR_ATTACTMENT0 + ndx` unless type is a depth or stencil type\n\t   *   then it's gl.DEPTH_ATTACHMENT or `gl.DEPTH_STENCIL_ATTACHMENT` depending\n\t   *   on the format or attachment type.\n\t   * @property {number} [format] The format. If one of `gl.RGBA4`,\n\t   *   `gl.RGB565`, `gl.RGB5_A1`, `gl.DEPTH_COMPONENT16`,\n\t   *   `gl.STENCIL_INDEX8` or `gl.DEPTH_STENCIL` then will create a\n\t   *   renderbuffer. Otherwise will create a texture. Default = `gl.RGBA`\n\t   * @property {number} [type] The type. Used for texture. Default = `gl.UNSIGNED_BYTE`.\n\t   * @property {number} [target] The texture target for `gl.framebufferTexture2D`.\n\t   *   Defaults to `gl.TEXTURE_2D`. Set to appropriate face for cube maps.\n\t   * @property {number} [level] level for `gl.framebufferTexture2D`. Defaults to 0.\n\t   * @property {WebGLObject} [attachment] An existing renderbuffer or texture.\n\t   *    If provided will attach this Object. This allows you to share\n\t   *    attachemnts across framebuffers.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  var defaultAttachments = [\n\t    { format: RGBA, type: UNSIGNED_BYTE, min: LINEAR, wrap: CLAMP_TO_EDGE, },\n\t    { format: DEPTH_STENCIL, },\n\t  ];\n\t\n\t  var attachmentsByFormat = {};\n\t  attachmentsByFormat[DEPTH_STENCIL] = DEPTH_STENCIL_ATTACHMENT;\n\t  attachmentsByFormat[STENCIL_INDEX] = STENCIL_ATTACHMENT;\n\t  attachmentsByFormat[STENCIL_INDEX8] = STENCIL_ATTACHMENT;\n\t  attachmentsByFormat[DEPTH_COMPONENT] = DEPTH_ATTACHMENT;\n\t  attachmentsByFormat[DEPTH_COMPONENT16] = DEPTH_ATTACHMENT;\n\t\n\t  function getAttachmentPointForFormat(format) {\n\t    return attachmentsByFormat[format];\n\t  }\n\t\n\t  var renderbufferFormats = {};\n\t  renderbufferFormats[RGBA4] = true;\n\t  renderbufferFormats[RGB5_A1] = true;\n\t  renderbufferFormats[RGB565] = true;\n\t  renderbufferFormats[DEPTH_STENCIL] = true;\n\t  renderbufferFormats[DEPTH_COMPONENT16] = true;\n\t  renderbufferFormats[STENCIL_INDEX] = true;\n\t  renderbufferFormats[STENCIL_INDEX8] = true;\n\t\n\t  function isRenderbufferFormat(format) {\n\t    return renderbufferFormats[format];\n\t  }\n\t\n\t  /**\n\t   * @typedef {Object} FramebufferInfo\n\t   * @property {WebGLFramebuffer} framebuffer The WebGLFramebuffer for this framebufferInfo\n\t   * @property {WebGLObject[]} attachments The created attachments in the same order as passed in to {@link module:twgl.createFramebufferInfo}.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Creates a framebuffer and attachments.\n\t   *\n\t   * This returns a {@link module:twgl.FramebufferInfo} because it needs to return the attachments as well as the framebuffer.\n\t   *\n\t   * The simplest usage\n\t   *\n\t   *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer\n\t   *     var fbi = twgl.createFramebuffer(gl);\n\t   *\n\t   * More complex usage\n\t   *\n\t   *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer\n\t   *     var attachments = [\n\t   *       { format: RGB565, mag: NEAREST },\n\t   *       { format: STENCIL_INDEX8 },\n\t   *     ]\n\t   *     var fbi = twgl.createFramebuffer(gl, attachments);\n\t   *\n\t   * Passing in a specific size\n\t   *\n\t   *     var width = 256;\n\t   *     var height = 256;\n\t   *     var fbi = twgl.createFramebuffer(gl, attachments, width, height);\n\t   *\n\t   * **Note!!** It is up to you to check if the framebuffer is renderable by calling `gl.checkFramebufferStatus`.\n\t   * [WebGL only guarantees 3 combinations of attachments work](https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.6).\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.AttachmentOptions[]} [attachments] which attachments to create. If not provided the default is a framebuffer with an\n\t   *    `RGBA`, `UNSIGNED_BYTE` texture `COLOR_ATTACHMENT0` and a `DEPTH_STENCIL` renderbuffer `DEPTH_STENCIL_ATTACHMENT`.\n\t   * @param {number} [width] the width for the attachments. Default = size of drawingBuffer\n\t   * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer\n\t   * @return {module:twgl.FramebufferInfo} the framebuffer and attachments.\n\t   * @memberOf module:twgl/framebuffers\n\t   */\n\t  function createFramebufferInfo(gl, attachments, width, height) {\n\t    var target = gl.FRAMEBUFFER;\n\t    var fb = gl.createFramebuffer();\n\t    gl.bindFramebuffer(target, fb);\n\t    width  = width  || gl.drawingBufferWidth;\n\t    height = height || gl.drawingBufferHeight;\n\t    attachments = attachments || defaultAttachments;\n\t    var colorAttachmentCount = 0;\n\t    var framebufferInfo = {\n\t      framebuffer: fb,\n\t      attachments: [],\n\t      width: width,\n\t      height: height,\n\t    };\n\t    attachments.forEach(function(attachmentOptions) {\n\t      var attachment = attachmentOptions.attachment;\n\t      var format = attachmentOptions.format;\n\t      var attachmentPoint = getAttachmentPointForFormat(format);\n\t      if (!attachmentPoint) {\n\t        attachmentPoint = COLOR_ATTACHMENT0 + colorAttachmentCount++;\n\t      }\n\t      if (!attachment) {\n\t        if (isRenderbufferFormat(format)) {\n\t          attachment = gl.createRenderbuffer();\n\t          gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);\n\t          gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);\n\t        } else {\n\t          var textureOptions = utils.shallowCopy(attachmentOptions);\n\t          textureOptions.width = width;\n\t          textureOptions.height = height;\n\t          if (textureOptions.auto === undefined) {\n\t            textureOptions.auto = false;\n\t            textureOptions.min = textureOptions.min || gl.LINEAR;\n\t            textureOptions.mag = textureOptions.mag || gl.LINEAR;\n\t            textureOptions.wrapS = textureOptions.wrapS || textureOptions.wrap || gl.CLAMP_TO_EDGE;\n\t            textureOptions.wrapT = textureOptions.wrapT || textureOptions.wrap || gl.CLAMP_TO_EDGE;\n\t          }\n\t          attachment = textures.createTexture(gl, textureOptions);\n\t        }\n\t      }\n\t      if (attachment instanceof WebGLRenderbuffer) {\n\t        gl.framebufferRenderbuffer(target, attachmentPoint, gl.RENDERBUFFER, attachment);\n\t      } else if (attachment instanceof WebGLTexture) {\n\t        gl.framebufferTexture2D(\n\t            target,\n\t            attachmentPoint,\n\t            attachmentOptions.texTarget || gl.TEXTURE_2D,\n\t            attachment,\n\t            attachmentOptions.level || 0);\n\t      } else {\n\t        throw \"unknown attachment type\";\n\t      }\n\t      framebufferInfo.attachments.push(attachment);\n\t    });\n\t    return framebufferInfo;\n\t  }\n\t\n\t  /**\n\t   * Resizes the attachments of a framebuffer.\n\t   *\n\t   * You need to pass in the same `attachments` as you passed in {@link module:twgl.createFramebuffer}\n\t   * because TWGL has no idea the format/type of each attachment.\n\t   *\n\t   * The simplest usage\n\t   *\n\t   *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer\n\t   *     var fbi = twgl.createFramebuffer(gl);\n\t   *\n\t   *     ...\n\t   *\n\t   *     function render() {\n\t   *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {\n\t   *         // resize the attachments\n\t   *         twgl.resizeFramebufferInfo(gl, fbi);\n\t   *       }\n\t   *\n\t   * More complex usage\n\t   *\n\t   *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer\n\t   *     var attachments = [\n\t   *       { format: RGB565, mag: NEAREST },\n\t   *       { format: STENCIL_INDEX8 },\n\t   *     ]\n\t   *     var fbi = twgl.createFramebuffer(gl, attachments);\n\t   *\n\t   *     ...\n\t   *\n\t   *     function render() {\n\t   *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {\n\t   *         // resize the attachments to match\n\t   *         twgl.resizeFramebufferInfo(gl, fbi, attachments);\n\t   *       }\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.FramebufferInfo} framebufferInfo a framebufferInfo as returned from {@link module:twgl.createFramebuffer}.\n\t   * @param {module:twgl.AttachmentOptions[]} [attachments] the same attachments options as passed to {@link module:twgl.createFramebuffer}.\n\t   * @param {number} [width] the width for the attachments. Default = size of drawingBuffer\n\t   * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer\n\t   * @memberOf module:twgl/framebuffers\n\t   */\n\t  function resizeFramebufferInfo(gl, framebufferInfo, attachments, width, height) {\n\t    width  = width  || gl.drawingBufferWidth;\n\t    height = height || gl.drawingBufferHeight;\n\t    framebufferInfo.width = width;\n\t    framebufferInfo.height = height;\n\t    attachments = attachments || defaultAttachments;\n\t    attachments.forEach(function(attachmentOptions, ndx) {\n\t      var attachment = framebufferInfo.attachments[ndx];\n\t      var format = attachmentOptions.format;\n\t      if (attachment instanceof WebGLRenderbuffer) {\n\t        gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);\n\t        gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);\n\t      } else if (attachment instanceof WebGLTexture) {\n\t        textures.resizeTexture(gl, attachment, attachmentOptions, width, height);\n\t      } else {\n\t        throw \"unknown attachment type\";\n\t      }\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Binds a framebuffer\n\t   *\n\t   * This function pretty much soley exists because I spent hours\n\t   * trying to figure out why something I wrote wasn't working only\n\t   * to realize I forget to set the viewport dimensions.\n\t   * My hope is this function will fix that.\n\t   *\n\t   * It is effectively the same as\n\t   *\n\t   *     gl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);\n\t   *     gl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.FramebufferInfo} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebuffer}.\n\t   *   If not passed will bind the canvas.\n\t   * @param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.\n\t   * @memberOf module:twgl/framebuffers\n\t   */\n\t\n\t  function bindFramebufferInfo(gl, framebufferInfo, target) {\n\t    target = target || gl.FRAMEBUFFER;\n\t    if (framebufferInfo) {\n\t      gl.bindFramebuffer(target, framebufferInfo.framebuffer);\n\t      gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);\n\t    } else {\n\t      gl.bindFramebuffer(target, null);\n\t      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n\t    }\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"bindFramebufferInfo\": bindFramebufferInfo,\n\t    \"createFramebufferInfo\": createFramebufferInfo,\n\t    \"resizeFramebufferInfo\": resizeFramebufferInfo,\n\t  };\n\t});\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/twgl',[\n\t    './attributes',\n\t    './draw',\n\t    './framebuffers',\n\t    './programs',\n\t    './textures',\n\t    './typedarrays',\n\t    './utils',\n\t  ], function(\n\t    attributes,\n\t    draw,\n\t    framebuffers,\n\t    programs,\n\t    textures,\n\t    typedArrays,\n\t    utils) {\n\t  \n\t\n\t  /**\n\t   * The main TWGL module.\n\t   *\n\t   * For most use cases you shouldn't need anything outside this module.\n\t   * Exceptions between the stuff added to twgl-full (v3, m4, primitives)\n\t   *\n\t   * @module twgl\n\t   * @borrows module:twgl/attributes.setAttribInfoBufferFromArray as setAttribInfoBufferFromArray\n\t   * @borrows module:twgl/attributes.createBufferInfoFromArrays as createBufferInfoFromArrays\n\t   * @borrows module:twgl/attributes.createVertexArrayInfo as createVertexArrayInfo\n\t   * @borrows module:twgl/draw.drawBufferInfo as drawBufferInfo\n\t   * @borrows module:twgl/draw.drawObjectList as drawObjectList\n\t   * @borrows module:twgl/framebuffers.createFramebufferInfo as createFramebufferInfo\n\t   * @borrows module:twgl/framebuffers.resizeFramebufferInfo as resizeFramebufferInfo\n\t   * @borrows module:twgl/framebuffers.bindFramebufferInfo as bindFramebufferInfo\n\t   * @borrows module:twgl/programs.createProgramInfo as createProgramInfo\n\t   * @borrows module:twgl/programs.createUniformBlockInfo as createUniformBlockInfo\n\t   * @borrows module:twgl/programs.bindUniformBlock as bindUniformBlock\n\t   * @borrows module:twgl/programs.setUniformBlock as setUniformBlock\n\t   * @borrows module:twgl/programs.setBlockUniforms as setBlockUniforms\n\t   * @borrows module:twgl/programs.setUniforms as setUniforms\n\t   * @borrows module:twgl/programs.setBuffersAndAttributes as setBuffersAndAttributes\n\t   * @borrows module:twgl/textures.setTextureFromArray as setTextureFromArray\n\t   * @borrows module:twgl/textures.createTexture as createTexture\n\t   * @borrows module:twgl/textures.resizeTexture as resizeTexture\n\t   * @borrows module:twgl/textures.createTextures as createTextures\n\t   */\n\t\n\t  // make sure we don't see a global gl\n\t  var gl = undefined;  // eslint-disable-line\n\t  var defaults = {\n\t    enableVertexArrayObjects: true,\n\t  };\n\t\n\t  /**\n\t   * Various default settings for twgl.\n\t   *\n\t   * Note: You can call this any number of times. Example:\n\t   *\n\t   *     twgl.setDefaults({ textureColor: [1, 0, 0, 1] });\n\t   *     twgl.setDefaults({ attribPrefix: 'a_' });\n\t   *\n\t   * is equivalent to\n\t   *\n\t   *     twgl.setDefaults({\n\t   *       textureColor: [1, 0, 0, 1],\n\t   *       attribPrefix: 'a_',\n\t   *     });\n\t   *\n\t   * @typedef {Object} Defaults\n\t   * @property {string} attribPrefix The prefix to stick on attributes\n\t   *\n\t   *   When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`\n\t   *   as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.\n\t   *\n\t   *   In otherwords I'll create arrays of geometry like this\n\t   *\n\t   *       var arrays = {\n\t   *         position: ...\n\t   *         normal: ...\n\t   *         texcoord: ...\n\t   *       };\n\t   *\n\t   *   But need those mapped to attributes and my attributes start with `a_`.\n\t   *\n\t   *   Default: `\"\"`\n\t   *\n\t   * @property {number[]} textureColor Array of 4 values in the range 0 to 1\n\t   *\n\t   *   The default texture color is used when loading textures from\n\t   *   urls. Because the URL will be loaded async we'd like to be\n\t   *   able to use the texture immediately. By putting a 1x1 pixel\n\t   *   color in the texture we can start using the texture before\n\t   *   the URL has loaded.\n\t   *\n\t   *   Default: `[0.5, 0.75, 1, 1]`\n\t   *\n\t   * @property {string} crossOrigin\n\t   *\n\t   *   If not undefined sets the crossOrigin attribute on images\n\t   *   that twgl creates when downloading images for textures.\n\t   *\n\t   *   Also see {@link module:twgl.TextureOptions}.\n\t   *\n\t   * @property {bool} enableVertexArrayObjects\n\t   *\n\t   *   If true then in WebGL 1.0 will attempt to get the `OES_vertex_array_object` extension.\n\t   *   If successful it will copy create/bind/delete/isVertexArrayOES from the extension to\n\t   *   the WebGLRenderingContext removing the OES at the end which is the standard entry point\n\t   *   for WebGL 2.\n\t   *\n\t   *   Note: According to webglstats.com 90% of devices support `OES_vertex_array_object`.\n\t   *   If you just want to count on support I suggest using [this polyfill](https://github.com/KhronosGroup/WebGL/blob/master/sdk/demos/google/resources/OESVertexArrayObject.js)\n\t   *   or ignoring devices that don't support them.\n\t   *\n\t   *   Default: `true`\n\t   *\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Sets various defaults for twgl.\n\t   *\n\t   * In the interest of terseness which is kind of the point\n\t   * of twgl I've integrated a few of the older functions here\n\t   *\n\t   * @param {module:twgl.Defaults} newDefaults The default settings.\n\t   * @memberOf module:twgl\n\t   */\n\t  function setDefaults(newDefaults) {\n\t    utils.copyExistingProperties(newDefaults, defaults);\n\t    attributes.setDefaults_(newDefaults);  // eslint-disable-line\n\t    textures.setDefaults_(newDefaults);  // eslint-disable-line\n\t  }\n\t\n\t  /**\n\t   * Adds Vertex Array Objects to WebGL 1 GL contexts if available\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   */\n\t  function addVertexArrayObjectSupport(gl) {\n\t    if (!gl || !defaults.enableVertexArrayObjects) {\n\t      return;\n\t    }\n\t    if (utils.isWebGL1(gl)) {\n\t      var ext = gl.getExtension(\"OES_vertex_array_object\");\n\t      if (ext) {\n\t        gl.createVertexArray = function() {\n\t          return ext.createVertexArrayOES();\n\t        };\n\t        gl.deleteVertexArray = function(v) {\n\t          ext.deleteVertexArrayOES(v);\n\t        };\n\t        gl.isVertexArray = function(v) {\n\t          return ext.isVertexArrayOES(v);\n\t        };\n\t        gl.bindVertexArray = function(v) {\n\t          ext.bindVertexArrayOES(v);\n\t        };\n\t        gl.VERTEX_ARRAY_BINDING = ext.VERTEX_ARRAY_BINDING_OES;\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Creates a webgl context.\n\t   * @param {HTMLCanvasElement} canvas The canvas tag to get\n\t   *     context from. If one is not passed in one will be\n\t   *     created.\n\t   * @return {WebGLRenderingContext} The created context.\n\t   */\n\t  function create3DContext(canvas, opt_attribs) {\n\t    var names = [\"webgl\", \"experimental-webgl\"];\n\t    var context = null;\n\t    for (var ii = 0; ii < names.length; ++ii) {\n\t      try {\n\t        context = canvas.getContext(names[ii], opt_attribs);\n\t      } catch(e) {}  // eslint-disable-line\n\t      if (context) {\n\t        break;\n\t      }\n\t    }\n\t    return context;\n\t  }\n\t\n\t  /**\n\t   * Gets a WebGL context.\n\t   * @param {HTMLCanvasElement} canvas a canvas element.\n\t   * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes\n\t   * @memberOf module:twgl\n\t   */\n\t  function getWebGLContext(canvas, opt_attribs) {\n\t    var gl = create3DContext(canvas, opt_attribs);\n\t    addVertexArrayObjectSupport(gl);\n\t    return gl;\n\t  }\n\t\n\t  /**\n\t   * Creates a webgl context.\n\t   *\n\t   * Will return a WebGL2 context if possible.\n\t   *\n\t   * You can check if it's WebGL2 with\n\t   *\n\t   *     twgl.isWebGL2(gl);\n\t   *\n\t   * @param {HTMLCanvasElement} canvas The canvas tag to get\n\t   *     context from. If one is not passed in one will be\n\t   *     created.\n\t   * @return {WebGLRenderingContext} The created context.\n\t   */\n\t  function createContext(canvas, opt_attribs) {\n\t    var names = [\"webgl2\", \"experimental-webgl2\", \"webgl\", \"experimental-webgl\"];\n\t    var context = null;\n\t    for (var ii = 0; ii < names.length; ++ii) {\n\t      try {\n\t        context = canvas.getContext(names[ii], opt_attribs);\n\t      } catch(e) {}  // eslint-disable-line\n\t      if (context) {\n\t        break;\n\t      }\n\t    }\n\t    return context;\n\t  }\n\t\n\t  /**\n\t   * Gets a WebGL context.  Will create a WebGL2 context if possible.\n\t   *\n\t   * You can check if it's WebGL2 with\n\t   *\n\t   *    function isWebGL2(gl) {\n\t   *      return gl.getParameter(gl.VERSION).indexOf(\"WebGL 2.0 \") == 0;\n\t   *    }\n\t   *\n\t   * @param {HTMLCanvasElement} canvas a canvas element.\n\t   * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes\n\t   * @return {WebGLRenderingContext} The created context.\n\t   * @memberOf module:twgl\n\t   */\n\t  function getContext(canvas, opt_attribs) {\n\t    var gl = createContext(canvas, opt_attribs);\n\t    addVertexArrayObjectSupport(gl);\n\t    return gl;\n\t  }\n\t\n\t  /**\n\t   * Resize a canvas to match the size it's displayed.\n\t   * @param {HTMLCanvasElement} canvas The canvas to resize.\n\t   * @param {number} [multiplier] So you can pass in `window.devicePixelRatio` if you want to.\n\t   * @return {boolean} true if the canvas was resized.\n\t   * @memberOf module:twgl\n\t   */\n\t  function resizeCanvasToDisplaySize(canvas, multiplier) {\n\t    multiplier = multiplier || 1;\n\t    multiplier = Math.max(1, multiplier);\n\t    var width  = canvas.clientWidth  * multiplier | 0;\n\t    var height = canvas.clientHeight * multiplier | 0;\n\t    if (canvas.width !== width ||\n\t        canvas.height !== height) {\n\t      canvas.width = width;\n\t      canvas.height = height;\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  var api = {\n\t    \"getContext\": getContext,\n\t    \"getWebGLContext\": getWebGLContext,\n\t    \"isWebGL1\": utils.isWebGL1,\n\t    \"isWebGL2\": utils.isWebGL2,\n\t    \"resizeCanvasToDisplaySize\": resizeCanvasToDisplaySize,\n\t    \"setDefaults\": setDefaults,\n\t  };\n\t\n\t  function notPrivate(name) {\n\t    return name[name.length - 1] !== '_';\n\t  }\n\t\n\t  function copyPublicProperties(src, dst) {\n\t    Object.keys(src).filter(notPrivate).forEach(function(key) {\n\t      dst[key] = src[key];\n\t    });\n\t    return dst;\n\t  }\n\t\n\t  var apis = {\n\t    attributes: attributes,\n\t    draw: draw,\n\t    framebuffers: framebuffers,\n\t    programs: programs,\n\t    textures: textures,\n\t    typedArrays: typedArrays,\n\t  };\n\t  Object.keys(apis).forEach(function(name) {\n\t    var srcApi = apis[name];\n\t    copyPublicProperties(srcApi, api);\n\t    api[name] = copyPublicProperties(srcApi, {});\n\t  });\n\t\n\t  return api;\n\t\n\t});\n\t\n\t\n\tdefine('main', [\n\t    'twgl/twgl',\n\t  ], function(\n\t    twgl\n\t  ) {\n\t    return twgl;\n\t})\n\t\n\tnotrequirebecasebrowserifymessesup(['main'], function(main) {\n\t  return main;\n\t}, undefined, true);   // forceSync = true\n\t\n\t\n\t\n\t\n\t;\n\tdefine(\"build/js/twgl-includer\", function(){});\n\t\n\t    return notrequirebecasebrowserifymessesup('main');\n\t}));\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 20731b1361f1f47115ff","import 'dom4'\nimport noise from './shaders/noise.frag'\nimport frag from './shaders/main.frag'\nimport vert from './shaders/main.vert'\nimport image from './midday.jpg'\nimport {\n  bindFramebufferInfo,\n  getWebGLContext,\n  createProgramInfo,\n  createBufferInfoFromArrays,\n  createTexture,\n  resizeCanvasToDisplaySize,\n  setBuffersAndAttributes,\n  createFramebufferInfo,\n  setUniforms,\n  drawBufferInfo } from 'twgl-base.js'\n\nconst arrays = {\n  position: {numComponents: 2, data: [1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1]}\n}\n\nclass AnimatedBackground {\n  constructor () {\n    let canvas = document.createElement('canvas')\n    document.body.appendChild(canvas)\n    this.pos = [0, 0]\n    this.delta = 0\n    this.subsideScale = 500\n    canvas.addEventListener('mousemove', this.updateMouse)\n    canvas.addEventListener('touchmove', this.updateMouse)\n    this.gl = getWebGLContext(canvas)\n    this.programInfo = createProgramInfo(this.gl, [vert, frag])\n    this.noiseProgramInfo = createProgramInfo(this.gl, [vert, noise])\n    this.bufferInfo = createBufferInfoFromArrays(this.gl, arrays)\n    this.framebufferInfo = createFramebufferInfo(this.gl)\n    this.texture = createTexture(this.gl, {src: image, wrap: this.gl.CLAMP_TO_EDGE}, () => {\n      this.render()\n    })\n  }\n  updateMouse = event => {\n    if (event.touches && event.touches.length > 1) {\n      return\n    }\n    let touches = event.touches\n    if (!touches) {\n      touches = [{ clientX: event.clientX, clientY: event.clientY }]\n    }\n    let pos = [touches[0].clientY / this.gl.canvas.height, touches[0].clientX / this.gl.canvas.width]\n    let delta = this.delta + Math.round(this.subsideScale * (Math.abs(this.pos[0] - pos[0]) + Math.abs(this.pos[1] - pos[1])))\n    if (delta > this.subsideScale) delta = this.delta\n    this.delta = delta\n    this.pos = pos\n  }\n  render = time => {\n    if (this.delta > 0) this.delta -= 1\n    let noiseUniforms = {\n      time,\n      Period: 0.0001,\n      resolution: [this.gl.canvas.width, this.gl.canvas.height]\n    }\n    let uniforms = {\n      Frequency: 1,\n      Amplitude: 1,\n      Intensity: this.delta / this.subsideScale,\n      u_texSampler: this.texture,\n      u_noiseSampler: this.framebufferInfo.attachments[0],\n      resolution: [this.gl.canvas.width, this.gl.canvas.height]\n    }\n    if (document.hasFocus()) {\n      resizeCanvasToDisplaySize(this.gl.canvas)\n      bindFramebufferInfo(this.gl, this.framebufferInfo)\n\n      this.gl.useProgram(this.noiseProgramInfo.program)\n      setBuffersAndAttributes(this.gl, this.noiseProgramInfo, this.bufferInfo)\n      setUniforms(this.noiseProgramInfo, noiseUniforms)\n      drawBufferInfo(this.gl, this.bufferInfo)\n\n      bindFramebufferInfo(this.gl, null)\n      this.gl.useProgram(this.programInfo.program)\n      setBuffersAndAttributes(this.gl, this.programInfo, this.bufferInfo)\n      setUniforms(this.programInfo, uniforms)\n      drawBufferInfo(this.gl, this.bufferInfo)\n    }\n    requestAnimationFrame(this.render)\n  }\n}\n\nnew AnimatedBackground()\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/classCallCheck.js\n// module id = 2\n// module chunks = 0","/*!\nCopyright (C) 2013-2015 by Andrea Giammarchi - @WebReflection\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n(function(window){'use strict';\n  /* jshint loopfunc: true, noempty: false*/\n  // http://www.w3.org/TR/dom/#element\n\n  function createDocumentFragment() {\n    return document.createDocumentFragment();\n  }\n\n  function createElement(nodeName) {\n    return document.createElement(nodeName);\n  }\n\n  function enoughArguments(length, name) {\n    if (!length) throw new Error(\n      'Failed to construct ' +\n        name +\n      ': 1 argument required, but only 0 present.'\n    );\n  }\n\n  function mutationMacro(nodes) {\n    if (nodes.length === 1) {\n      return textNodeIfString(nodes[0]);\n    }\n    for (var\n      fragment = createDocumentFragment(),\n      list = slice.call(nodes),\n      i = 0; i < nodes.length; i++\n    ) {\n      fragment.appendChild(textNodeIfString(list[i]));\n    }\n    return fragment;\n  }\n\n  function textNodeIfString(node) {\n    return typeof node === 'string' ? document.createTextNode(node) : node;\n  }\n\n  for(var\n    head,\n    property,\n    TemporaryPrototype,\n    TemporaryTokenList,\n    wrapVerifyToken,\n    document = window.document,\n    hOP = Object.prototype.hasOwnProperty,\n    defineProperty = Object.defineProperty || function (object, property, descriptor) {\n      if (hOP.call(descriptor, 'value')) {\n        object[property] = descriptor.value;\n      } else {\n        if (hOP.call(descriptor, 'get'))\n          object.__defineGetter__(property, descriptor.get);\n        if (hOP.call(descriptor, 'set'))\n          object.__defineSetter__(property, descriptor.set);\n      }\n      return object;\n    },\n    indexOf = [].indexOf || function indexOf(value){\n      var length = this.length;\n      while(length--) {\n        if (this[length] === value) {\n          break;\n        }\n      }\n      return length;\n    },\n    // http://www.w3.org/TR/domcore/#domtokenlist\n    verifyToken = function (token) {\n      if (!token) {\n        throw 'SyntaxError';\n      } else if (spaces.test(token)) {\n        throw 'InvalidCharacterError';\n      }\n      return token;\n    },\n    DOMTokenList = function (node) {\n      var\n        noClassName = typeof node.className === 'undefined',\n        className = noClassName ?\n          (node.getAttribute('class') || '') : node.className,\n        isSVG = noClassName || typeof className === 'object',\n        value = (isSVG ?\n          (noClassName ? className : className.baseVal) :\n          className\n        ).replace(trim, '')\n      ;\n      if (value.length) {\n        properties.push.apply(\n          this,\n          value.split(spaces)\n        );\n      }\n      this._isSVG = isSVG;\n      this._ = node;\n    },\n    classListDescriptor = {\n      get: function get() {\n        return new DOMTokenList(this);\n      },\n      set: function(){}\n    },\n    uid = 'dom4-tmp-'.concat(Math.random() * +new Date()).replace('.','-'),\n    trim = /^\\s+|\\s+$/g,\n    spaces = /\\s+/,\n    SPACE = '\\x20',\n    CLASS_LIST = 'classList',\n    toggle = function toggle(token, force) {\n      if (this.contains(token)) {\n        if (!force) {\n          // force is not true (either false or omitted)\n          this.remove(token);\n        }\n      } else if(force === undefined || force) {\n        force = true;\n        this.add(token);\n      }\n      return !!force;\n    },\n    DocumentFragmentPrototype = window.DocumentFragment && DocumentFragment.prototype,\n    Node = window.Node,\n    NodePrototype = (Node || Element).prototype,\n    CharacterData = window.CharacterData || Node,\n    CharacterDataPrototype = CharacterData && CharacterData.prototype,\n    DocumentType = window.DocumentType,\n    DocumentTypePrototype = DocumentType && DocumentType.prototype,\n    ElementPrototype = (window.Element || Node || window.HTMLElement).prototype,\n    HTMLSelectElement = window.HTMLSelectElement || createElement('select').constructor,\n    selectRemove = HTMLSelectElement.prototype.remove,\n    ShadowRoot = window.ShadowRoot,\n    SVGElement = window.SVGElement,\n    // normalizes multiple ids as CSS query\n    idSpaceFinder = / /g,\n    idSpaceReplacer = '\\\\ ',\n    createQueryMethod = function (methodName) {\n      var createArray = methodName === 'querySelectorAll';\n      return function (css) {\n        var a, i, id, query, nl, selectors, node = this.parentNode;\n        if (node) {\n          for (\n            id = this.getAttribute('id') || uid,\n            query = id === uid ? id : id.replace(idSpaceFinder, idSpaceReplacer),\n            selectors = css.split(','),\n            i = 0; i < selectors.length; i++\n          ) {\n            selectors[i] = '#' + query + ' ' + selectors[i];\n          }\n          css = selectors.join(',');\n        }\n        if (id === uid) this.setAttribute('id', id);\n        nl = (node || this)[methodName](css);\n        if (id === uid) this.removeAttribute('id');\n        // return a list\n        if (createArray) {\n          i = nl.length;\n          a = new Array(i);\n          while (i--) a[i] = nl[i];\n        }\n        // return node or null\n        else {\n          a = nl;\n        }\n        return a;\n      };\n    },\n    addQueryAndAll = function (where) {\n      if (!('query' in where)) {\n        where.query = ElementPrototype.query;\n      }\n      if (!('queryAll' in where)) {\n        where.queryAll = ElementPrototype.queryAll;\n      }\n    },\n    properties = [\n      'matches', (\n        ElementPrototype.matchesSelector ||\n        ElementPrototype.webkitMatchesSelector ||\n        ElementPrototype.khtmlMatchesSelector ||\n        ElementPrototype.mozMatchesSelector ||\n        ElementPrototype.msMatchesSelector ||\n        ElementPrototype.oMatchesSelector ||\n        function matches(selector) {\n          var parentNode = this.parentNode;\n          return !!parentNode && -1 < indexOf.call(\n            parentNode.querySelectorAll(selector),\n            this\n          );\n        }\n      ),\n      'closest', function closest(selector) {\n        var parentNode = this, matches;\n        while (\n          // document has no .matches\n          (matches = parentNode && parentNode.matches) &&\n          !parentNode.matches(selector)\n        ) {\n          parentNode = parentNode.parentNode;\n        }\n        return matches ? parentNode : null;\n      },\n      'prepend', function prepend() {\n        var firstChild = this.firstChild,\n            node = mutationMacro(arguments);\n        if (firstChild) {\n          this.insertBefore(node, firstChild);\n        } else {\n          this.appendChild(node);\n        }\n      },\n      'append', function append() {\n        this.appendChild(mutationMacro(arguments));\n      },\n      'before', function before() {\n        var parentNode = this.parentNode;\n        if (parentNode) {\n          parentNode.insertBefore(\n            mutationMacro(arguments), this\n          );\n        }\n      },\n      'after', function after() {\n        var parentNode = this.parentNode,\n            nextSibling = this.nextSibling,\n            node = mutationMacro(arguments);\n        if (parentNode) {\n          if (nextSibling) {\n            parentNode.insertBefore(node, nextSibling);\n          } else {\n            parentNode.appendChild(node);\n          }\n        }\n      },\n      // WARNING - DEPRECATED - use .replaceWith() instead\n      'replace', function replace() {\n        this.replaceWith.apply(this, arguments);\n      },\n      'replaceWith', function replaceWith() {\n        var parentNode = this.parentNode;\n        if (parentNode) {\n          parentNode.replaceChild(\n            mutationMacro(arguments),\n            this\n          );\n        }\n      },\n      'remove', function remove() {\n        var parentNode = this.parentNode;\n        if (parentNode) {\n          parentNode.removeChild(this);\n        }\n      },\n      'query', createQueryMethod('querySelector'),\n      'queryAll', createQueryMethod('querySelectorAll')\n    ],\n    slice = properties.slice,\n    i = properties.length; i; i -= 2\n  ) {\n    property = properties[i - 2];\n    if (!(property in ElementPrototype)) {\n      ElementPrototype[property] = properties[i - 1];\n    }\n    if (property === 'remove') {\n      // see https://github.com/WebReflection/dom4/issues/19\n      HTMLSelectElement.prototype[property] = function () {\n        return 0 < arguments.length ?\n          selectRemove.apply(this, arguments) :\n          ElementPrototype.remove.call(this);\n      };\n    }\n    // see https://github.com/WebReflection/dom4/issues/18\n    if (/^(?:before|after|replace|replaceWith|remove)$/.test(property)) {\n      if (CharacterData && !(property in CharacterDataPrototype)) {\n        CharacterDataPrototype[property] = properties[i - 1];\n      }\n      if (DocumentType && !(property in DocumentTypePrototype)) {\n        DocumentTypePrototype[property] = properties[i - 1];\n      }\n    }\n    // see https://github.com/WebReflection/dom4/pull/26\n    if (/^(?:append|prepend)$/.test(property)) {\n      if (DocumentFragmentPrototype) {\n        if (!(property in DocumentFragmentPrototype)) {\n          DocumentFragmentPrototype[property] = properties[i - 1];\n        }\n      } else {\n        try {\n          createDocumentFragment().constructor.prototype[property] = properties[i - 1];\n        } catch(o_O) {}\n      }\n    }\n  }\n\n  // bring query and queryAll to the document too\n  addQueryAndAll(document);\n\n  // brings query and queryAll to fragments as well\n  if (DocumentFragmentPrototype) {\n    addQueryAndAll(DocumentFragmentPrototype);\n  } else {\n    try {\n      addQueryAndAll(createDocumentFragment().constructor.prototype);\n    } catch(o_O) {}\n  }\n\n  // bring query and queryAll to the ShadowRoot too\n  if (ShadowRoot) {\n    addQueryAndAll(ShadowRoot.prototype);\n  }\n\n  // most likely an IE9 only issue\n  // see https://github.com/WebReflection/dom4/issues/6\n  if (!createElement('a').matches('a')) {\n    ElementPrototype[property] = function(matches){\n      return function (selector) {\n        return matches.call(\n          this.parentNode ?\n            this :\n            createDocumentFragment().appendChild(this),\n          selector\n        );\n      };\n    }(ElementPrototype[property]);\n  }\n\n  // used to fix both old webkit and SVG\n  DOMTokenList.prototype = {\n    length: 0,\n    add: function add() {\n      for(var j = 0, token; j < arguments.length; j++) {\n        token = arguments[j];\n        if(!this.contains(token)) {\n          properties.push.call(this, property);\n        }\n      }\n      if (this._isSVG) {\n        this._.setAttribute('class', '' + this);\n      } else {\n        this._.className = '' + this;\n      }\n    },\n    contains: (function(indexOf){\n      return function contains(token) {\n        i = indexOf.call(this, property = verifyToken(token));\n        return -1 < i;\n      };\n    }([].indexOf || function (token) {\n      i = this.length;\n      while(i-- && this[i] !== token){}\n      return i;\n    })),\n    item: function item(i) {\n      return this[i] || null;\n    },\n    remove: function remove() {\n      for(var j = 0, token; j < arguments.length; j++) {\n        token = arguments[j];\n        if(this.contains(token)) {\n          properties.splice.call(this, i, 1);\n        }\n      }\n      if (this._isSVG) {\n        this._.setAttribute('class', '' + this);\n      } else {\n        this._.className = '' + this;\n      }\n    },\n    toggle: toggle,\n    toString: function toString() {\n      return properties.join.call(this, SPACE);\n    }\n  };\n\n  if (SVGElement && !(CLASS_LIST in SVGElement.prototype)) {\n    defineProperty(SVGElement.prototype, CLASS_LIST, classListDescriptor);\n  }\n\n  // http://www.w3.org/TR/dom/#domtokenlist\n  // iOS 5.1 has completely screwed this property\n  // classList in ElementPrototype is false\n  // but it's actually there as getter\n  if (!(CLASS_LIST in document.documentElement)) {\n    defineProperty(ElementPrototype, CLASS_LIST, classListDescriptor);\n  } else {\n    // iOS 5.1 and Nokia ASHA do not support multiple add or remove\n    // trying to detect and fix that in here\n    TemporaryTokenList = createElement('div')[CLASS_LIST];\n    TemporaryTokenList.add('a', 'b', 'a');\n    if ('a\\x20b' != TemporaryTokenList) {\n      // no other way to reach original methods in iOS 5.1\n      TemporaryPrototype = TemporaryTokenList.constructor.prototype;\n      if (!('add' in TemporaryPrototype)) {\n        // ASHA double fails in here\n        TemporaryPrototype = window.TemporaryTokenList.prototype;\n      }\n      wrapVerifyToken = function (original) {\n        return function () {\n          var i = 0;\n          while (i < arguments.length) {\n            original.call(this, arguments[i++]);\n          }\n        };\n      };\n      TemporaryPrototype.add = wrapVerifyToken(TemporaryPrototype.add);\n      TemporaryPrototype.remove = wrapVerifyToken(TemporaryPrototype.remove);\n      // toggle is broken too ^_^ ... let's fix it\n      TemporaryPrototype.toggle = toggle;\n    }\n  }\n\n  if (!('contains' in NodePrototype)) {\n    defineProperty(NodePrototype, 'contains', {\n      value: function (el) {\n        while (el && el !== this) el = el.parentNode;\n        return this === el;\n      }\n    });\n  }\n\n  if (!('head' in document)) {\n    defineProperty(document, 'head', {\n      get: function () {\n        return head || (\n          head = document.getElementsByTagName('head')[0]\n        );\n      }\n    });\n  }\n\n  // requestAnimationFrame partial polyfill\n  (function () {\n    for (var\n      raf,\n      rAF = window.requestAnimationFrame,\n      cAF = window.cancelAnimationFrame,\n      prefixes = ['o', 'ms', 'moz', 'webkit'],\n      i = prefixes.length;\n      !cAF && i--;\n    ) {\n      rAF = rAF || window[prefixes[i] + 'RequestAnimationFrame'];\n      cAF = window[prefixes[i] + 'CancelAnimationFrame'] ||\n            window[prefixes[i] + 'CancelRequestAnimationFrame'];\n    }\n    if (!cAF) {\n      // some FF apparently implemented rAF but no cAF \n      if (rAF) {\n        raf = rAF;\n        rAF = function (callback) {\n          var goOn = true;\n          raf(function () {\n            if (goOn) callback.apply(this, arguments);\n          });\n          return function () {\n            goOn = false;\n          };\n        };\n        cAF = function (id) {\n          id();\n        };\n      } else {\n        rAF = function (callback) {\n          return setTimeout(callback, 15, 15);\n        };\n        cAF = function (id) {\n          clearTimeout(id);\n        };\n      }\n    }\n    window.requestAnimationFrame = rAF;\n    window.cancelAnimationFrame = cAF;\n  }());\n\n  // http://www.w3.org/TR/dom/#customevent\n  try{new window.CustomEvent('?');}catch(o_O){\n    window.CustomEvent = function(\n      eventName,\n      defaultInitDict\n    ){\n\n      // the infamous substitute\n      function CustomEvent(type, eventInitDict) {\n        /*jshint eqnull:true */\n        var event = document.createEvent(eventName);\n        if (typeof type != 'string') {\n          throw new Error('An event name must be provided');\n        }\n        if (eventName == 'Event') {\n          event.initCustomEvent = initCustomEvent;\n        }\n        if (eventInitDict == null) {\n          eventInitDict = defaultInitDict;\n        }\n        event.initCustomEvent(\n          type,\n          eventInitDict.bubbles,\n          eventInitDict.cancelable,\n          eventInitDict.detail\n        );\n        return event;\n      }\n\n      // attached at runtime\n      function initCustomEvent(\n        type, bubbles, cancelable, detail\n      ) {\n        /*jshint validthis:true*/\n        this.initEvent(type, bubbles, cancelable);\n        this.detail = detail;\n      }\n\n      // that's it\n      return CustomEvent;\n    }(\n      // is this IE9 or IE10 ?\n      // where CustomEvent is there\n      // but not usable as construtor ?\n      window.CustomEvent ?\n        // use the CustomEvent interface in such case\n        'CustomEvent' : 'Event',\n        // otherwise the common compatible one\n      {\n        bubbles: false,\n        cancelable: false,\n        detail: null\n      }\n    );\n  }\n\n  // window.Event as constructor\n  try { new Event('_'); } catch (o_O) {\n    /* jshint -W022 */\n    o_O = (function ($Event) {\n      function Event(type, init) {\n        enoughArguments(arguments.length, 'Event');\n        var out = document.createEvent('Event');\n        if (!init) init = {};\n        out.initEvent(\n          type,\n          !!init.bubbles,\n          !!init.cancelable\n        );\n        return out;\n      }\n      Event.prototype = $Event.prototype;\n      return Event;\n    }(window.Event || function Event() {}));\n    defineProperty(window, 'Event', {value: o_O});\n    // Android 4 gotcha\n    if (Event !== o_O) Event = o_O;\n  }\n\n  // window.KeyboardEvent as constructor\n  try { new KeyboardEvent('_', {}); } catch (o_O) {\n    /* jshint -W022 */\n    o_O = (function ($KeyboardEvent) {\n      // code inspired by https://gist.github.com/termi/4654819\n      var\n        initType = 0,\n        defaults = {\n          char: '',\n          key: '',\n          location: 0,\n          ctrlKey: false,\n          shiftKey: false,\n          altKey: false,\n          metaKey: false,\n          altGraphKey: false,\n          repeat: false,\n          locale: navigator.language,\n          detail: 0,\n          bubbles: false,\n          cancelable: false,\n          keyCode: 0,\n          charCode: 0,\n          which: 0\n        },\n        eventType\n      ;\n      try {\n        var e = document.createEvent('KeyboardEvent');\n        e.initKeyboardEvent(\n          'keyup', false, false, window, '+', 3,\n          true, false, true, false, false\n        );\n        initType = (\n          (e.keyIdentifier || e.key) == '+' &&\n          (e.keyLocation || e.location) == 3\n        ) && (\n          e.ctrlKey ? e.altKey ? 1 : 3 : e.shiftKey ? 2 : 4\n        ) || 9;\n      } catch(o_O) {}\n      eventType = 0 < initType ? 'KeyboardEvent' : 'Event';\n\n      function getModifier(init) {\n        for (var\n          out = [],\n          keys = [\n            'ctrlKey',\n            'Control',\n            'shiftKey',\n            'Shift',\n            'altKey',\n            'Alt',\n            'metaKey',\n            'Meta',\n            'altGraphKey',\n            'AltGraph'\n          ],\n          i = 0; i < keys.length; i += 2\n        ) {\n          if (init[keys[i]])\n            out.push(keys[i + 1]);\n        }\n        return out.join(' ');\n      }\n\n      function withDefaults(target, source) {\n        for (var key in source) {\n          if (\n            source.hasOwnProperty(key) &&\n            !source.hasOwnProperty.call(target, key)\n          ) target[key] = source[key];\n        }\n        return target;\n      }\n\n      function withInitValues(key, out, init) {\n        try {\n          out[key] = init[key];\n        } catch(o_O) {}\n      }\n\n      function KeyboardEvent(type, init) {\n        enoughArguments(arguments.length, 'KeyboardEvent');\n        init = withDefaults(init || {}, defaults);\n        var\n          out = document.createEvent(eventType),\n          ctrlKey = init.ctrlKey,\n          shiftKey = init.shiftKey,\n          altKey = init.altKey,\n          metaKey = init.metaKey,\n          altGraphKey = init.altGraphKey,\n          modifiers = initType > 3 ? getModifier(init) : null,\n          key = String(init.key),\n          chr = String(init.char),\n          location = init.location,\n          keyCode = init.keyCode || (\n            (init.keyCode = key) &&\n            key.charCodeAt(0)\n          ) || 0,\n          charCode = init.charCode || (\n            (init.charCode = chr) &&\n            chr.charCodeAt(0)\n          ) || 0,\n          bubbles = init.bubbles,\n          cancelable = init.cancelable,\n          repeat = init.repeat,\n          locale = init.locale,\n          view = init.view || window,\n          args\n        ;\n        if (!init.which) init.which = init.keyCode;\n        if ('initKeyEvent' in out) {\n          out.initKeyEvent(\n            type, bubbles, cancelable, view,\n            ctrlKey, altKey, shiftKey, metaKey, keyCode, charCode\n          );\n        } else if (0 < initType && 'initKeyboardEvent' in out) {\n          args = [type, bubbles, cancelable, view];\n          switch (initType) {\n            case 1:\n              args.push(key, location, ctrlKey, shiftKey, altKey, metaKey, altGraphKey);\n              break;\n            case 2:\n              args.push(ctrlKey, altKey, shiftKey, metaKey, keyCode, charCode);\n              break;\n            case 3:\n              args.push(key, location, ctrlKey, altKey, shiftKey, metaKey, altGraphKey);\n              break;\n            case 4:\n              args.push(key, location, modifiers, repeat, locale);\n              break;\n            default:\n              args.push(char, key, location, modifiers, repeat, locale);\n          }\n          out.initKeyboardEvent.apply(out, args);\n        } else {\n          out.initEvent(type, bubbles, cancelable);\n        }\n        for (key in out) {\n          if (defaults.hasOwnProperty(key) && out[key] !== init[key]) {\n            withInitValues(key, out, init);\n          }\n        }\n        return out;\n      }\n      KeyboardEvent.prototype = $KeyboardEvent.prototype;\n      return KeyboardEvent;\n    }(window.KeyboardEvent || function KeyboardEvent() {}));\n    defineProperty(window, 'KeyboardEvent', {value: o_O});\n    // Android 4 gotcha\n    if (KeyboardEvent !== o_O) KeyboardEvent = o_O;\n  }\n\n  // window.MouseEvent as constructor\n  try { new MouseEvent('_', {}); } catch (o_O) {\n    /* jshint -W022 */\n    o_O = (function ($MouseEvent) {\n      function MouseEvent(type, init) {\n        enoughArguments(arguments.length, 'MouseEvent');\n        var out = document.createEvent('MouseEvent');\n        if (!init) init = {};\n        out.initMouseEvent(\n          type,\n          !!init.bubbles,\n          !!init.cancelable,\n          init.view || window,\n          init.detail || 1,\n          init.screenX || 0,\n          init.screenY || 0,\n          init.clientX || 0,\n          init.clientY || 0,\n          !!init.ctrlKey,\n          !!init.altKey,\n          !!init.shiftKey,\n          !!init.metaKey,\n          init.button || 0,\n          init.relatedTarget || null\n        );\n        return out;\n      }\n      MouseEvent.prototype = $MouseEvent.prototype;\n      return MouseEvent;\n    }(window.MouseEvent || function MouseEvent() {}));\n    defineProperty(window, 'MouseEvent', {value: o_O});\n    // Android 4 gotcha\n    if (MouseEvent !== o_O) MouseEvent = o_O;\n  }\n\n}(window));(function (global){'use strict';\n\n  // a WeakMap fallback for DOM nodes only used as key\n  var DOMMap = global.WeakMap || (function () {\n\n    var\n      counter = 0,\n      dispatched = false,\n      drop = false,\n      value\n    ;\n\n    function dispatch(key, ce, shouldDrop) {\n      drop = shouldDrop;\n      dispatched = false;\n      value = undefined;\n      key.dispatchEvent(ce);\n    }\n\n    function Handler(value) {\n      this.value = value;\n    }\n\n    Handler.prototype.handleEvent = function handleEvent(e) {\n      dispatched = true;\n      if (drop) {\n        e.currentTarget.removeEventListener(e.type, this, false);\n      } else {\n        value = this.value;\n      }\n    };\n\n    function DOMMap() {\n      counter++;  // make id clashing highly improbable\n      this.__ce__ = new Event(('@DOMMap:' + counter) + Math.random());\n    }\n\n    DOMMap.prototype = {\n      'constructor': DOMMap,\n      'delete': function del(key) {\n        return dispatch(key, this.__ce__, true), dispatched;\n      },\n      'get': function get(key) {\n        dispatch(key, this.__ce__, false);\n        var v = value;\n        value = undefined;\n        return v;\n      },\n      'has': function has(key) {\n        return dispatch(key, this.__ce__, false), dispatched;\n      },\n      'set': function set(key, value) {\n        dispatch(key, this.__ce__, true);\n        key.addEventListener(this.__ce__.type, new Handler(value), false);\n        return this;\n      },\n    };\n\n    return DOMMap;\n\n  }());\n\n  function Dict() {}\n  Dict.prototype = (Object.create || Object)(null);\n\n  // https://dom.spec.whatwg.org/#interface-eventtarget\n\n  function createEventListener(type, callback, options) {\n    function eventListener(e) {\n      if (eventListener.once) {\n        e.currentTarget.removeEventListener(\n          e.type,\n          callback,\n          eventListener\n        );\n        eventListener.removed = true;\n      }\n      if (eventListener.passive) {\n        e.preventDefault = createEventListener.preventDefault;\n      }\n      if (typeof eventListener.callback === 'function') {\n        /* jshint validthis: true */\n        eventListener.callback.call(this, e);\n      } else if (eventListener.callback) {\n        eventListener.callback.handleEvent(e);\n      }\n      if (eventListener.passive) {\n        delete e.preventDefault;\n      }\n    }\n    eventListener.type = type;\n    eventListener.callback = callback;\n    eventListener.capture = !!options.capture;\n    eventListener.passive = !!options.passive;\n    eventListener.once = !!options.once;\n    // currently pointless but specs say to use it, so ...\n    eventListener.removed = false;\n    return eventListener;\n  }\n\n  createEventListener.preventDefault = function preventDefault() {};\n\n  var\n    Event = global.CustomEvent,\n    hOP = Object.prototype.hasOwnProperty,\n    dE = global.dispatchEvent,\n    aEL = global.addEventListener,\n    rEL = global.removeEventListener,\n    counter = 0,\n    increment = function () { counter++; },\n    indexOf = [].indexOf || function indexOf(value){\n      var length = this.length;\n      while(length--) {\n        if (this[length] === value) {\n          break;\n        }\n      }\n      return length;\n    },\n    getListenerKey = function (options) {\n      return ''.concat(\n        options.capture ? '1' : '0',\n        options.passive ? '1' : '0',\n        options.once ? '1' : '0'\n      );\n    },\n    augment, proto\n  ;\n\n  try {\n    aEL('_', increment, {once: true});\n    dE(new Event('_'));\n    dE(new Event('_'));\n    rEL('_', increment, {once: true});\n  } catch(o_O) {}\n\n  if (counter !== 1) {\n    (function () {\n      var dm = new DOMMap();\n      function createAEL(aEL) {\n        return function addEventListener(type, handler, options) {\n          if (options && typeof options !== 'boolean') {\n            var\n              info = dm.get(this),\n              key = getListenerKey(options),\n              i, tmp, wrap\n            ;\n            if (!info) dm.set(this, (info = new Dict()));\n            if (!(type in info)) info[type] = {\n              handler: [],\n              wrap: []\n            };\n            tmp = info[type];\n            i = indexOf.call(tmp.handler, handler);\n            if (i < 0) {\n              i = tmp.handler.push(handler) - 1;\n              tmp.wrap[i] = (wrap = new Dict());\n            } else {\n              wrap = tmp.wrap[i];\n            }\n            if (!(key in wrap)) {\n              wrap[key] = createEventListener(type, handler, options);\n              aEL.call(this, type, wrap[key], wrap[key].capture);\n            }\n          } else {\n            aEL.call(this, type, handler, options);\n          }\n        };\n      }\n      function createREL(rEL) {\n        return function removeEventListener(type, handler, options) {\n          if (options && typeof options !== 'boolean') {\n            var\n              info = dm.get(this),\n              key, i, tmp, wrap\n            ;\n            if (info && (type in info)) {\n              tmp = info[type];\n              i = indexOf.call(tmp.handler, handler);\n              if (-1 < i) {\n                key = getListenerKey(options);\n                wrap = tmp.wrap[i];\n                if (key in wrap) {\n                  rEL.call(this, type, wrap[key], wrap[key].capture);\n                  delete wrap[key];\n                  // return if there are other wraps\n                  for (key in wrap) return;\n                  // otherwise remove all the things\n                  tmp.handler.splice(i, 1);\n                  tmp.wrap.splice(i, 1);\n                  // if there are no other handlers\n                  if (tmp.handler.length === 0)\n                    // drop the info[type] entirely\n                    delete info[type];\n                }\n              }\n            }\n          } else {\n            rEL.call(this, type, handler, options);\n          }\n        };\n      }\n\n      augment = function (Constructor) {\n        if (!Constructor) return;\n        var proto = Constructor.prototype;\n        proto.addEventListener = createAEL(proto.addEventListener);\n        proto.removeEventListener = createREL(proto.removeEventListener);\n      };\n\n      if (global.EventTarget) {\n        augment(EventTarget);\n      } else {\n        augment(global.Text);\n        augment(global.Element || global.HTMLElement);\n        augment(global.HTMLDocument);\n        augment(global.Window || {prototype:global});\n        augment(global.XMLHttpRequest);\n      }\n\n    }());\n  }\n\n}(self));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/dom4/build/dom4.max.js\n// module id = 3\n// module chunks = 0","module.exports = \"precision highp float;\\n#define GLSLIFY 1\\nuniform vec2 resolution;\\nuniform sampler2D u_mySampler;\\nuniform float time;\\nuniform float Period;\\n\\nvarying vec2 v_position;\\n\\n// http://www.nutty.ca/?page_id=352&link=refraction\\n// Description : Array and textureless GLSL 3D simplex noise function.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\\nfloat snoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n  // First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n  // Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n  // Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n  //Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n  // Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\\n\\nvoid main() {\\n  float z = time * Period;\\n  vec2 uv = v_position * 1.5;\\n  float value = (snoise(vec3(uv, z)) + 1.0) * 0.5;\\n  vec4 greyscale = vec4(value, value, value, 1.0);\\n  gl_FragColor = greyscale;\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./shaders/noise.frag\n// module id = 4\n// module chunks = 0","module.exports = \"precision highp float;\\n#define GLSLIFY 1\\nuniform vec2 resolution;\\nuniform sampler2D u_noiseSampler;\\nuniform sampler2D u_texSampler;\\nuniform float Amplitude;\\nuniform float Frequency;\\nuniform float Intensity;\\n\\nvarying vec2 v_position;\\nvarying vec2 v_texcoord;\\n\\nvec3 GetNormal () {\\n  float sobelX[9];\\n  sobelX[0] = 1.0; sobelX[1] = 0.0; sobelX[2] = -1.0;\\n  sobelX[3] = 2.0; sobelX[4] = 0.0; sobelX[5] = -2.0;\\n  sobelX[6] = 1.0; sobelX[7] = 0.0; sobelX[8] = -1.0;\\n\\n  float sobelY[9];\\n  sobelY[0] = 1.0; sobelY[1] = 2.0; sobelY[2] =  1.0;\\n  sobelY[3] = 0.0; sobelY[4] = 0.0; sobelY[5] =  0.0;\\n  sobelY[6] = -1.0; sobelY[7] = -2.0; sobelY[8] = -1.0;\\n\\n  float texelX[9];\\n  float texelY[9];\\n  vec2 uv = v_texcoord * Frequency;\\n  for (int i = 0; i < 9; i++)\\n  {\\n      vec4 otherTexel = texture2D(u_noiseSampler, uv);\\n      float average = (otherTexel.x + otherTexel.y + otherTexel.z) / 3.0;\\n      texelX[i] = average  * sobelX[i];\\n      texelY[i] = average  * sobelY[i];\\n  }\\n  vec3 normal = vec3(\\n    (texelX[0] + texelX[3] + texelX[6]) +\\n    (texelX[2] + texelX[5] + texelX[8]),\\n    (texelY[1] + texelY[2] + texelY[3]) +\\n    (texelY[6] + texelY[7] + texelY[8]),\\n    1.0 / Amplitude);\\n\\n  return normalize(normal);\\n}\\n\\nvoid main() {\\n  vec3 normal = GetNormal();\\n  vec2 offset = (normal.xy + vec2(0, 0.5)) * Intensity;\\n  vec2 uv = v_position * vec2(1.0, -0.5) + vec2(0, 0.5);\\n  // gl_FragColor.xyz = normal;\\n  // gl_FragColor.xyz = texture2D(u_noiseSampler, v_texcoord).xyz;\\n  gl_FragColor.xyz = texture2D(u_texSampler, uv + offset).xyz;\\n  gl_FragColor.w = 1.0;\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./shaders/main.frag\n// module id = 5\n// module chunks = 0","module.exports = \"#define GLSLIFY 1\\nattribute vec2 position;\\nvarying vec2 v_position;\\nvarying vec2 v_texcoord;\\n\\nvoid main() {\\n  gl_Position = vec4(position, 0, 1);\\n  v_position = position;\\n  v_texcoord = position.xy * 0.5 + 0.5;\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./shaders/main.vert\n// module id = 6\n// module chunks = 0","module.exports = __webpack_public_path__ + \"266c6946415c3f1d47a8b2d96471bc0c.jpg\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./midday.jpg\n// module id = 7\n// module chunks = 0","/**\n * @license twgl.js 2.1.0 Copyright (c) 2015, Gregg Tavares All Rights Reserved.\n * Available via the MIT license.\n * see: http://github.com/greggman/twgl.js for details\n */\n/**\n * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } if (typeof module !== 'undefined' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.twgl = factory();\n    }\n}(this, function () {\n\n/**\n * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar notrequirebecasebrowserifymessesupjs, notrequirebecasebrowserifymessesup, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level notrequirebecasebrowserifymessesup that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                name = name.split('/');\n                lastIndex = name.length - 1;\n\n                // Node .js allowance:\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n                }\n\n                //Lop off the last part of baseParts, so that . matches the\n                //\"directory\" and not name of the baseName's module. For instance,\n                //baseName of \"one/two/three\", maps to \"one/two/three.js\", but we\n                //want the directory, \"one/two\" for this normalization.\n                name = baseParts.slice(0, baseParts.length - 1).concat(name);\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a notrequirebecasebrowserifymessesup function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            var args = aps.call(arguments, 0);\n\n            //If first arg is not notrequirebecasebrowserifymessesup('string'), and there is only\n            //one arg, it is the array form without a callback. Insert\n            //a null so that the following concat is correct.\n            if (typeof args[0] !== 'string' && args.length === 1) {\n                args.push(null);\n            }\n            return req.apply(undef, args.concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        notrequirebecasebrowserifymessesup: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [notrequirebecasebrowserifymessesup, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['notrequirebecasebrowserifymessesup', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"notrequirebecasebrowserifymessesup\") {\n                    args[i] = handlers.notrequirebecasebrowserifymessesup(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    notrequirebecasebrowserifymessesupjs = notrequirebecasebrowserifymessesup = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support notrequirebecasebrowserifymessesup(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use notrequirebecasebrowserifymessesup('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    notrequirebecasebrowserifymessesupjs._defined = defined;\n\n    define = function (name, deps, callback) {\n        if (typeof name !== 'string') {\n            throw new Error('See almond README: incorrect module build, no module name');\n        }\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"node_modules/almond/almond.js\", function(){});\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\ndefine('twgl/typedarrays',[], function() {\n  \n\n  /**\n   * Low level shader typed array related functions\n   *\n   * You should generally not need to use these functions. They are provided\n   * for those cases where you're doing something out of the ordinary\n   * and you need lower level access.\n   *\n   * For backward compatibily they are available at both `twgl.typedArray` and `twgl`\n   * itself\n   *\n   * See {@link module:twgl} for core functions\n   *\n   * @module twgl/typedArray\n   */\n\n\n  // make sure we don't see a global gl\n  var gl = undefined;  // eslint-disable-line\n\n  /* DataType */\n  var BYTE                           = 0x1400;\n  var UNSIGNED_BYTE                  = 0x1401;\n  var SHORT                          = 0x1402;\n  var UNSIGNED_SHORT                 = 0x1403;\n  var INT                            = 0x1404;\n  var UNSIGNED_INT                   = 0x1405;\n  var FLOAT                          = 0x1406;\n\n  /**\n   * Get the GL type for a typedArray\n   * @param {ArrayBuffer|ArrayBufferView} typedArray a typedArray\n   * @return {number} the GL type for array. For example pass in an `Int8Array` and `gl.BYTE` will\n   *   be returned. Pass in a `Uint32Array` and `gl.UNSIGNED_INT` will be returned\n   * @memberOf module:twgl/typedArray\n   */\n  function getGLTypeForTypedArray(typedArray) {\n    if (typedArray instanceof Int8Array)         { return BYTE; }           // eslint-disable-line\n    if (typedArray instanceof Uint8Array)        { return UNSIGNED_BYTE; }  // eslint-disable-line\n    if (typedArray instanceof Uint8ClampedArray) { return UNSIGNED_BYTE; }  // eslint-disable-line\n    if (typedArray instanceof Int16Array)        { return SHORT; }          // eslint-disable-line\n    if (typedArray instanceof Uint16Array)       { return UNSIGNED_SHORT; } // eslint-disable-line\n    if (typedArray instanceof Int32Array)        { return INT; }            // eslint-disable-line\n    if (typedArray instanceof Uint32Array)       { return UNSIGNED_INT; }   // eslint-disable-line\n    if (typedArray instanceof Float32Array)      { return FLOAT; }          // eslint-disable-line\n    throw \"unsupported typed array type\";\n  }\n\n  /**\n   * Get the typed array constructor for a given GL type\n   * @param {number} type the GL type. (eg: `gl.UNSIGNED_INT`)\n   * @return {function} the constructor for a the corresponding typed array. (eg. `Uint32Array`).\n   * @memberOf module:twgl/typedArray\n   */\n  function getTypedArrayTypeForGLType(type) {\n    switch (type) {\n      case BYTE:           return Int8Array;     // eslint-disable-line\n      case UNSIGNED_BYTE:  return Uint8Array;    // eslint-disable-line\n      case SHORT:          return Int16Array;    // eslint-disable-line\n      case UNSIGNED_SHORT: return Uint16Array;   // eslint-disable-line\n      case INT:            return Int32Array;    // eslint-disable-line\n      case UNSIGNED_INT:   return Uint32Array;   // eslint-disable-line\n      case FLOAT:          return Float32Array;  // eslint-disable-line\n      default:\n        throw \"unknown gl type\";\n    }\n  }\n\n  function isArrayBuffer(a) {\n    return a && a.buffer && a.buffer instanceof ArrayBuffer;\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  return {\n    \"getGLTypeForTypedArray\": getGLTypeForTypedArray,\n    \"getTypedArrayTypeForGLType\": getTypedArrayTypeForGLType,\n    \"isArrayBuffer\": isArrayBuffer,\n  };\n});\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/utils',[], function() {\n  \n\n  /**\n   * Copy an object 1 level deep\n   * @param {object} src object to copy\n   * @return {object} the copy\n   */\n  function shallowCopy(src) {\n    var dst = {};\n    Object.keys(src).forEach(function(key) {\n      dst[key] = src[key];\n    });\n    return dst;\n  }\n\n  /**\n   * Copy named properties\n   *\n   * @param {string[]} names names of properties to copy\n   * @param {object} src object to copy properties from\n   * @param {object} dst object to copy properties to\n   */\n  function copyNamedProperties(names, src, dst) {\n    names.forEach(function(name) {\n      var value = src[name];\n      if (value !== undefined) {\n        dst[name] = value;\n      }\n    });\n  }\n\n  /**\n   * Copies properties from source to dest only if a matching key is in dest\n   *\n   * @param {Object.<string, ?>} src the source\n   * @param {Object.<string, ?>} dst the dest\n   */\n  function copyExistingProperties(src, dst) {\n    Object.keys(dst).forEach(function(key) {\n      if (dst.hasOwnProperty(key) && src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    });\n  }\n\n  /**\n   * Gets the gl version as a number\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @return {number} version of gl\n   */\n  function getVersionAsNumber(gl) {\n    return parseFloat(gl.getParameter(gl.VERSION).substr(6));\n  }\n\n  /**\n   * Check if context is WebGL 2.0\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @return {bool} true if it's WebGL 2.0\n   * @memberOf module:twgl\n   */\n  function isWebGL2(gl) {\n    return gl.getParameter(gl.VERSION).indexOf(\"WebGL 2.0\") === 0;\n  }\n\n  /**\n   * Check if context is WebGL 1.0\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @return {bool} true if it's WebGL 1.0\n   * @memberOf module:twgl\n   */\n  function isWebGL1(gl) {\n    var version = getVersionAsNumber(gl);\n    return version <= 1.0 && version > 0.0;  // because as of 2016/5 Edge returns 0.96\n  }\n\n  var error =\n      (    window.console\n        && window.console.error\n        && typeof window.console.error === \"function\"\n      )\n      ? window.console.error.bind(window.console)\n      : function() { };\n\n  var warn =\n      (    window.console\n        && window.console.warn\n        && typeof window.console.warn === \"function\"\n      )\n      ? window.console.warn.bind(window.console)\n      : function() { };\n\n  return {\n    copyExistingProperties: copyExistingProperties,\n    copyNamedProperties: copyNamedProperties,\n    shallowCopy: shallowCopy,\n    isWebGL1: isWebGL1,\n    isWebGL2: isWebGL2,\n    error: error,\n    warn: warn,\n  };\n});\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/attributes',[\n    './typedarrays',\n    './utils',\n  ], function(\n    typedArrays,\n    utils) {\n  \n\n  /**\n   * Low level attribute and buffer related functions\n   *\n   * You should generally not need to use these functions. They are provided\n   * for those cases where you're doing something out of the ordinary\n   * and you need lower level access.\n   *\n   * For backward compatibily they are available at both `twgl.attributes` and `twgl`\n   * itself\n   *\n   * See {@link module:twgl} for core functions\n   *\n   * @module twgl/attributes\n   */\n\n  // make sure we don't see a global gl\n  var gl = undefined;  // eslint-disable-line\n  var defaults = {\n    attribPrefix: \"\",\n  };\n\n  /**\n   * Sets the default attrib prefix\n   *\n   * When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`\n   * as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.\n   *\n   * In otherwords I'll create arrays of geometry like this\n   *\n   *     var arrays = {\n   *       position: ...\n   *       normal: ...\n   *       texcoord: ...\n   *     };\n   *\n   * But need those mapped to attributes and my attributes start with `a_`.\n   *\n   * @deprecated see {@link module:twgl.setDefaults}\n   * @param {string} prefix prefix for attribs\n   * @memberOf module:twgl/attributes\n   */\n  function setAttributePrefix(prefix) {\n    defaults.attribPrefix = prefix;\n  }\n\n  function setDefaults(newDefaults) {\n    utils.copyExistingProperties(newDefaults, defaults);\n  }\n\n  function setBufferFromTypedArray(gl, type, buffer, array, drawType) {\n    gl.bindBuffer(type, buffer);\n    gl.bufferData(type, array, drawType || gl.STATIC_DRAW);\n  }\n\n  /**\n   * Given typed array creates a WebGLBuffer and copies the typed array\n   * into it.\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @param {ArrayBuffer|ArrayBufferView|WebGLBuffer} typedArray the typed array. Note: If a WebGLBuffer is passed in it will just be returned. No action will be taken\n   * @param {number} [type] the GL bind type for the buffer. Default = `gl.ARRAY_BUFFER`.\n   * @param {number} [drawType] the GL draw type for the buffer. Default = 'gl.STATIC_DRAW`.\n   * @return {WebGLBuffer} the created WebGLBuffer\n   * @memberOf module:twgl/attributes\n   */\n  function createBufferFromTypedArray(gl, typedArray, type, drawType) {\n    if (typedArray instanceof WebGLBuffer) {\n      return typedArray;\n    }\n    type = type || gl.ARRAY_BUFFER;\n    var buffer = gl.createBuffer();\n    setBufferFromTypedArray(gl, type, buffer, typedArray, drawType);\n    return buffer;\n  }\n\n  function isIndices(name) {\n    return name === \"indices\";\n  }\n\n  // This is really just a guess. Though I can't really imagine using\n  // anything else? Maybe for some compression?\n  function getNormalizationForTypedArray(typedArray) {\n    if (typedArray instanceof Int8Array)    { return true; }  // eslint-disable-line\n    if (typedArray instanceof Uint8Array)   { return true; }  // eslint-disable-line\n    return false;\n  }\n\n  function getArray(array) {\n    return array.length ? array : array.data;\n  }\n\n  var texcoordRE = /coord|texture/i;\n  var colorRE = /color|colour/i;\n\n  function guessNumComponentsFromName(name, length) {\n    var numComponents;\n    if (texcoordRE.test(name)) {\n      numComponents = 2;\n    } else if (colorRE.test(name)) {\n      numComponents = 4;\n    } else {\n      numComponents = 3;  // position, normals, indices ...\n    }\n\n    if (length % numComponents > 0) {\n      throw \"Can not guess numComponents for attribute '\" + name + \"'. Tried \" +\n            numComponents + \" but \" + length +\n            \" values is not evenly divisible by \" + numComponents +\n            \". You should specify it.\";\n    }\n\n    return numComponents;\n  }\n\n  function getNumComponents(array, arrayName) {\n    return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);\n  }\n\n  function makeTypedArray(array, name) {\n    if (typedArrays.isArrayBuffer(array)) {\n      return array;\n    }\n\n    if (typedArrays.isArrayBuffer(array.data)) {\n      return array.data;\n    }\n\n    if (Array.isArray(array)) {\n      array = {\n        data: array,\n      };\n    }\n\n    var Type = array.type;\n    if (!Type) {\n      if (isIndices(name)) {\n        Type = Uint16Array;\n      } else {\n        Type = Float32Array;\n      }\n    }\n    return new Type(array.data);\n  }\n\n  /**\n   * The info for an attribute. This is effectively just the arguments to `gl.vertexAttribPointer` plus the WebGLBuffer\n   * for the attribute.\n   *\n   * @typedef {Object} AttribInfo\n   * @property {number} [numComponents] the number of components for this attribute.\n   * @property {number} [size] synonym for `numComponents`.\n   * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`\n   * @property {boolean} [normalized] whether or not to normalize the data. Default = false\n   * @property {number} [offset] offset into buffer in bytes. Default = 0\n   * @property {number} [stride] the stride in bytes per element. Default = 0\n   * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute\n   * @property {number} [drawType] the draw type passed to gl.bufferData. Default = gl.STATIC_DRAW\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Use this type of array spec when TWGL can't guess the type or number of compoments of an array\n   * @typedef {Object} FullArraySpec\n   * @property {(number[]|ArrayBuffer)} data The data of the array.\n   * @property {number} [numComponents] number of components for `vertexAttribPointer`. Default is based on the name of the array.\n   *    If `coord` is in the name assumes `numComponents = 2`.\n   *    If `color` is in the name assumes `numComponents = 4`.\n   *    otherwise assumes `numComponents = 3`\n   * @property {constructor} type The type. This is only used if `data` is a JavaScript array. It is the constructor for the typedarray. (eg. `Uint8Array`).\n   * For example if you want colors in a `Uint8Array` you might have a `FullArraySpec` like `{ type: Uint8Array, data: [255,0,255,255, ...], }`.\n   * @property {number} [size] synonym for `numComponents`.\n   * @property {boolean} [normalize] normalize for `vertexAttribPointer`. Default is true if type is `Int8Array` or `Uint8Array` otherwise false.\n   * @property {number} [stride] stride for `vertexAttribPointer`. Default = 0\n   * @property {number} [offset] offset for `vertexAttribPointer`. Default = 0\n   * @property {string} [attrib] name of attribute this array maps to. Defaults to same name as array prefixed by the default attribPrefix.\n   * @property {string} [name] synonym for `attrib`.\n   * @property {string} [attribName] synonym for `attrib`.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * An individual array in {@link module:twgl.Arrays}\n   *\n   * When passed to {@link module:twgl.createBufferInfoFromArrays} if an ArraySpec is `number[]` or `ArrayBuffer`\n   * the types will be guessed based on the name. `indices` will be `Uint16Array`, everything else will\n   * be `Float32Array`\n   *\n   * @typedef {(number[]|ArrayBuffer|module:twgl.FullArraySpec)} ArraySpec\n   * @memberOf module:twgl\n   */\n\n  /**\n   * This is a JavaScript object of arrays by name. The names should match your shader's attributes. If your\n   * attributes have a common prefix you can specify it by calling {@link module:twgl.setAttributePrefix}.\n   *\n   *     Bare JavaScript Arrays\n   *\n   *         var arrays = {\n   *            position: [-1, 1, 0],\n   *            normal: [0, 1, 0],\n   *            ...\n   *         }\n   *\n   *     Bare TypedArrays\n   *\n   *         var arrays = {\n   *            position: new Float32Array([-1, 1, 0]),\n   *            color: new Uint8Array([255, 128, 64, 255]),\n   *            ...\n   *         }\n   *\n   * *   Will guess at `numComponents` if not specified based on name.\n   *\n   *     If `coord` is in the name assumes `numComponents = 2`\n   *\n   *     If `color` is in the name assumes `numComponents = 4`\n   *\n   *     otherwise assumes `numComponents = 3`\n   *\n   * Objects with various fields. See {@link module:twgl.FullArraySpec}.\n   *\n   *     var arrays = {\n   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n   *     };\n   *\n   * @typedef {Object.<string, module:twgl.ArraySpec>} Arrays\n   * @memberOf module:twgl\n   */\n\n\n  /**\n   * Creates a set of attribute data and WebGLBuffers from set of arrays\n   *\n   * Given\n   *\n   *      var arrays = {\n   *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n   *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n   *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n   *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },\n   *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n   *      };\n   *\n   * returns something like\n   *\n   *      var attribs = {\n   *        position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n   *        texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n   *        normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n   *        color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },\n   *      };\n   *\n   * notes:\n   *\n   * *   Arrays can take various forms\n   *\n   *     Bare JavaScript Arrays\n   *\n   *         var arrays = {\n   *            position: [-1, 1, 0],\n   *            normal: [0, 1, 0],\n   *            ...\n   *         }\n   *\n   *     Bare TypedArrays\n   *\n   *         var arrays = {\n   *            position: new Float32Array([-1, 1, 0]),\n   *            color: new Uint8Array([255, 128, 64, 255]),\n   *            ...\n   *         }\n   *\n   * *   Will guess at `numComponents` if not specified based on name.\n   *\n   *     If `coord` is in the name assumes `numComponents = 2`\n   *\n   *     If `color` is in the name assumes `numComponents = 4`\n   *\n   *     otherwise assumes `numComponents = 3`\n   *\n   * @param {WebGLRenderingContext} gl The webgl rendering context.\n   * @param {module:twgl.Arrays} arrays The arrays\n   * @return {Object.<string, module:twgl.AttribInfo>} the attribs\n   * @memberOf module:twgl/attributes\n   */\n  function createAttribsFromArrays(gl, arrays) {\n    var attribs = {};\n    Object.keys(arrays).forEach(function(arrayName) {\n      if (!isIndices(arrayName)) {\n        var array = arrays[arrayName];\n        var attribName = array.attrib || array.name || array.attribName || (defaults.attribPrefix + arrayName);\n        var typedArray = makeTypedArray(array, arrayName);\n        attribs[attribName] = {\n          buffer:        createBufferFromTypedArray(gl, typedArray, undefined, array.drawType),\n          numComponents: getNumComponents(array, arrayName),\n          type:          typedArrays.getGLTypeForTypedArray(typedArray),\n          normalize:     array.normalize !== undefined ? array.normalize : getNormalizationForTypedArray(typedArray),\n          stride:        array.stride || 0,\n          offset:        array.offset || 0,\n          drawType:      array.drawType,\n        };\n      }\n    });\n    return attribs;\n  }\n\n  /**\n   * Sets the contents of a buffer attached to an attribInfo\n   *\n   * This is helper function to dynamically update a buffer.\n   *\n   * Let's say you make a bufferInfo\n   *\n   *     var arrays = {\n   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n   *     };\n   *     var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\n   *\n   *  And you want to dynamically upate the positions. You could do this\n   *\n   *     // assuming arrays.position has already been updated with new data.\n   *     twgl.setAttribInfoBufferFromArray(gl, bufferInfo.attribs.position, arrays.position);\n   *\n   * @param {WebGLRenderingContext} gl\n   * @param {AttribInfo} attribInfo The attribInfo who's buffer contents to set. NOTE: If you have an attribute prefix\n   *   the name of the attribute will include the prefix.\n   * @param {ArraySpec} array Note: it is arguably ineffient to pass in anything but a typed array because anything\n   *    else will have to be converted to a typed array before it can be used by WebGL. During init time that\n   *    inefficiency is usually not important but if you're updating data dynamically best to be efficient.\n   * @param {number} [offset] an optional offset into the buffer. This is only an offset into the WebGL buffer\n   *    not the array. To pass in an offset into the array itself use a typed array and create an `ArrayBufferView`\n   *    for the portion of the array you want to use.\n   *\n   *        var someArray = new Float32Array(1000); // an array with 1000 floats\n   *        var someSubArray = new Float32Array(someArray.buffer, offsetInBytes, sizeInUnits); // a view into someArray\n   *\n   *    Now you can pass `someSubArray` into setAttribInfoBufferFromArray`\n   * @memberOf module:twgl/attributes\n   */\n  function setAttribInfoBufferFromArray(gl, attribInfo, array, offset) {\n    array = makeTypedArray(array);\n    if (offset) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, attribInfo.buffer);\n      gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);\n    } else {\n      setBufferFromTypedArray(gl, gl.ARRAY_BUFFER, attribInfo.buffer, array, attribInfo.drawType);\n    }\n  }\n\n  /**\n   * tries to get the number of elements from a set of arrays.\n   */\n\n  var getNumElementsFromNonIndexedArrays = (function() {\n    var positionKeys = ['position', 'positions', 'a_position'];\n\n    return function getNumElementsFromNonIndexedArrays(arrays) {\n      var key;\n      for (var ii = 0; ii < positionKeys.length; ++ii) {\n        key = positionKeys[ii];\n        if (key in arrays) {\n          break;\n        }\n      }\n      if (ii === positionKeys.length) {\n        key = Object.keys(arrays)[0];\n      }\n      var array = arrays[key];\n      var length = getArray(array).length;\n      var numComponents = getNumComponents(array, key);\n      var numElements = length / numComponents;\n      if (length % numComponents > 0) {\n        throw \"numComponents \" + numComponents + \" not correct for length \" + length;\n      }\n      return numElements;\n    };\n  }());\n\n  /**\n   * @typedef {Object} BufferInfo\n   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n   * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..\n   * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.\n   * @property {Object.<string, module:twgl.AttribInfo>} [attribs] The attribs approriate to call `setAttributes`\n   * @memberOf module:twgl\n   */\n\n  /**\n   * @typedef {Object} VertexArrayInfo\n   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n   * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..\n   * @property {WebGLVertexArrayObject> [vertexArrayObject] a vertex array object\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Creates a BufferInfo from an object of arrays.\n   *\n   * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to\n   * {@link module:twgl:drawBufferInfo}.\n   *\n   * Given an object like\n   *\n   *     var arrays = {\n   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n   *     };\n   *\n   *  Creates an BufferInfo like this\n   *\n   *     bufferInfo = {\n   *       numElements: 4,        // or whatever the number of elements is\n   *       indices: WebGLBuffer,  // this property will not exist if there are no indices\n   *       attribs: {\n   *         a_position: { buffer: WebGLBuffer, numComponents: 3, },\n   *         a_normal:   { buffer: WebGLBuffer, numComponents: 3, },\n   *         a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },\n   *       },\n   *     };\n   *\n   *  The properties of arrays can be JavaScript arrays in which case the number of components\n   *  will be guessed.\n   *\n   *     var arrays = {\n   *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],\n   *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],\n   *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],\n   *        indices:  [0, 1, 2, 1, 2, 3],\n   *     };\n   *\n   *  They can also by TypedArrays\n   *\n   *     var arrays = {\n   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n   *     };\n   *\n   *  Or augmentedTypedArrays\n   *\n   *     var positions = createAugmentedTypedArray(3, 4);\n   *     var texcoords = createAugmentedTypedArray(2, 4);\n   *     var normals   = createAugmentedTypedArray(3, 4);\n   *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);\n   *\n   *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);\n   *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);\n   *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);\n   *     indices.push([0, 1, 2, 1, 2, 3]);\n   *\n   *     var arrays = {\n   *        position: positions,\n   *        texcoord: texcoords,\n   *        normal:   normals,\n   *        indices:  indices,\n   *     };\n   *\n   * For the last example it is equivalent to\n   *\n   *     var bufferInfo = {\n   *       attribs: {\n   *         a_position: { numComponents: 3, buffer: gl.createBuffer(), },\n   *         a_texcoods: { numComponents: 2, buffer: gl.createBuffer(), },\n   *         a_normals: { numComponents: 3, buffer: gl.createBuffer(), },\n   *       },\n   *       indices: gl.createBuffer(),\n   *       numElements: 6,\n   *     };\n   *\n   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_position.buffer);\n   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);\n   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_texcoord.buffer);\n   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);\n   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_normal.buffer);\n   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);\n   *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);\n   *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @param {module:twgl.Arrays} arrays Your data\n   * @return {module:twgl.BufferInfo} A BufferInfo\n   * @memberOf module:twgl/attributes\n   */\n  function createBufferInfoFromArrays(gl, arrays) {\n    var bufferInfo = {\n      attribs: createAttribsFromArrays(gl, arrays),\n    };\n    var indices = arrays.indices;\n    if (indices) {\n      indices = makeTypedArray(indices, \"indices\");\n      bufferInfo.indices = createBufferFromTypedArray(gl, indices, gl.ELEMENT_ARRAY_BUFFER);\n      bufferInfo.numElements = indices.length;\n      bufferInfo.elementType = typedArrays.getGLTypeForTypedArray(indices);\n    } else {\n      bufferInfo.numElements = getNumElementsFromNonIndexedArrays(arrays);\n    }\n\n    return bufferInfo;\n  }\n\n  /**\n   * Creates a buffer from an array, typed array, or array spec\n   *\n   * Given something like this\n   *\n   *     [1, 2, 3],\n   *\n   * or\n   *\n   *     new Uint16Array([1,2,3]);\n   *\n   * or\n   *\n   *     {\n   *        data: [1, 2, 3],\n   *        type: Uint8Array,\n   *     }\n   *\n   * returns a WebGLBuffer that constains the given data.\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n   * @param {module:twgl.ArraySpec} array an array, typed array, or array spec.\n   * @param {string} arrayName name of array. Used to guess the type if type can not be dervied other wise.\n   * @return {WebGLBuffer} a WebGLBuffer containing the data in array.\n   * @memberOf module:twgl/attributes\n   */\n  function createBufferFromArray(gl, array, arrayName) {\n    var type = arrayName === \"indices\" ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n    var typedArray = makeTypedArray(array, arrayName);\n    return createBufferFromTypedArray(gl, typedArray, type);\n  }\n\n  /**\n   * Creates buffers from arrays or typed arrays\n   *\n   * Given something like this\n   *\n   *     var arrays = {\n   *        positions: [1, 2, 3],\n   *        normals: [0, 0, 1],\n   *     }\n   *\n   * returns something like\n   *\n   *     buffers = {\n   *       positions: WebGLBuffer,\n   *       normals: WebGLBuffer,\n   *     }\n   *\n   * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n   * @param {module:twgl.Arrays} arrays\n   * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array\n   * @memberOf module:twgl/attributes\n   */\n  function createBuffersFromArrays(gl, arrays) {\n    var buffers = { };\n    Object.keys(arrays).forEach(function(key) {\n      buffers[key] = createBufferFromArray(gl, arrays[key], key);\n    });\n\n    return buffers;\n  }\n\n  /**\n   * Creates a BufferInfo from an object of arrays.\n   *\n   * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to\n   * {@link module:twgl:drawBufferInfo}.\n   *\n   * > **IMPORTANT:** Vertex Array Objects are **not** a direct analog for a BufferInfo. Vertex Array Objects\n   *   assign buffers to specific attributes at creation time. That means they can only be used with programs\n   *   who's attributes use the same attribute locations for the same purposes.\n   *\n   * > Bind your attribute locations by passing an array of attribute names to {@link module:twgl.createProgramInfo}\n   *   or use WebGL 2's GLSL ES 3's `layout(location = <num>)` to make sure locations match.\n   *\n   * also\n   *\n   * > **IMPORTANT:** After calling twgl.setBuffersAndAttribute with a BufferInfo that uses a Vertex Array Object\n   *   that Vertex Array Object will be bound. That means **ANY MANIPULATION OF ELEMENT_ARRAY_BUFFER or ATTRIBUTES**\n   *   will affect the Vertex Array Object state.\n   *\n   * > Call `gl.bindVertexArray(null)` to get back manipulating the global attributes and ELEMENT_ARRAY_BUFFER.\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @param {module:twgl.ProgramInfo|module:twgl.ProgramInfo[]} programInfo a programInfo or array of programInfos\n   *\n   *    You need to make sure every attribute that will be used is bound. So for example assume shader 1\n   *    uses attributes A, B, C and shader 2 uses attributes A, B, D. If you only pass in the programInfo\n   *    for shader 1 then only attributes A, B, and C will have their attributes set because TWGL doesn't\n   *    now attribute D's location.\n   *\n   *    So, you can pass in both shader 1 and shader 2's programInfo\n   *\n   * @return {module:twgl.VertexArrayInfo} The created VertexArrayInfo\n   *\n   * @memberOf module:twgl/attributes\n   */\n  function createVertexArrayInfo(gl, programInfos, bufferInfo) {\n    var vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    if (!programInfos.length) {\n      programInfos = [programInfos];\n    }\n    programInfos.forEach(function(programInfo) {\n      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n    });\n    gl.bindVertexArray(null);\n    return {\n      numElements: bufferInfo.numElements,\n      elementType: bufferInfo.elementType,\n      vertexArrayObject: vao,\n    };\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  // No speed diff AFAICT.\n  return {\n    \"createAttribsFromArrays\": createAttribsFromArrays,\n    \"createBuffersFromArrays\": createBuffersFromArrays,\n    \"createBufferFromArray\": createBufferFromArray,\n    \"createBufferFromTypedArray\": createBufferFromTypedArray,\n    \"createBufferInfoFromArrays\": createBufferInfoFromArrays,\n    \"setAttribInfoBufferFromArray\": setAttribInfoBufferFromArray,\n\n    \"createVertexArrayInfo\": createVertexArrayInfo,\n\n    \"setAttributePrefix\": setAttributePrefix,\n\n    \"setDefaults_\": setDefaults,\n    \"getNumComponents_\": getNumComponents,\n    \"getArray_\": getArray,\n  };\n\n});\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/programs',[\n    './utils',\n  ], function(\n    utils) {\n  \n\n  /**\n   * Low level shader program related functions\n   *\n   * You should generally not need to use these functions. They are provided\n   * for those cases where you're doing something out of the ordinary\n   * and you need lower level access.\n   *\n   * For backward compatibily they are available at both `twgl.programs` and `twgl`\n   * itself\n   *\n   * See {@link module:twgl} for core functions\n   *\n   * @module twgl/programs\n   */\n\n  var error = utils.error;\n  var warn = utils.warn;\n\n  var FLOAT                         = 0x1406;\n  var FLOAT_VEC2                    = 0x8B50;\n  var FLOAT_VEC3                    = 0x8B51;\n  var FLOAT_VEC4                    = 0x8B52;\n  var INT                           = 0x1404;\n  var INT_VEC2                      = 0x8B53;\n  var INT_VEC3                      = 0x8B54;\n  var INT_VEC4                      = 0x8B55;\n  var BOOL                          = 0x8B56;\n  var BOOL_VEC2                     = 0x8B57;\n  var BOOL_VEC3                     = 0x8B58;\n  var BOOL_VEC4                     = 0x8B59;\n  var FLOAT_MAT2                    = 0x8B5A;\n  var FLOAT_MAT3                    = 0x8B5B;\n  var FLOAT_MAT4                    = 0x8B5C;\n  var SAMPLER_2D                    = 0x8B5E;\n  var SAMPLER_CUBE                  = 0x8B60;\n  var SAMPLER_3D                    = 0x8B5F;\n  var SAMPLER_2D_SHADOW             = 0x8B62;\n  var FLOAT_MAT2x3                  = 0x8B65;\n  var FLOAT_MAT2x4                  = 0x8B66;\n  var FLOAT_MAT3x2                  = 0x8B67;\n  var FLOAT_MAT3x4                  = 0x8B68;\n  var FLOAT_MAT4x2                  = 0x8B69;\n  var FLOAT_MAT4x3                  = 0x8B6A;\n  var SAMPLER_2D_ARRAY              = 0x8DC1;\n  var SAMPLER_2D_ARRAY_SHADOW       = 0x8DC4;\n  var SAMPLER_CUBE_SHADOW           = 0x8DC5;\n  var UNSIGNED_INT                  = 0x1405;\n  var UNSIGNED_INT_VEC2             = 0x8DC6;\n  var UNSIGNED_INT_VEC3             = 0x8DC7;\n  var UNSIGNED_INT_VEC4             = 0x8DC8;\n  var INT_SAMPLER_2D                = 0x8DCA;\n  var INT_SAMPLER_3D                = 0x8DCB;\n  var INT_SAMPLER_CUBE              = 0x8DCC;\n  var INT_SAMPLER_2D_ARRAY          = 0x8DCF;\n  var UNSIGNED_INT_SAMPLER_2D       = 0x8DD2;\n  var UNSIGNED_INT_SAMPLER_3D       = 0x8DD3;\n  var UNSIGNED_INT_SAMPLER_CUBE     = 0x8DD4;\n  var UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;\n\n  var TEXTURE_2D                    = 0x0DE1;\n  var TEXTURE_CUBE_MAP              = 0x8513;\n  var TEXTURE_3D                    = 0x806F;\n  var TEXTURE_2D_ARRAY              = 0x8C1A;\n\n  var typeMap = {};\n\n  /**\n   * Returns the corresponding bind point for a given sampler type\n   */\n  function getBindPointForSamplerType(gl, type) {\n    return typeMap[type].bindPoint;\n  }\n\n  // This kind of sucks! If you could compose functions as in `var fn = gl[name];`\n  // this code could be a lot smaller but that is sadly really slow (T_T)\n\n  function floatSetter(gl, location) {\n    return function(v) {\n      gl.uniform1f(location, v);\n    };\n  }\n\n  function floatArraySetter(gl, location) {\n    return function(v) {\n      gl.uniform1fv(location, v);\n    };\n  }\n\n  function floatVec2Setter(gl, location) {\n    return function(v) {\n      gl.uniform2fv(location, v);\n    };\n  }\n\n  function floatVec3Setter(gl, location) {\n    return function(v) {\n      gl.uniform3fv(location, v);\n    };\n  }\n\n  function floatVec4Setter(gl, location) {\n    return function(v) {\n      gl.uniform4fv(location, v);\n    };\n  }\n\n  function intSetter(gl, location) {\n    return function(v) {\n      gl.uniform1i(location, v);\n    };\n  }\n\n  function intArraySetter(gl, location) {\n    return function(v) {\n      gl.uniform1iv(location, v);\n    };\n  }\n\n  function intVec2Setter(gl, location) {\n    return function(v) {\n      gl.uniform2iv(location, v);\n    };\n  }\n\n  function intVec3Setter(gl, location) {\n    return function(v) {\n      gl.uniform3iv(location, v);\n    };\n  }\n\n  function intVec4Setter(gl, location) {\n    return function(v) {\n      gl.uniform4iv(location, v);\n    };\n  }\n\n  function uintSetter(gl, location) {\n    return function(v) {\n      gl.uniform1ui(location, v);\n    };\n  }\n\n  function uintArraySetter(gl, location) {\n    return function(v) {\n      gl.uniform1uiv(location, v);\n    };\n  }\n\n  function uintVec2Setter(gl, location) {\n    return function(v) {\n      gl.uniform2uiv(location, v);\n    };\n  }\n\n  function uintVec3Setter(gl, location) {\n    return function(v) {\n      gl.uniform3uiv(location, v);\n    };\n  }\n\n  function uintVec4Setter(gl, location) {\n    return function(v) {\n      gl.uniform4uiv(location, v);\n    };\n  }\n\n  function floatMat2Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix2fv(location, false, v);\n    };\n  }\n\n  function floatMat3Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix3fv(location, false, v);\n    };\n  }\n\n  function floatMat4Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix4fv(location, false, v);\n    };\n  }\n\n  function floatMat23Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix2x3fv(location, false, v);\n    };\n  }\n\n  function floatMat32Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix3x2fv(location, false, v);\n    };\n  }\n\n  function floatMat24Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix2x4fv(location, false, v);\n    };\n  }\n\n  function floatMat42Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix4x2fv(location, false, v);\n    };\n  }\n\n  function floatMat34Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix3x4fv(location, false, v);\n    };\n  }\n\n  function floatMat43Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix4x3fv(location, false, v);\n    };\n  }\n\n  function samplerSetter(gl, type, unit, location) {\n    var bindPoint = getBindPointForSamplerType(gl, type);\n    return function(texture) {\n      gl.uniform1i(location, unit);\n      gl.activeTexture(gl.TEXTURE0 + unit);\n      gl.bindTexture(bindPoint, texture);\n    };\n  }\n\n  function samplerArraySetter(gl, type, unit, location, size) {\n    var bindPoint = getBindPointForSamplerType(gl, type);\n    var units = new Int32Array(size);\n    for (var ii = 0; ii < size; ++ii) {\n      units[ii] = unit + ii;\n    }\n\n    return function(textures) {\n      gl.uniform1iv(location, units);\n      textures.forEach(function(texture, index) {\n        gl.activeTexture(gl.TEXTURE0 + units[index]);\n        gl.bindTexture(bindPoint, texture);\n      });\n    };\n  }\n\n  typeMap[FLOAT]                         = { Type: Float32Array, size:  4, setter: floatSetter,      arraySetter: floatArraySetter, };\n  typeMap[FLOAT_VEC2]                    = { Type: Float32Array, size:  8, setter: floatVec2Setter,  };\n  typeMap[FLOAT_VEC3]                    = { Type: Float32Array, size: 12, setter: floatVec3Setter,  };\n  typeMap[FLOAT_VEC4]                    = { Type: Float32Array, size: 16, setter: floatVec4Setter,  };\n  typeMap[INT]                           = { Type: Int32Array,   size:  4, setter: intSetter,        arraySetter: intArraySetter, };\n  typeMap[INT_VEC2]                      = { Type: Int32Array,   size:  8, setter: intVec2Setter,    };\n  typeMap[INT_VEC3]                      = { Type: Int32Array,   size: 12, setter: intVec3Setter,    };\n  typeMap[INT_VEC4]                      = { Type: Int32Array,   size: 16, setter: intVec4Setter,    };\n  typeMap[UNSIGNED_INT]                  = { Type: Uint32Array,  size:  4, setter: uintSetter,       arraySetter: uintArraySetter, };\n  typeMap[UNSIGNED_INT_VEC2]             = { Type: Uint32Array,  size:  8, setter: uintVec2Setter,   };\n  typeMap[UNSIGNED_INT_VEC3]             = { Type: Uint32Array,  size: 12, setter: uintVec3Setter,   };\n  typeMap[UNSIGNED_INT_VEC4]             = { Type: Uint32Array,  size: 16, setter: uintVec4Setter,   };\n  typeMap[BOOL]                          = { Type: Uint32Array,  size:  4, setter: intSetter,        arraySetter: intArraySetter, };\n  typeMap[BOOL_VEC2]                     = { Type: Uint32Array,  size:  8, setter: intVec2Setter,    };\n  typeMap[BOOL_VEC3]                     = { Type: Uint32Array,  size: 12, setter: intVec3Setter,    };\n  typeMap[BOOL_VEC4]                     = { Type: Uint32Array,  size: 16, setter: intVec4Setter,    };\n  typeMap[FLOAT_MAT2]                    = { Type: Float32Array, size: 16, setter: floatMat2Setter,  };\n  typeMap[FLOAT_MAT3]                    = { Type: Float32Array, size: 36, setter: floatMat3Setter,  };\n  typeMap[FLOAT_MAT4]                    = { Type: Float32Array, size: 64, setter: floatMat4Setter,  };\n  typeMap[FLOAT_MAT2x3]                  = { Type: Float32Array, size: 24, setter: floatMat23Setter, };\n  typeMap[FLOAT_MAT2x4]                  = { Type: Float32Array, size: 32, setter: floatMat24Setter, };\n  typeMap[FLOAT_MAT3x2]                  = { Type: Float32Array, size: 24, setter: floatMat32Setter, };\n  typeMap[FLOAT_MAT3x4]                  = { Type: Float32Array, size: 48, setter: floatMat34Setter, };\n  typeMap[FLOAT_MAT4x2]                  = { Type: Float32Array, size: 32, setter: floatMat42Setter, };\n  typeMap[FLOAT_MAT4x3]                  = { Type: Float32Array, size: 48, setter: floatMat43Setter, };\n  typeMap[SAMPLER_2D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n  typeMap[SAMPLER_CUBE]                  = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n  typeMap[SAMPLER_3D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };\n  typeMap[SAMPLER_2D_SHADOW]             = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n  typeMap[SAMPLER_2D_ARRAY]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n  typeMap[SAMPLER_2D_ARRAY_SHADOW]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n  typeMap[SAMPLER_CUBE_SHADOW]           = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n  typeMap[INT_SAMPLER_2D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n  typeMap[INT_SAMPLER_3D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };\n  typeMap[INT_SAMPLER_CUBE]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n  typeMap[INT_SAMPLER_2D_ARRAY]          = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n  typeMap[UNSIGNED_INT_SAMPLER_2D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n  typeMap[UNSIGNED_INT_SAMPLER_3D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };\n  typeMap[UNSIGNED_INT_SAMPLER_CUBE]     = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n  typeMap[UNSIGNED_INT_SAMPLER_2D_ARRAY] = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n\n  var attrTypeMap = {};\n  attrTypeMap[FLOAT_MAT2] = { size:  4, count: 2, };\n  attrTypeMap[FLOAT_MAT3] = { size:  9, count: 3, };\n  attrTypeMap[FLOAT_MAT4] = { size: 16, count: 4, };\n\n  // make sure we don't see a global gl\n  var gl = undefined;  // eslint-disable-line\n\n  /**\n   * Error Callback\n   * @callback ErrorCallback\n   * @param {string} msg error message.\n   * @param {number} [lineOffset] amount to add to line number\n   * @memberOf module:twgl\n   */\n\n  function addLineNumbers(src, lineOffset) {\n    lineOffset = lineOffset || 0;\n    ++lineOffset;\n\n    return src.split(\"\\n\").map(function(line, ndx) {\n      return (ndx + lineOffset) + \": \" + line;\n    }).join(\"\\n\");\n  }\n\n  var spaceRE = /^[ \\t]*\\n/;\n\n  /**\n   * Loads a shader.\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n   * @param {string} shaderSource The shader source.\n   * @param {number} shaderType The type of shader.\n   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors.\n   * @return {WebGLShader} The created shader.\n   */\n  function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\n    var errFn = opt_errorCallback || error;\n    // Create the shader object\n    var shader = gl.createShader(shaderType);\n\n    // Remove the first end of line because WebGL 2.0 notrequirebecasebrowserifymessesups\n    // #version 300 es\n    // as the first line. No whitespace allowed before that line\n    // so\n    //\n    // <script>\n    // #version 300 es\n    // </script>\n    //\n    // Has one line before it which is invalid according to GLSL ES 3.00\n    //\n    var lineOffset = 0;\n    if (spaceRE.test(shaderSource)) {\n      lineOffset = 1;\n      shaderSource = shaderSource.replace(spaceRE, '');\n    }\n\n    // Load the shader source\n    gl.shaderSource(shader, shaderSource);\n\n    // Compile the shader\n    gl.compileShader(shader);\n\n    // Check the compile status\n    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (!compiled) {\n      // Something went wrong during compilation; get the error\n      var lastError = gl.getShaderInfoLog(shader);\n      errFn(addLineNumbers(shaderSource, lineOffset) + \"\\n*** Error compiling shader: \" + lastError);\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    return shader;\n  }\n\n  /**\n   * Creates a program, attaches shaders, binds attrib locations, links the\n   * program and calls useProgram.\n   *\n   * NOTE: There are 3 signatures for this function\n   *\n   *     twgl.createProgram(gl, [vs, fs], opt_errFunc);\n   *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_errFunc);\n   *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n   *\n   * @param {WebGLShader[]} shaders The shaders to attach\n   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console\n   *        on error. If you want something else pass an callback. It's passed an error message.\n   * @return {WebGLProgram?} the created program or null if error.\n   * @memberOf module:twgl/programs\n   */\n  function createProgram(\n      gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {\n    if (typeof opt_locations === 'function') {\n      opt_errorCallback = opt_locations;\n      opt_locations = undefined;\n    }\n    if (typeof opt_attribs === 'function') {\n      opt_errorCallback = opt_attribs;\n      opt_attribs = undefined;\n    }\n    var errFn = opt_errorCallback || error;\n    var program = gl.createProgram();\n    shaders.forEach(function(shader) {\n      gl.attachShader(program, shader);\n    });\n    if (opt_attribs) {\n      opt_attribs.forEach(function(attrib,  ndx) {\n        gl.bindAttribLocation(\n            program,\n            opt_locations ? opt_locations[ndx] : ndx,\n            attrib);\n      });\n    }\n    gl.linkProgram(program);\n\n    // Check the link status\n    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n        // something went wrong with the link\n        var lastError = gl.getProgramInfoLog(program);\n        errFn(\"Error in program linking:\" + lastError);\n\n        gl.deleteProgram(program);\n        return null;\n    }\n    return program;\n  }\n\n  /**\n   * Loads a shader from a script tag.\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n   * @param {string} scriptId The id of the script tag.\n   * @param {number} [opt_shaderType] The type of shader. If not passed in it will\n   *     be derived from the type of the script tag.\n   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors.\n   * @return {WebGLShader?} The created shader or null if error.\n   */\n  function createShaderFromScript(\n      gl, scriptId, opt_shaderType, opt_errorCallback) {\n    var shaderSource = \"\";\n    var shaderType;\n    var shaderScript = document.getElementById(scriptId);\n    if (!shaderScript) {\n      throw \"*** Error: unknown script element\" + scriptId;\n    }\n    shaderSource = shaderScript.text;\n\n    if (!opt_shaderType) {\n      if (shaderScript.type === \"x-shader/x-vertex\") {\n        shaderType = gl.VERTEX_SHADER;\n      } else if (shaderScript.type === \"x-shader/x-fragment\") {\n        shaderType = gl.FRAGMENT_SHADER;\n      } else if (shaderType !== gl.VERTEX_SHADER && shaderType !== gl.FRAGMENT_SHADER) {\n        throw \"*** Error: unknown shader type\";\n      }\n    }\n\n    return loadShader(\n        gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,\n        opt_errorCallback);\n  }\n\n  var defaultShaderType = [\n    \"VERTEX_SHADER\",\n    \"FRAGMENT_SHADER\",\n  ];\n\n  /**\n   * Creates a program from 2 script tags.\n   *\n   * NOTE: There are 3 signatures for this function\n   *\n   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_errFunc);\n   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_errFunc);\n   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n   *\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n   *        to use.\n   * @param {string[]} shaderScriptIds Array of ids of the script\n   *        tags for the shaders. The first is assumed to be the\n   *        vertex shader, the second the fragment shader.\n   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n   *        on error. If you want something else pass an callback. It's passed an error message.\n   * @return {WebGLProgram} The created program.\n   * @memberOf module:twgl/programs\n   */\n  function createProgramFromScripts(\n      gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {\n    var shaders = [];\n    for (var ii = 0; ii < shaderScriptIds.length; ++ii) {\n      var shader = createShaderFromScript(\n          gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], opt_errorCallback);\n      if (!shader) {\n        return null;\n      }\n      shaders.push(shader);\n    }\n    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n  }\n\n  /**\n   * Creates a program from 2 sources.\n   *\n   * NOTE: There are 3 signatures for this function\n   *\n   *     twgl.createProgramFromSource(gl, [vs, fs], opt_errFunc);\n   *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_errFunc);\n   *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n   *\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n   *        to use.\n   * @param {string[]} shaderSourcess Array of sources for the\n   *        shaders. The first is assumed to be the vertex shader,\n   *        the second the fragment shader.\n   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n   *        on error. If you want something else pass an callback. It's passed an error message.\n   * @return {WebGLProgram} The created program.\n   * @memberOf module:twgl/programs\n   */\n  function createProgramFromSources(\n      gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n    var shaders = [];\n    for (var ii = 0; ii < shaderSources.length; ++ii) {\n      var shader = loadShader(\n          gl, shaderSources[ii], gl[defaultShaderType[ii]], opt_errorCallback);\n      if (!shader) {\n        return null;\n      }\n      shaders.push(shader);\n    }\n    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n  }\n\n  /**\n   * Creates setter functions for all uniforms of a shader\n   * program.\n   *\n   * @see {@link module:twgl.setUniforms}\n   *\n   * @param {WebGLProgram} program the program to create setters for.\n   * @returns {Object.<string, function>} an object with a setter by name for each uniform\n   * @memberOf module:twgl/programs\n   */\n  function createUniformSetters(gl, program) {\n    var textureUnit = 0;\n\n    /**\n     * Creates a setter for a uniform of the given program with it's\n     * location embedded in the setter.\n     * @param {WebGLProgram} program\n     * @param {WebGLUniformInfo} uniformInfo\n     * @returns {function} the created setter.\n     */\n    function createUniformSetter(program, uniformInfo) {\n      var location = gl.getUniformLocation(program, uniformInfo.name);\n      var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === \"[0]\");\n      var type = uniformInfo.type;\n      var typeInfo = typeMap[type];\n      if (!typeInfo) {\n        throw (\"unknown type: 0x\" + type.toString(16)); // we should never get here.\n      }\n      if (typeInfo.bindPoint) {\n        // it's a sampler\n        var unit = textureUnit;\n        textureUnit += uniformInfo.size;\n\n        if (isArray) {\n          return typeInfo.arraySetter(gl, type, unit, location, uniformInfo.size);\n        } else {\n          return typeInfo.setter(gl, type, unit, location, uniformInfo.size);\n        }\n      } else {\n        if (typeInfo.arraySetter && isArray) {\n          return typeInfo.arraySetter(gl, location);\n        } else {\n          return typeInfo.setter(gl, location);\n        }\n      }\n    }\n\n    var uniformSetters = { };\n    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    for (var ii = 0; ii < numUniforms; ++ii) {\n      var uniformInfo = gl.getActiveUniform(program, ii);\n      if (!uniformInfo) {\n        break;\n      }\n      var name = uniformInfo.name;\n      // remove the array suffix.\n      if (name.substr(-3) === \"[0]\") {\n        name = name.substr(0, name.length - 3);\n      }\n      var setter = createUniformSetter(program, uniformInfo);\n      uniformSetters[name] = setter;\n    }\n    return uniformSetters;\n  }\n\n  /**\n   * @typedef {Object} UniformData\n   * @property {number} type The WebGL type enum for this uniform\n   * @property {number} size The number of elements for this uniform\n   * @property {number} blockNdx The block index this uniform appears in\n   * @property {number} offset The byte offset in the block for this uniform's value\n   * @memberOf module:twgl\n   */\n\n  /**\n   * The specification for one UniformBlockObject\n   *\n   * @typedef {Object} BlockSpec\n   * @property {number} index The index of the block.\n   * @property {number} size The size in bytes needed for the block\n   * @property {number[]} uniformIndices The indices of the uniforms used by the block. These indices\n   *    correspond to entries in a UniformData array in the {@link module:twgl.UniformBlockSpec}.\n   * @property {bool} usedByVertexShader Self explanitory\n   * @property {bool} usedByFragmentShader Self explanitory\n   * @property {bool} used Self explanitory\n   * @memberOf module:twgl\n   */\n\n  /**\n   * A `UniformBlockSpec` represents the data needed to create and bind\n   * UniformBlockObjects for a given program\n   *\n   * @typedef {Object} UniformBlockSpec\n   * @property {Object.<string, module:twgl.BlockSpec> blockSpecs The BlockSpec for each block by block name\n   * @property {UniformData[]} uniformData An array of data for each uniform by uniform index.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Creates a UniformBlockSpec for the given program.\n   *\n   * A UniformBlockSpec represents the data needed to create and bind\n   * UniformBlockObjects\n   *\n   * @param {WebGL2RenderingContext} gl A WebGL2 Rendering Context\n   * @param {WebGLProgram} program A WebGLProgram for a successfully linked program\n   * @return {module:twgl.UniformBlockSpec} The created UniformBlockSpec\n   * @memberOf module:twgl/programs\n   */\n  function createUniformBlockSpecFromProgram(gl, program) {\n    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n    var uniformData = [];\n    var uniformIndices = [];\n\n    for (var ii = 0; ii < numUniforms; ++ii) {\n      uniformIndices.push(ii);\n      uniformData.push({});\n      var uniformInfo = gl.getActiveUniform(program, ii);\n      if (!uniformInfo) {\n        break;\n      }\n      // REMOVE [0]?\n      uniformData[ii].name = uniformInfo.name;\n    }\n\n    [\n      [ \"UNIFORM_TYPE\", \"type\" ],\n      [ \"UNIFORM_SIZE\", \"size\" ],  // num elements\n      [ \"UNIFORM_BLOCK_INDEX\", \"blockNdx\" ],\n      [ \"UNIFORM_OFFSET\", \"offset\", ],\n    ].forEach(function(pair) {\n      var pname = pair[0];\n      var key = pair[1];\n      gl.getActiveUniforms(program, uniformIndices, gl[pname]).forEach(function(value, ndx) {\n        uniformData[ndx][key] = value;\n      });\n    });\n\n    var blockSpecs = {};\n\n    var numUniformBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n    for (ii = 0; ii < numUniformBlocks; ++ii) {\n      var name = gl.getActiveUniformBlockName(program, ii);\n      var blockSpec = {\n        index: ii,\n        usedByVertexShader: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),\n        usedByFragmentShader: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),\n        size: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_DATA_SIZE),\n        uniformIndices: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),\n      };\n      blockSpec.used = blockSpec.usedByVertexSahder || blockSpec.usedByFragmentShader;\n      blockSpecs[name] = blockSpec;\n    }\n\n    return {\n      blockSpecs: blockSpecs,\n      uniformData: uniformData,\n    };\n  }\n\n  var arraySuffixRE = /\\[\\d+\\]\\.$/;  // better way to check?\n\n  /**\n   * Represents a UniformBlockObject including an ArrayBuffer with all the uniform values\n   * and a corresponding WebGLBuffer to hold those values on the GPU\n   *\n   * @typedef {Object} UniformBlockInfo\n   * @property {string} name The name of the block\n   * @property {ArrayBuffer} array The array buffer that contains the uniform values\n   * @property {Float32Array} asFloat A float view on the array buffer. This is useful\n   *    inspecting the contents of the buffer in the debugger.\n   * @property {WebGLBuffer} buffer A WebGL buffer that will hold a copy of the uniform values for rendering.\n   * @property {number} [offset] offset into buffer\n   * @property {Object.<string, ArrayBufferView>} uniforms A uniform name to ArrayBufferView map.\n   *   each Uniform has a correctly typed `ArrayBufferView` into array at the correct offset\n   *   and length of that uniform. So for example a float uniform would have a 1 float `Float32Array`\n   *   view. A single mat4 would have a 16 element `Float32Array` view. An ivec2 would have an\n   *   `Int32Array` view, etc.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Creates a `UniformBlockInfo` for the specified block\n   *\n   * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy\n   * `UniformBlockInfo` is returned**. This is because when debugging GLSL\n   * it is common to comment out large portions of a shader or for example set\n   * the final output to a constant. When that happens blocks get optimized out.\n   * If this function did not create dummy blocks your code would crash when debugging.\n   *\n   * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext\n   * @param {WebGLProgram} program A WebGLProgram\n   * @param {module:twgl.UniformBlockSpec} uinformBlockSpec. A UniformBlockSpec as returned\n   *     from {@link module:twgl.createUniformBlockSpecFromProgram}.\n   * @param {string} blockName The name of the block.\n   * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo\n   * @memberOf module:twgl/programs\n   */\n  function createUniformBlockInfoFromProgram(gl, program, uniformBlockSpec, blockName) {\n    var blockSpecs = uniformBlockSpec.blockSpecs;\n    var uniformData = uniformBlockSpec.uniformData;\n    var blockSpec = blockSpecs[blockName];\n    if (!blockSpec) {\n      warn(\"no uniform block object named:\", blockName);\n      return {\n        name: blockName,\n        uniforms: {},\n      };\n    }\n    var array = new ArrayBuffer(blockSpec.size);\n    var buffer = gl.createBuffer();\n    var uniformBufferIndex = blockSpec.index;\n    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);\n    gl.uniformBlockBinding(program, blockSpec.index, uniformBufferIndex);\n\n    var prefix = blockName + \".\";\n    if (arraySuffixRE.test(prefix)) {\n      prefix = prefix.replace(arraySuffixRE, \".\");\n    }\n    var uniforms = {};\n    blockSpec.uniformIndices.forEach(function(uniformNdx) {\n      var data = uniformData[uniformNdx];\n      var typeInfo = typeMap[data.type];\n      var Type = typeInfo.Type;\n      var length = data.size * typeInfo.size;\n      var name = data.name;\n      if (name.substr(0, prefix.length) === prefix) {\n        name = name.substr(prefix.length);\n      }\n      uniforms[name] = new Type(array, data.offset, length / Type.BYTES_PER_ELEMENT);\n    });\n    return {\n      name: blockName,\n      array: array,\n      asFloat: new Float32Array(array),  // for debugging\n      buffer: buffer,\n      uniforms: uniforms,\n    };\n  }\n\n  /**\n   * Creates a `UniformBlockInfo` for the specified block\n   *\n   * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy\n   * `UniformBlockInfo` is returned**. This is because when debugging GLSL\n   * it is common to comment out large portions of a shader or for example set\n   * the final output to a constant. When that happens blocks get optimized out.\n   * If this function did not create dummy blocks your code would crash when debugging.\n   *\n   * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext\n   * @param {module:twgl.ProgramInfo} programInfo a `ProgramInfo`\n   *     as returned from {@link module:twgl.createProgramInfo}\n   * @param {string} blockName The name of the block.\n   * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo\n   * @memberOf module:twgl/programs\n   */\n  function createUniformBlockInfo(gl, programInfo, blockName) {\n    return createUniformBlockInfoFromProgram(gl, programInfo.program, programInfo.uniformBlockSpec, blockName);\n  }\n\n  /**\n   * Binds a unform block to the matching uniform block point.\n   * Matches by blocks by name so blocks must have the same name not just the same\n   * structure.\n   *\n   * If you have changed any values and you upload the valus into the corresponding WebGLBuffer\n   * call {@link module:twgl.setUniformBlock} instead.\n   *\n   * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.\n   * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`\n   *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as\n   *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.\n   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from\n   *     {@link module:twgl.createUniformBlockInfo}.\n   * @return {bool} true if buffer was bound. If the programInfo has no block with the same block name\n   *     no buffer is bound.\n   * @memberOf module:twgl/programs\n   */\n  function bindUniformBlock(gl, programInfo, uniformBlockInfo) {\n    var uniformBlockSpec = programInfo.uniformBlockSpec || programInfo;\n    var blockSpec = uniformBlockSpec.blockSpecs[uniformBlockInfo.name];\n    if (blockSpec) {\n      var bufferBindIndex = blockSpec.index;\n      gl.bindBufferRange(gl.UNIFORM_BUFFER, bufferBindIndex, uniformBlockInfo.buffer, uniformBlockInfo.offset || 0, uniformBlockInfo.array.byteLength);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Uploads the current uniform values to the corresponding WebGLBuffer\n   * and binds that buffer to the program's corresponding bind point for the uniform block object.\n   *\n   * If you haven't changed any values and you only need to bind the uniform block object\n   * call {@link module:twgl.bindUniformBlock} instead.\n   *\n   * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.\n   * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`\n   *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as\n   *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.\n   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from\n   *     {@link module:twgl.createUniformBlockInfo}.\n   * @memberOf module:twgl/programs\n   */\n  function setUniformBlock(gl, programInfo, uniformBlockInfo) {\n    if (bindUniformBlock(gl, programInfo, uniformBlockInfo)) {\n      gl.bufferData(gl.UNIFORM_BUFFER, uniformBlockInfo.array, gl.DYNAMIC_DRAW);\n    }\n  }\n\n  /**\n   * Sets values of a uniform block object\n   *\n   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo A UniformBlockInfo as returned by {@link module:twgl.createUniformBlockInfo}.\n   * @param {Object.<string, ?>} values A uniform name to value map where the value is correct for the given\n   *    type of uniform. So for example given a block like\n   *\n   *       uniform SomeBlock {\n   *         float someFloat;\n   *         vec2 someVec2;\n   *         vec3 someVec3Array[2];\n   *         int someInt;\n   *       }\n   *\n   *  You can set the values of the uniform block with\n   *\n   *       twgl.setBlockUniforms(someBlockInfo, {\n   *          someFloat: 12.3,\n   *          someVec2: [1, 2],\n   *          someVec3Array: [1, 2, 3, 4, 5, 6],\n   *          someInt: 5,\n   *       }\n   *\n   *  Arrays can be JavaScript arrays or typed arrays\n   *\n   *  Any name that doesn't match will be ignored\n   * @memberOf module:twgl/programs\n   */\n  function setBlockUniforms(uniformBlockInfo, values) {\n    var uniforms = uniformBlockInfo.uniforms;\n    for (var name in values) {\n      var array = uniforms[name];\n      if (array) {\n        var value = values[name];\n        if (value.length) {\n          array.set(value);\n        } else {\n          array[0] = value;\n        }\n      }\n    }\n  }\n\n  /**\n   * Set uniforms and binds related textures.\n   *\n   * example:\n   *\n   *     var programInfo = createProgramInfo(\n   *         gl, [\"some-vs\", \"some-fs\"]);\n   *\n   *     var tex1 = gl.createTexture();\n   *     var tex2 = gl.createTexture();\n   *\n   *     ... assume we setup the textures with data ...\n   *\n   *     var uniforms = {\n   *       u_someSampler: tex1,\n   *       u_someOtherSampler: tex2,\n   *       u_someColor: [1,0,0,1],\n   *       u_somePosition: [0,1,1],\n   *       u_someMatrix: [\n   *         1,0,0,0,\n   *         0,1,0,0,\n   *         0,0,1,0,\n   *         0,0,0,0,\n   *       ],\n   *     };\n   *\n   *     gl.useProgram(program);\n   *\n   * This will automatically bind the textures AND set the\n   * uniforms.\n   *\n   *     twgl.setUniforms(programInfo, uniforms);\n   *\n   * For the example above it is equivalent to\n   *\n   *     var texUnit = 0;\n   *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n   *     gl.bindTexture(gl.TEXTURE_2D, tex1);\n   *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n   *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n   *     gl.bindTexture(gl.TEXTURE_2D, tex2);\n   *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n   *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);\n   *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);\n   *     gl.uniformMatrix4fv(u_someMatrix, false, [\n   *         1,0,0,0,\n   *         0,1,0,0,\n   *         0,0,1,0,\n   *         0,0,0,0,\n   *       ]);\n   *\n   * Note it is perfectly reasonable to call `setUniforms` multiple times. For example\n   *\n   *     var uniforms = {\n   *       u_someSampler: tex1,\n   *       u_someOtherSampler: tex2,\n   *     };\n   *\n   *     var moreUniforms {\n   *       u_someColor: [1,0,0,1],\n   *       u_somePosition: [0,1,1],\n   *       u_someMatrix: [\n   *         1,0,0,0,\n   *         0,1,0,0,\n   *         0,0,1,0,\n   *         0,0,0,0,\n   *       ],\n   *     };\n   *\n   *     twgl.setUniforms(programInfo, uniforms);\n   *     twgl.setUniforms(programInfo, moreUniforms);\n   *\n   * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from\n   *        `createUniformSetters`.\n   * @param {Object.<string, ?>} values an object with values for the\n   *        uniforms.\n   *   You can pass multiple objects by putting them in an array or by calling with more arguments.For example\n   *\n   *     var sharedUniforms = {\n   *       u_fogNear: 10,\n   *       u_projection: ...\n   *       ...\n   *     };\n   *\n   *     var localUniforms = {\n   *       u_world: ...\n   *       u_diffuseColor: ...\n   *     };\n   *\n   *     twgl.setUniforms(programInfo, sharedUniforms, localUniforms);\n   *\n   *     // is the same as\n   *\n   *     twgl.setUniforms(programInfo, [sharedUniforms, localUniforms]);\n   *\n   *     // is the same as\n   *\n   *     twgl.setUniforms(programInfo, sharedUniforms);\n   *     twgl.setUniforms(programInfo, localUniforms};\n   *\n   * @memberOf module:twgl/programs\n   */\n  function setUniforms(setters, values) {  // eslint-disable-line\n    var actualSetters = setters.uniformSetters || setters;\n    var numArgs = arguments.length;\n    for (var andx = 1; andx < numArgs; ++andx) {\n      var vals = arguments[andx];\n      if (Array.isArray(vals)) {\n        var numValues = vals.length;\n        for (var ii = 0; ii < numValues; ++ii) {\n          setUniforms(actualSetters, vals[ii]);\n        }\n      } else {\n        for (var name in vals) {\n          var setter = actualSetters[name];\n          if (setter) {\n            setter(vals[name]);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates setter functions for all attributes of a shader\n   * program. You can pass this to {@link module:twgl.setBuffersAndAttributes} to set all your buffers and attributes.\n   *\n   * @see {@link module:twgl.setAttributes} for example\n   * @param {WebGLProgram} program the program to create setters for.\n   * @return {Object.<string, function>} an object with a setter for each attribute by name.\n   * @memberOf module:twgl/programs\n   */\n  function createAttributeSetters(gl, program) {\n    var attribSetters = {\n    };\n\n    function createAttribSetter(index) {\n      return function(b) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n        gl.enableVertexAttribArray(index);\n        gl.vertexAttribPointer(\n            index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);\n      };\n    }\n\n    function createMatAttribSetter(index, typeInfo) {\n      var defaultSize = typeInfo.size;\n      var count = typeInfo.count;\n\n      return function(b) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n        var numComponents = b.size || b.numComponents || defaultSize;\n        var size = numComponents / count;\n        var type = b.type || gl.FLOAT;\n        var typeInfo = typeMap[type];\n        var stride = typeInfo.size * numComponents;\n        var normalize = b.normalize || false;\n        var offset = b.offset || 0;\n        var rowOffset = stride / count;\n        for (var i = 0; i < count; ++i) {\n          gl.enableVertexAttribArray(index + i);\n          gl.vertexAttribPointer(\n              index + i, size, type, normalize, stride, offset + rowOffset * i);\n        }\n      };\n    }\n\n    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n    for (var ii = 0; ii < numAttribs; ++ii) {\n      var attribInfo = gl.getActiveAttrib(program, ii);\n      if (!attribInfo) {\n        break;\n      }\n      var index = gl.getAttribLocation(program, attribInfo.name);\n      var typeInfo = attrTypeMap[attribInfo.type];\n      if (typeInfo) {\n        attribSetters[attribInfo.name] = createMatAttribSetter(index, typeInfo);\n      } else {\n        attribSetters[attribInfo.name] = createAttribSetter(index);\n      }\n    }\n\n    return attribSetters;\n  }\n\n  /**\n   * Sets attributes and binds buffers (deprecated... use {@link module:twgl.setBuffersAndAttributes})\n   *\n   * Example:\n   *\n   *     var program = createProgramFromScripts(\n   *         gl, [\"some-vs\", \"some-fs\");\n   *\n   *     var attribSetters = createAttributeSetters(program);\n   *\n   *     var positionBuffer = gl.createBuffer();\n   *     var texcoordBuffer = gl.createBuffer();\n   *\n   *     var attribs = {\n   *       a_position: {buffer: positionBuffer, numComponents: 3},\n   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n   *     };\n   *\n   *     gl.useProgram(program);\n   *\n   * This will automatically bind the buffers AND set the\n   * attributes.\n   *\n   *     setAttributes(attribSetters, attribs);\n   *\n   * Properties of attribs. For each attrib you can add\n   * properties:\n   *\n   * *   type: the type of data in the buffer. Default = gl.FLOAT\n   * *   normalize: whether or not to normalize the data. Default = false\n   * *   stride: the stride. Default = 0\n   * *   offset: offset into the buffer. Default = 0\n   *\n   * For example if you had 3 value float positions, 2 value\n   * float texcoord and 4 value uint8 colors you'd setup your\n   * attribs like this\n   *\n   *     var attribs = {\n   *       a_position: {buffer: positionBuffer, numComponents: 3},\n   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n   *       a_color: {\n   *         buffer: colorBuffer,\n   *         numComponents: 4,\n   *         type: gl.UNSIGNED_BYTE,\n   *         normalize: true,\n   *       },\n   *     };\n   *\n   * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters\n   * @param {Object.<string, module:twgl.AttribInfo>} buffers AttribInfos mapped by attribute name.\n   * @memberOf module:twgl/programs\n   * @deprecated use {@link module:twgl.setBuffersAndAttributes}\n   */\n  function setAttributes(setters, buffers) {\n    for (var name in buffers) {\n      var setter = setters[name];\n      if (setter) {\n        setter(buffers[name]);\n      }\n    }\n  }\n\n  /**\n   * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate\n   *\n   * Example:\n   *\n   *     var programInfo = createProgramInfo(\n   *         gl, [\"some-vs\", \"some-fs\");\n   *\n   *     var arrays = {\n   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n   *     };\n   *\n   *     var bufferInfo = createBufferInfoFromArrays(gl, arrays);\n   *\n   *     gl.useProgram(programInfo.program);\n   *\n   * This will automatically bind the buffers AND set the\n   * attributes.\n   *\n   *     setBuffersAndAttributes(gl, programInfo, bufferInfo);\n   *\n   * For the example above it is equivilent to\n   *\n   *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n   *     gl.enableVertexAttribArray(a_positionLocation);\n   *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);\n   *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n   *     gl.enableVertexAttribArray(a_texcoordLocation);\n   *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n   * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters A `ProgramInfo` as returned from {@link module:twgl.createProgrmaInfo} or Attribute setters as returned from {@link module:twgl.createAttributeSetters}\n   * @param {(module:twgl.BufferInfo|module:twgl.vertexArrayInfo)} buffers a `BufferInfo` as returned from {@link module:twgl.createBufferInfoFromArrays}.\n   *   or a `VertexArrayInfo` as returned from {@link module:twgl.createVertexArrayInfo}\n   * @memberOf module:twgl/programs\n   */\n  function setBuffersAndAttributes(gl, programInfo, buffers) {\n    if (buffers.vertexArrayObject) {\n      gl.bindVertexArray(buffers.vertexArrayObject);\n    } else {\n      setAttributes(programInfo.attribSetters || programInfo, buffers.attribs);\n      if (buffers.indices) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\n      }\n    }\n  }\n\n  /**\n   * @typedef {Object} ProgramInfo\n   * @property {WebGLProgram} program A shader program\n   * @property {Object<string, function>} uniformSetters object of setters as returned from createUniformSetters,\n   * @property {Object<string, function>} attribSetters object of setters as returned from createAttribSetters,\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Creates a ProgramInfo from an existing program.\n   *\n   * A ProgramInfo contains\n   *\n   *     programInfo = {\n   *        program: WebGLProgram,\n   *        uniformSetters: object of setters as returned from createUniformSetters,\n   *        attribSetters: object of setters as returned from createAttribSetters,\n   *     }\n   *\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n   *        to use.\n   * @param {WebGLProgram} program an existing WebGLProgram.\n   * @return {module:twgl.ProgramInfo} The created ProgramInfo.\n   * @memberOf module:twgl/programs\n   */\n  function createProgramInfoFromProgram(gl, program) {\n    var uniformSetters = createUniformSetters(gl, program);\n    var attribSetters = createAttributeSetters(gl, program);\n    var programInfo = {\n      program: program,\n      uniformSetters: uniformSetters,\n      attribSetters: attribSetters,\n    };\n\n    if (utils.isWebGL2(gl)) {\n      programInfo.uniformBlockSpec = createUniformBlockSpecFromProgram(gl, program);\n    }\n\n    return programInfo;\n  }\n\n  /**\n   * Creates a ProgramInfo from 2 sources.\n   *\n   * A ProgramInfo contains\n   *\n   *     programInfo = {\n   *        program: WebGLProgram,\n   *        uniformSetters: object of setters as returned from createUniformSetters,\n   *        attribSetters: object of setters as returned from createAttribSetters,\n   *     }\n   *\n   * NOTE: There are 3 signatures for this function\n   *\n   *     twgl.createProgramInfo(gl, [vs, fs], opt_errFunc);\n   *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_errFunc);\n   *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n   *\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n   *        to use.\n   * @param {string[]} shaderSourcess Array of sources for the\n   *        shaders or ids. The first is assumed to be the vertex shader,\n   *        the second the fragment shader.\n   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n   * @param {number[]} [opt_locations] The locations for the attributes. A parallel array to opt_attribs letting you assign locations.\n   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n   *        on error. If you want something else pass an callback. It's passed an error message.\n   * @return {module:twgl.ProgramInfo?} The created ProgramInfo or null if it failed to link or compile\n   * @memberOf module:twgl/programs\n   */\n  function createProgramInfo(\n      gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n    if (typeof opt_locations === 'function') {\n      opt_errorCallback = opt_locations;\n      opt_locations = undefined;\n    }\n    if (typeof opt_attribs === 'function') {\n      opt_errorCallback = opt_attribs;\n      opt_attribs = undefined;\n    }\n    var errFn = opt_errorCallback || error;\n    var good = true;\n    shaderSources = shaderSources.map(function(source) {\n      // Lets assume if there is no \\n it's an id\n      if (source.indexOf(\"\\n\") < 0) {\n        var script = document.getElementById(source);\n        if (!script) {\n          errFn(\"no element with id: \" + source);\n          good = false;\n        } else {\n          source = script.text;\n        }\n      }\n      return source;\n    });\n    if (!good) {\n      return null;\n    }\n    var program = createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback);\n    if (!program) {\n      return null;\n    }\n    return createProgramInfoFromProgram(gl, program);\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  // No speed diff AFAICT.\n  return {\n    \"createAttributeSetters\": createAttributeSetters,\n\n    \"createProgram\": createProgram,\n    \"createProgramFromScripts\": createProgramFromScripts,\n    \"createProgramFromSources\": createProgramFromSources,\n    \"createProgramInfo\": createProgramInfo,\n    \"createProgramInfoFromProgram\": createProgramInfoFromProgram,\n    \"createUniformSetters\": createUniformSetters,\n    \"createUniformBlockSpecFromProgram\": createUniformBlockSpecFromProgram,\n    \"createUniformBlockInfoFromProgram\": createUniformBlockInfoFromProgram,\n    \"createUniformBlockInfo\": createUniformBlockInfo,\n\n    \"setAttributes\": setAttributes,\n    \"setBuffersAndAttributes\": setBuffersAndAttributes,\n    \"setUniforms\": setUniforms,\n    \"setUniformBlock\": setUniformBlock,\n    \"setBlockUniforms\": setBlockUniforms,\n    \"bindUniformBlock\": bindUniformBlock,\n  };\n\n});\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/draw',[\n    './programs',\n  ], function(\n    programs) {\n  \n\n  /**\n   * Drawing related functions\n   *\n   * For backward compatibily they are available at both `twgl.draw` and `twgl`\n   * itself\n   *\n   * See {@link module:twgl} for core functions\n   *\n   * @module twgl/draw\n   */\n\n  /**\n   * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate\n   *\n   * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself\n   * but calling this means if you switch from indexed data to non-indexed\n   * data you don't have to remember to update your draw call.\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} bufferInfo A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays} or\n   *   a VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}\n   * @param {enum} [type] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...). Defaults to `gl.TRIANGLES`\n   * @param {number} [count] An optional count. Defaults to bufferInfo.numElements\n   * @param {number} [offset] An optional offset. Defaults to 0.\n   * @memberOf module:twgl/draw\n   */\n  function drawBufferInfo(gl, bufferInfo, type, count, offset) {\n    type = type === undefined ? gl.TRIANGLES : type;\n    var indices = bufferInfo.indices;\n    var elementType = bufferInfo.elementType;\n    var numElements = count === undefined ? bufferInfo.numElements : count;\n    offset = offset === undefined ? 0 : offset;\n    if (elementType || indices) {\n      gl.drawElements(type, numElements, elementType === undefined ? gl.UNSIGNED_SHORT : bufferInfo.elementType, offset);\n    } else {\n      gl.drawArrays(type, offset, numElements);\n    }\n  }\n\n  /**\n   * A DrawObject is useful for putting objects in to an array and passing them to {@link module:twgl.drawObjectList}.\n   *\n   * You need either a `BufferInfo` or a `VertexArrayInfo`.\n   *\n   * @typedef {Object} DrawObject\n   * @property {boolean} [active] whether or not to draw. Default = `true` (must be `false` to be not true). In otherwords `undefined` = `true`\n   * @property {number} [type] type to draw eg. `gl.TRIANGLES`, `gl.LINES`, etc...\n   * @property {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}\n   * @property {module:twgl.BufferInfo} [bufferInfo] A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays}\n   * @property {module:twgl.VertexArrayInfo} [vertexArrayInfo] A VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}\n   * @property {Object<string, ?>} uniforms The values for the uniforms.\n   *   You can pass multiple objects by putting them in an array. For example\n   *\n   *     var sharedUniforms = {\n   *       u_fogNear: 10,\n   *       u_projection: ...\n   *       ...\n   *     };\n   *\n   *     var localUniforms = {\n   *       u_world: ...\n   *       u_diffuseColor: ...\n   *     };\n   *\n   *     var drawObj = {\n   *       ...\n   *       uniforms: [sharedUniforms, localUniforms],\n   *     };\n   *\n   * @property {number} [offset] the offset to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to 0.\n   * @property {number} [count] the count to pass to `gl.drawArrays` or `gl.drawElemnts`. Defaults to bufferInfo.numElements.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Draws a list of objects\n   * @param {DrawObject[]} objectsToDraw an array of objects to draw.\n   * @memberOf module:twgl/draw\n   */\n  function drawObjectList(gl, objectsToDraw) {\n    var lastUsedProgramInfo = null;\n    var lastUsedBufferInfo = null;\n\n    objectsToDraw.forEach(function(object) {\n      if (object.active === false) {\n        return;\n      }\n\n      var programInfo = object.programInfo;\n      var bufferInfo = object.vertexArrayInfo || object.bufferInfo;\n      var bindBuffers = false;\n      var type = object.type === undefined ? gl.TRIANGLES : object.type;\n\n      if (programInfo !== lastUsedProgramInfo) {\n        lastUsedProgramInfo = programInfo;\n        gl.useProgram(programInfo.program);\n\n        // We have to rebind buffers when changing programs because we\n        // only bind buffers the program uses. So if 2 programs use the same\n        // bufferInfo but the 1st one uses only positions the when the\n        // we switch to the 2nd one some of the attributes will not be on.\n        bindBuffers = true;\n      }\n\n      // Setup all the needed attributes.\n      if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {\n        if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject && !bufferInfo.vertexArrayObject) {\n          gl.bindVertexArray(null);\n        }\n        lastUsedBufferInfo = bufferInfo;\n        programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n      }\n\n      // Set the uniforms.\n      programs.setUniforms(programInfo, object.uniforms);\n\n      // Draw\n      drawBufferInfo(gl, bufferInfo, type, object.count, object.offset);\n    });\n\n    if (lastUsedBufferInfo.vertexArrayObject) {\n      gl.bindVertexArray(null);\n    }\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  // No speed diff AFAICT.\n  return {\n    \"drawBufferInfo\": drawBufferInfo,\n    \"drawObjectList\": drawObjectList,\n  };\n\n});\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/textures',[\n    './typedarrays',\n    './utils',\n  ], function(\n    typedArrays,\n    utils) {\n  \n\n  /**\n   * Low level texture related functions\n   *\n   * You should generally not need to use these functions. They are provided\n   * for those cases where you're doing something out of the ordinary\n   * and you need lower level access.\n   *\n   * For backward compatibily they are available at both `twgl.textures` and `twgl`\n   * itself\n   *\n   * See {@link module:twgl} for core functions\n   *\n   * @module twgl/textures\n   */\n\n  // make sure we don't see a global gl\n  var gl = undefined;  // eslint-disable-line\n  var defaults = {\n    textureColor: new Uint8Array([128, 192, 255, 255]),\n    textureOptions: {},\n    crossOrigin: undefined,\n  };\n  var isArrayBuffer = typedArrays.isArrayBuffer;\n\n  /* PixelFormat */\n  var ALPHA                          = 0x1906;\n  var RGB                            = 0x1907;\n  var RGBA                           = 0x1908;\n  var LUMINANCE                      = 0x1909;\n  var LUMINANCE_ALPHA                = 0x190A;\n\n  /* TextureWrapMode */\n  var REPEAT                         = 0x2901;  // eslint-disable-line\n  var MIRRORED_REPEAT                = 0x8370;  // eslint-disable-line\n\n  /* TextureMagFilter */\n  var NEAREST                        = 0x2600;  // eslint-disable-line\n\n  /* TextureMinFilter */\n  var NEAREST_MIPMAP_NEAREST         = 0x2700;  // eslint-disable-line\n  var LINEAR_MIPMAP_NEAREST          = 0x2701;  // eslint-disable-line\n  var NEAREST_MIPMAP_LINEAR          = 0x2702;  // eslint-disable-line\n  var LINEAR_MIPMAP_LINEAR           = 0x2703;  // eslint-disable-line\n\n  /**\n   * Sets the default texture color.\n   *\n   * The default texture color is used when loading textures from\n   * urls. Because the URL will be loaded async we'd like to be\n   * able to use the texture immediately. By putting a 1x1 pixel\n   * color in the texture we can start using the texture before\n   * the URL has loaded.\n   *\n   * @param {number[]} color Array of 4 values in the range 0 to 1\n   * @deprecated see {@link module:twgl.setDefaults}\n   * @memberOf module:twgl/textures\n   */\n  function setDefaultTextureColor(color) {\n    defaults.textureColor = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);\n  }\n\n  function setDefaults(newDefaults) {\n    utils.copyExistingProperties(newDefaults, defaults);\n    if (newDefaults.textureColor) {\n      setDefaultTextureColor(newDefaults.textureColor);\n    }\n  }\n\n  /**\n   * Gets a string for gl enum\n   *\n   * Note: Several enums are the same. Without more\n   * context (which function) it's impossible to always\n   * give the correct enum.\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @param {number} value the value of the enum you want to look up.\n   */\n  var glEnumToString = (function() {\n    var enums;\n\n    function init(gl) {\n      if (!enums) {\n        enums = {};\n        Object.keys(gl).forEach(function(key) {\n          if (typeof gl[key] === 'number') {\n            enums[gl[key]] = key;\n          }\n        });\n      }\n    }\n\n    return function glEnumToString(gl, value) {\n      init();\n      return enums[value] || (\"0x\" + value.toString(16));\n    };\n  }());\n\n  /**\n   * A function to generate the source for a texture.\n   * @callback TextureFunc\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @param {module:twgl.TextureOptions} options the texture options\n   * @return {*} Returns any of the things documentented for `src` for {@link module:twgl.TextureOptions}.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Texture options passed to most texture functions. Each function will use whatever options\n   * are appropriate for its needs. This lets you pass the same options to all functions.\n   *\n   * @typedef {Object} TextureOptions\n   * @property {number} [target] the type of texture `gl.TEXTURE_2D` or `gl.TEXTURE_CUBE_MAP`. Defaults to `gl.TEXTURE_2D`.\n   * @property {number} [width] the width of the texture. Only used if src is an array or typed array or null.\n   * @property {number} [height] the height of a texture. Only used if src is an array or typed array or null.\n   * @property {number} [depth] the depth of a texture. Only used if src is an array or type array or null and target is `TEXTURE_3D` .\n   * @property {number} [min] the min filter setting (eg. `gl.LINEAR`). Defaults to `gl.NEAREST_MIPMAP_LINEAR`\n   *     or if texture is not a power of 2 on both dimensions then defaults to `gl.LINEAR`.\n   * @property {number} [mag] the mag filter setting (eg. `gl.LINEAR`). Defaults to `gl.LINEAR`\n   * @property {number} [internalFormat] internal format for texture. Defaults to `gl.RGBA`\n   * @property {number} [format] format for texture. Defaults to `gl.RGBA`.\n   * @property {number} [type] type for texture. Defaults to `gl.UNSIGNED_BYTE` unless `src` is ArrayBuffer. If `src`\n   *     is ArrayBuffer defaults to type that matches ArrayBuffer type.\n   * @property {number} [wrap] Texture wrapping for both S and T (and R if TEXTURE_3D). Defaults to `gl.REPEAT` for 2D unless src is WebGL1 and src not npot and `gl.CLAMP_TO_EDGE` for cube\n   * @property {number} [wrapS] Texture wrapping for S. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n   * @property {number} [wrapT] Texture wrapping for T. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n   * @property {number} [wrapR] Texture wrapping for R. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n   * @property {number} [minLod] TEXTURE_MIN_LOD setting\n   * @property {number} [maxLod] TEXTURE_MAX_LOD setting\n   * @property {number} [baseLevel] TEXTURE_BASE_LEVEL setting\n   * @property {number} [maxLevel] TEXTURE_MAX_LEVEL setting\n   * @property {number} [unpackAlignment] The `gl.UNPACK_ALIGNMENT` used when uploading an array. Defaults to 1.\n   * @property {number} [premultiplyAlpha] Whether or not to premultiply alpha. Defaults to whatever the current setting is.\n   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n   *     the current setting for specific textures.\n   * @property {number} [flipY] Whether or not to flip the texture vertically on upload. Defaults to whatever the current setting is.\n   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n   *     the current setting for specific textures.\n   * @property {number} [colorspaceConversion] Whether or not to let the browser do colorspace conversion of the texture on upload. Defaults to whatever the current setting is.\n   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n   *     the current setting for specific textures.\n   * @property {(number[]|ArrayBuffer)} color color used as temporary 1x1 pixel color for textures loaded async when src is a string.\n   *    If it's a JavaScript array assumes color is 0 to 1 like most GL colors as in `[1, 0, 0, 1] = red=1, green=0, blue=0, alpha=0`.\n   *    Defaults to `[0.5, 0.75, 1, 1]`. See {@link module:twgl.setDefaultTextureColor}. If `false` texture is set. Can be used to re-load a texture\n   * @property {boolean} [auto] If not `false` then texture working filtering is set automatically for non-power of 2 images and\n   *    mips are generated for power of 2 images.\n   * @property {number[]} [cubeFaceOrder] The order that cube faces are pulled out of an img or set of images. The default is\n   *\n   *     [gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n   *      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n   *      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]\n   *\n   * @property {(number[]|ArrayBuffer|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement|string|string[]|module:twgl.TextureFunc)} [src] source for texture\n   *\n   *    If `string` then it's assumed to be a URL to an image. The image will be downloaded async. A usable\n   *    1x1 pixel texture will be returned immediatley. The texture will be updated once the image has downloaded.\n   *    If `target` is `gl.TEXTURE_CUBE_MAP` will attempt to divide image into 6 square pieces. 1x6, 6x1, 3x2, 2x3.\n   *    The pieces will be uploaded in `cubeFaceOrder`\n   *\n   *    If `string[]` then it must have 6 entries, one for each face of a cube map. Target must be `gl.TEXTURE_CUBE_MAP`.\n   *\n   *    If `HTMLElement` then it wil be used immediately to create the contents of the texture. Examples `HTMLImageElement`,\n   *    `HTMLCanvasElement`, `HTMLVideoElement`.\n   *\n   *    If `number[]` or `ArrayBuffer` it's assumed to be data for a texture. If `width` or `height` is\n   *    not specified it is guessed as follows. First the number of elements is computed by `src.length / numComponets`\n   *    where `numComponents` is derived from `format`. If `target` is `gl.TEXTURE_CUBE_MAP` then `numElements` is divided\n   *    by 6. Then\n   *\n   *    *   If neither `width` nor `height` are specified and `sqrt(numElements)` is an integer then width and height\n   *        are set to `sqrt(numElements)`. Otherwise `width = numElements` and `height = 1`.\n   *\n   *    *   If only one of `width` or `height` is specified then the other equals `numElements / specifiedDimension`.\n   *\n   * If `number[]` will be converted to `type`.\n   *\n   * If `src` is a function it will be called with a `WebGLRenderingContext` and these options.\n   * Whatever it returns is subject to these rules. So it can return a string url, an `HTMLElement`\n   * an array etc...\n   *\n   * If `src` is undefined then an empty texture will be created of size `width` by `height`.\n   *\n   * @property {string} [crossOrigin] What to set the crossOrigin property of images when they are downloaded.\n   *    default: undefined. Also see {@link module:twgl.setDefaults}.\n   *\n   * @memberOf module:twgl\n   */\n\n  // NOTE: While querying GL is considered slow it's not remotely as slow\n  // as uploading a texture. On top of that you're unlikely to call this in\n  // a perf critical loop. Even if upload a texture every frame that's unlikely\n  // to be more than 1 or 2 textures a frame. In other words, the benefits of\n  // making the API easy to use outweigh any supposed perf benefits\n  var lastPackState = {};\n\n  /**\n   * Saves any packing state that will be set based on the options.\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   */\n  function savePackState(gl, options) {\n    if (options.colorspaceConversion !== undefined) {\n      lastPackState.colorspaceConversion = gl.getParameter(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL);\n      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, options.colorspaceConversion);\n    }\n    if (options.premultiplyAlpha !== undefined) {\n      lastPackState.premultiplyAlpha = gl.getParameter(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL);\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlpha);\n    }\n    if (options.flipY !== undefined) {\n      lastPackState.flipY = gl.getParameter(gl.UNPACK_FLIP_Y_WEBGL);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, options.flipY);\n    }\n  }\n\n  /**\n   * Restores any packing state that was set based on the options.\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   */\n  function restorePackState(gl, options) {\n    if (options.colorspaceConversion !== undefined) {\n      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, lastPackState.colorspaceConversion);\n    }\n    if (options.premultiplyAlpha !== undefined) {\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, lastPackState.premultiplyAlpha);\n    }\n    if (options.flipY !== undefined) {\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, lastPackState.flipY);\n    }\n  }\n\n  /**\n   * Sets the texture parameters of a texture.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   *   This is often the same options you passed in when you created the texture.\n   * @memberOf module:twgl/textures\n   */\n  function setTextureParameters(gl, tex, options) {\n    var target = options.target || gl.TEXTURE_2D;\n    gl.bindTexture(target, tex);\n    if (options.min) {\n      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, options.min);\n    }\n    if (options.mag) {\n      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, options.mag);\n    }\n    if (options.wrap) {\n      gl.texParameteri(target, gl.TEXTURE_WRAP_S, options.wrap);\n      gl.texParameteri(target, gl.TEXTURE_WRAP_T, options.wrap);\n      if (target === gl.TEXTURE_3D) {\n        gl.texParameteri(target, gl.TEXTURE_WRAP_R, options.wrap);\n      }\n    }\n    if (options.wrapR) {\n      gl.texParameteri(target, gl.TEXTURE_WRAP_R, options.wrapR);\n    }\n    if (options.wrapS) {\n      gl.texParameteri(target, gl.TEXTURE_WRAP_S, options.wrapS);\n    }\n    if (options.wrapT) {\n      gl.texParameteri(target, gl.TEXTURE_WRAP_T, options.wrapT);\n    }\n    if (options.minLod) {\n      gl.texParameteri(target, gl.TEXTURE_MIN_LOD, options.minLod);\n    }\n    if (options.maxLod) {\n      gl.texParameteri(target, gl.TEXTURE_MAX_LOD, options.maxLod);\n    }\n    if (options.baseLevel) {\n      gl.texParameteri(target, gl.TEXTURE_BASE_LEVEL, options.baseLevel);\n    }\n    if (options.maxLevel) {\n      gl.texParameteri(target, gl.TEXTURE_MAX_LEVEL, options.maxLevel);\n    }\n  }\n\n  /**\n   * Makes a 1x1 pixel\n   * If no color is passed in uses the default color which can be set by calling `setDefaultTextureColor`.\n   * @param {(number[]|ArrayBuffer)} [color] The color using 0-1 values\n   * @return {Uint8Array} Unit8Array with color.\n   */\n  function make1Pixel(color) {\n    color = color || defaults.textureColor;\n    if (isArrayBuffer(color)) {\n      return color;\n    }\n    return new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);\n  }\n\n  /**\n   * Returns true if value is power of 2\n   * @param {number} value number to check.\n   * @return true if value is power of 2\n   */\n  function isPowerOf2(value) {\n    return (value & (value - 1)) === 0;\n  }\n\n  /**\n   * Sets filtering or generates mips for texture based on width or height\n   * If width or height is not passed in uses `options.width` and//or `options.height`\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n   *   This is often the same options you passed in when you created the texture.\n   * @param {number} [width] width of texture\n   * @param {number} [height] height of texture\n   * @memberOf module:twgl/textures\n   */\n  function setTextureFilteringForSize(gl, tex, options, width, height) {\n    options = options || defaults.textureOptions;\n    var target = options.target || gl.TEXTURE_2D;\n    width = width || options.width;\n    height = height || options.height;\n    gl.bindTexture(target, tex);\n    if (!isPowerOf2(width) || !isPowerOf2(height)) {\n      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    } else {\n      gl.generateMipmap(target);\n    }\n  }\n\n  /**\n   * Gets an array of cubemap face enums\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   *   This is often the same options you passed in when you created the texture.\n   * @return {number[]} cubemap face enums\n   */\n  function getCubeFaceOrder(gl, options) {\n    options = options || {};\n    return options.cubeFaceOrder || [\n        gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n        gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n        gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n        gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n        gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n        gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\n      ];\n  }\n\n  /**\n   * @typedef {Object} FaceInfo\n   * @property {number} face gl enum for texImage2D\n   * @property {number} ndx face index (0 - 5) into source data\n   * @ignore\n   */\n\n  /**\n   * Gets an array of FaceInfos\n   * There's a bug in some NVidia drivers that will crash the driver if\n   * `gl.TEXTURE_CUBE_MAP_POSITIVE_X` is not uploaded first. So, we take\n   * the user's desired order from his faces to WebGL and make sure we\n   * do the faces in WebGL order\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   * @return {FaceInfo[]} cubemap face infos. Arguably the `face` property of each element is redundent but\n   *    it's needed internally to sort the array of `ndx` properties by `face`.\n   */\n  function getCubeFacesWithNdx(gl, options) {\n    var faces = getCubeFaceOrder(gl, options);\n    // work around bug in NVidia drivers. We have to upload the first face first else the driver crashes :(\n    var facesWithNdx = faces.map(function(face, ndx) {\n      return { face: face, ndx: ndx };\n    });\n    facesWithNdx.sort(function(a, b) {\n      return a.face - b.face;\n    });\n    return facesWithNdx;\n  }\n\n  /**\n   * Set a texture from the contents of an element. Will also set\n   * texture filtering or generate mips based on the dimensions of the element\n   * unless `options.auto === false`. If `target === gl.TEXTURE_CUBE_MAP` will\n   * attempt to slice image into 1x6, 2x3, 3x2, or 6x1 images, one for each face.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {HTMLElement} element a canvas, img, or video element.\n   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n   *   This is often the same options you passed in when you created the texture.\n   * @memberOf module:twgl/textures\n   * @kind function\n   */\n  var setTextureFromElement = function() {\n    var ctx = document.createElement(\"canvas\").getContext(\"2d\");\n    return function setTextureFromElement(gl, tex, element, options) {\n      options = options || defaults.textureOptions;\n      var target = options.target || gl.TEXTURE_2D;\n      var width = element.width;\n      var height = element.height;\n      var format = options.format || gl.RGBA;\n      var internalFormat = options.internalFormat || format;\n      var type = options.type || gl.UNSIGNED_BYTE;\n      savePackState(gl, options);\n      gl.bindTexture(target, tex);\n      if (target === gl.TEXTURE_CUBE_MAP) {\n        // guess the parts\n        var imgWidth  = element.width;\n        var imgHeight = element.height;\n        var size;\n        var slices;\n        if (imgWidth / 6 === imgHeight) {\n          // It's 6x1\n          size = imgHeight;\n          slices = [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0];\n        } else if (imgHeight / 6 === imgWidth) {\n          // It's 1x6\n          size = imgWidth;\n          slices = [0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5];\n        } else if (imgWidth / 3 === imgHeight / 2) {\n          // It's 3x2\n          size = imgWidth / 3;\n          slices = [0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1];\n        } else if (imgWidth / 2 === imgHeight / 3) {\n          // It's 2x3\n          size = imgWidth / 2;\n          slices = [0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2];\n        } else {\n          throw \"can't figure out cube map from element: \" + (element.src ? element.src : element.nodeName);\n        }\n        ctx.canvas.width = size;\n        ctx.canvas.height = size;\n        width = size;\n        height = size;\n        getCubeFacesWithNdx(gl, options).forEach(function(f) {\n          var xOffset = slices[f.ndx * 2 + 0] * size;\n          var yOffset = slices[f.ndx * 2 + 1] * size;\n          ctx.drawImage(element, xOffset, yOffset, size, size, 0, 0, size, size);\n          gl.texImage2D(f.face, 0, internalFormat, format, type, ctx.canvas);\n        });\n        // Free up the canvas memory\n        ctx.canvas.width = 1;\n        ctx.canvas.height = 1;\n      } else if (target === gl.TEXTURE_3D) {\n        var smallest = Math.min(element.width, element.height);\n        var largest = Math.max(element.width, element.height);\n        var depth = largest / smallest;\n        if (depth % 1 !== 0) {\n          throw \"can not compute 3D dimensions of element\";\n        }\n        var xMult = element.width  === largest ? 1 : 0;\n        var yMult = element.height === largest ? 1 : 0;\n        gl.texImage3D(target, 0, internalFormat, smallest, smallest, smallest, 0, format, type, null);\n        // remove this is texSubImage3D gets width and height arguments\n        ctx.canvas.width = smallest;\n        ctx.canvas.height = smallest;\n        for (var d = 0; d < depth; ++d) {\n//          gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, d * smallest);\n//          gl.texSubImage3D(target, 0, 0, 0, d, format, type, element);\n            var srcX = d * smallest * xMult;\n            var srcY = d * smallest * yMult;\n            var srcW = smallest;\n            var srcH = smallest;\n            var dstX = 0;\n            var dstY = 0;\n            var dstW = smallest;\n            var dstH = smallest;\n            ctx.drawImage(element, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);\n            gl.texSubImage3D(target, 0, 0, 0, d, format, type, ctx.canvas);\n        }\n        ctx.canvas.width = 0;\n        ctx.canvas.height = 0;\n// FIX (save state)\n//        gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, 0);\n      } else {\n        gl.texImage2D(target, 0, internalFormat, format, type, element);\n      }\n      restorePackState(gl, options);\n      if (options.auto !== false) {\n        setTextureFilteringForSize(gl, tex, options, width, height);\n      }\n      setTextureParameters(gl, tex, options);\n    };\n  }();\n\n  function noop() {\n  }\n\n  /**\n   * Loads an image\n   * @param {string} url url to image\n   * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null\n   *     if there was an error\n   * @return {HTMLImageElement} the image being loaded.\n   */\n  function loadImage(url, crossOrigin, callback) {\n    callback = callback || noop;\n    var img = new Image();\n    crossOrigin = crossOrigin !== undefined ? crossOrigin : defaults.crossOrigin;\n    if (crossOrigin !== undefined) {\n      img.crossOrigin = crossOrigin;\n    }\n\n    function clearEventHandlers() {\n      img.removeEventListener('error', onError);  // eslint-disable-line\n      img.removeEventListener('load', onLoad);  // eslint-disable-line\n      img = null;\n    }\n\n    function onError() {\n      var msg = \"couldn't load image: \" + url;\n      utils.error(msg);\n      callback(msg, img);\n      clearEventHandlers();\n    }\n\n    function onLoad() {\n      callback(null, img);\n      clearEventHandlers();\n    }\n\n    img.addEventListener('error', onError);\n    img.addEventListener('load', onLoad);\n    img.src = url;\n    return img;\n  }\n\n  /**\n   * Sets a texture to a 1x1 pixel color. If `options.color === false` is nothing happens. If it's not set\n   * the default texture color is used which can be set by calling `setDefaultTextureColor`.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n   *   This is often the same options you passed in when you created the texture.\n   * @memberOf module:twgl/textures\n   */\n  function setTextureTo1PixelColor(gl, tex, options) {\n    options = options || defaults.textureOptions;\n    var target = options.target || gl.TEXTURE_2D;\n    gl.bindTexture(target, tex);\n    if (options.color === false) {\n      return;\n    }\n    // Assume it's a URL\n    // Put 1x1 pixels in texture. That makes it renderable immediately regardless of filtering.\n    var color = make1Pixel(options.color);\n    if (target === gl.TEXTURE_CUBE_MAP) {\n      for (var ii = 0; ii < 6; ++ii) {\n        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n      }\n    } else if (target === gl.TEXTURE_3D) {\n      gl.texImage3D(target, 0, gl.RGBA, 1, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n    } else {\n      gl.texImage2D(target, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n    }\n  }\n\n  /**\n   * The src image(s) used to create a texture.\n   *\n   * When you call {@link module:twgl.createTexture} or {@link module:twgl.createTextures}\n   * you can pass in urls for images to load into the textures. If it's a single url\n   * then this will be a single HTMLImageElement. If it's an array of urls used for a cubemap\n   * this will be a corresponding array of images for the cubemap.\n   *\n   * @typedef {HTMLImageElement|HTMLImageElement[]} TextureSrc\n   * @memberOf module:twgl\n   */\n\n  /**\n   * A callback for when an image finished downloading and been uploaded into a texture\n   * @callback TextureReadyCallback\n   * @param {*} err If truthy there was an error.\n   * @param {WebGLTexture} texture the texture.\n   * @param {module:twgl.TextureSrc} souce image(s) used to as the src for the texture\n   * @memberOf module:twgl\n   */\n\n  /**\n   * A callback for when all images have finished downloading and been uploaded into their respective textures\n   * @callback TexturesReadyCallback\n   * @param {*} err If truthy there was an error.\n   * @param {Object.<string, WebGLTexture>} textures the created textures by name. Same as returned by {@link module:twgl.createTextures}.\n   * @param {Object.<string, module:twgl.TextureSrc>} sources the image(s) used for the texture by name.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * A callback for when an image finished downloading and been uploaded into a texture\n   * @callback CubemapReadyCallback\n   * @param {*} err If truthy there was an error.\n   * @param {WebGLTexture} tex the texture.\n   * @param {HTMLImageElement[]} imgs the images for each face.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Loads a texture from an image from a Url as specified in `options.src`\n   * If `options.color !== false` will set the texture to a 1x1 pixel color so that the texture is\n   * immediately useable. It will be updated with the contents of the image once the image has finished\n   * downloading. Filtering options will be set as approriate for image unless `options.auto === false`.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n   * @param {module:twgl.TextureReadyCallback} [callback] A function to be called when the image has finished loading. err will\n   *    be non null if there was an error.\n   * @return {HTMLImageElement} the image being downloaded.\n   * @memberOf module:twgl/textures\n   */\n  function loadTextureFromUrl(gl, tex, options, callback) {\n    callback = callback || noop;\n    options = options || defaults.textureOptions;\n    setTextureTo1PixelColor(gl, tex, options);\n    // Because it's async we need to copy the options.\n    options = utils.shallowCopy(options);\n    var img = loadImage(options.src, options.crossOrigin, function(err, img) {\n      if (err) {\n        callback(err, tex, img);\n      } else {\n        setTextureFromElement(gl, tex, img, options);\n        callback(null, tex, img);\n      }\n    });\n    return img;\n  }\n\n  /**\n   * Loads a cubemap from 6 urls as specified in `options.src`. Will set the cubemap to a 1x1 pixel color\n   * so that it is usable immediately unless `option.color === false`.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   * @param {module:twgl.CubemapReadyCallback} [callback] A function to be called when all the images have finished loading. err will\n   *    be non null if there was an error.\n   * @memberOf module:twgl/textures\n   */\n  function loadCubemapFromUrls(gl, tex, options, callback) {\n    callback = callback || noop;\n    var urls = options.src;\n    if (urls.length !== 6) {\n      throw \"there must be 6 urls for a cubemap\";\n    }\n    var format = options.format || gl.RGBA;\n    var type = options.type || gl.UNSIGNED_BYTE;\n    var target = options.target || gl.TEXTURE_2D;\n    if (target !== gl.TEXTURE_CUBE_MAP) {\n      throw \"target must be TEXTURE_CUBE_MAP\";\n    }\n    setTextureTo1PixelColor(gl, tex, options);\n    // Because it's async we need to copy the options.\n    options = utils.shallowCopy(options);\n    var numToLoad = 6;\n    var errors = [];\n    var imgs;\n    var faces = getCubeFaceOrder(gl, options);\n\n    function uploadImg(faceTarget) {\n      return function(err, img) {\n        --numToLoad;\n        if (err) {\n          errors.push(err);\n        } else {\n          if (img.width !== img.height) {\n            errors.push(\"cubemap face img is not a square: \" + img.src);\n          } else {\n            savePackState(gl, options);\n            gl.bindTexture(target, tex);\n\n            // So assuming this is the first image we now have one face that's img sized\n            // and 5 faces that are 1x1 pixel so size the other faces\n            if (numToLoad === 5) {\n              // use the default order\n              getCubeFaceOrder(gl).forEach(function(otherTarget) {\n                // Should we re-use the same face or a color?\n                gl.texImage2D(otherTarget, 0, format, format, type, img);\n              });\n            } else {\n              gl.texImage2D(faceTarget, 0, format, format, type, img);\n            }\n\n            restorePackState(gl, options);\n            gl.generateMipmap(target);\n          }\n        }\n\n        if (numToLoad === 0) {\n          callback(errors.length ? errors : undefined, imgs, tex);\n        }\n      };\n    }\n\n    imgs = urls.map(function(url, ndx) {\n      return loadImage(url, options.crossOrigin, uploadImg(faces[ndx]));\n    });\n  }\n\n  /**\n   * Gets the number of compontents for a given image format.\n   * @param {number} format the format.\n   * @return {number} the number of components for the format.\n   * @memberOf module:twgl/textures\n   */\n  function getNumComponentsForFormat(format) {\n    switch (format) {\n      case ALPHA:\n      case LUMINANCE:\n        return 1;\n      case LUMINANCE_ALPHA:\n        return 2;\n      case RGB:\n        return 3;\n      case RGBA:\n        return 4;\n      default:\n        throw \"unknown type: \" + format;\n    }\n  }\n\n  /**\n   * Gets the texture type for a given array type.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @return {number} the gl texture type\n   */\n  function getTextureTypeForArrayType(gl, src) {\n    if (isArrayBuffer(src)) {\n      return typedArrays.getGLTypeForTypedArray(src);\n    }\n    return gl.UNSIGNED_BYTE;\n  }\n\n  function guessDimensions(gl, target, width, height, numElements) {\n    if (numElements % 1 !== 0) {\n      throw \"can't guess dimensions\";\n    }\n    if (!width && !height) {\n      var size = Math.sqrt(numElements / (target === gl.TEXTURE_CUBE_MAP ? 6 : 1));\n      if (size % 1 === 0) {\n        width = size;\n        height = size;\n      } else {\n        width = numElements;\n        height = 1;\n      }\n    } else if (!height) {\n      height = numElements / width;\n      if (height % 1) {\n        throw \"can't guess dimensions\";\n      }\n    } else if (!width) {\n      width = numElements / height;\n      if (width % 1) {\n        throw \"can't guess dimensions\";\n      }\n    }\n    return {\n      width: width,\n      height: height,\n    };\n  }\n\n  /**\n   * Sets a texture from an array or typed array. If the width or height is not provided will attempt to\n   * guess the size. See {@link module:twgl.TextureOptions}.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {(number[]|ArrayBuffer)} src An array or typed arry with texture data.\n   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n   *   This is often the same options you passed in when you created the texture.\n   * @memberOf module:twgl/textures\n   */\n  function setTextureFromArray(gl, tex, src, options) {\n    options = options || defaults.textureOptions;\n    var target = options.target || gl.TEXTURE_2D;\n    gl.bindTexture(target, tex);\n    var width = options.width;\n    var height = options.height;\n    var depth = options.depth;\n    var format = options.format || gl.RGBA;\n    var internalFormat = options.internalFormat || format;\n    var type = options.type || getTextureTypeForArrayType(gl, src);\n    var numComponents = getNumComponentsForFormat(format);\n    var numElements = src.length / numComponents;\n    if (numElements % 1) {\n      throw \"length wrong size for format: \" + glEnumToString(gl, format);\n    }\n    var dimensions;\n    if (target === gl.TEXTURE_3D) {\n      if (!width && !height && !depth) {\n        var size = Math.cbrt(numElements);\n        if (size % 1 !== 0) {\n          throw \"can't guess cube size of array of numElements: \" + numElements;\n        }\n        width = size;\n        height = size;\n        depth = size;\n      } else if (width && (!height || !depth)) {\n        dimensions = guessDimensions(gl, target, height, depth, numElements / width);\n        height = dimensions.width;\n        depth = dimensions.height;\n      } else if (height && (!width || !depth)) {\n        dimensions = guessDimensions(gl, target, width, depth, numElements / height);\n        width = dimensions.width;\n        depth = dimensions.height;\n      } else {\n        dimensions = guessDimensions(gl, target, width, height, numElements / depth);\n        width = dimensions.width;\n        height = dimensions.height;\n      }\n    } else {\n      dimensions = guessDimensions(gl, target, width, height, numElements);\n      width = dimensions.width;\n      height = dimensions.height;\n    }\n    if (!isArrayBuffer(src)) {\n      var Type = typedArrays.getTypedArrayTypeForGLType(type);\n      src = new Type(src);\n    } else {\n      if (src instanceof Uint8ClampedArray) {\n        src = new Uint8Array(src.buffer);\n      }\n    }\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, options.unpackAlignment || 1);\n    savePackState(gl, options);\n    if (target === gl.TEXTURE_CUBE_MAP) {\n      var faceSize = numElements / 6 * numComponents;\n      getCubeFacesWithNdx(gl, options).forEach(function(f) {\n        var offset = faceSize * f.ndx;\n        var data = src.subarray(offset, offset + faceSize);\n        gl.texImage2D(f.face, 0, internalFormat, width, height, 0, format, type, data);\n      });\n    } else if (target === gl.TEXTURE_3D) {\n      gl.texImage3D(target, 0, internalFormat, width, height, depth, 0, format, type, src);\n    } else {\n      gl.texImage2D(target, 0, internalFormat, width, height, 0, format, type, src);\n    }\n    restorePackState(gl, options);\n    return {\n      width: width,\n      height: height,\n      depth: depth,\n    };\n  }\n\n  /**\n   * Sets a texture with no contents of a certain size. In other words calls `gl.texImage2D` with `null`.\n   * You must set `options.width` and `options.height`.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   * @memberOf module:twgl/textures\n   */\n  function setEmptyTexture(gl, tex, options) {\n    var target = options.target || gl.TEXTURE_2D;\n    gl.bindTexture(target, tex);\n    var format = options.format || gl.RGBA;\n    var internalFormat = options.internalFormat || format;\n    var type = options.type || gl.UNSIGNED_BYTE;\n    savePackState(gl, options);\n    if (target === gl.TEXTURE_CUBE_MAP) {\n      for (var ii = 0; ii < 6; ++ii) {\n        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, internalFormat, options.width, options.height, 0, format, type, null);\n      }\n    } else if (target === gl.TEXTURE_3D) {\n      gl.texImage3D(target, 0, internalFormat, options.width, options.height, options.depth, 0, format, type, null);\n    } else {\n      gl.texImage2D(target, 0, internalFormat, options.width, options.height, 0, format, type, null);\n    }\n    restorePackState(gl, options);\n  }\n\n  /**\n   * Creates a texture based on the options passed in.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n   * @param {module:twgl.TextureReadyCallback} [callback] A callback called when an image has been downloaded and uploaded to the texture.\n   * @return {WebGLTexture} the created texture.\n   * @memberOf module:twgl/textures\n   */\n  function createTexture(gl, options, callback) {\n    callback = callback || noop;\n    options = options || defaults.textureOptions;\n    var tex = gl.createTexture();\n    var target = options.target || gl.TEXTURE_2D;\n    var width  = options.width  || 1;\n    var height = options.height || 1;\n    gl.bindTexture(target, tex);\n    if (target === gl.TEXTURE_CUBE_MAP) {\n      // this should have been the default for CUBEMAPS :(\n      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    }\n    var src = options.src;\n    if (src) {\n      if (typeof src === \"function\") {\n        src = src(gl, options);\n      }\n      if (typeof (src) === \"string\") {\n        loadTextureFromUrl(gl, tex, options, callback);\n      } else if (isArrayBuffer(src) ||\n                 (Array.isArray(src) && (\n                      typeof src[0] === 'number' ||\n                      Array.isArray(src[0]) ||\n                      isArrayBuffer(src[0]))\n                 )\n                ) {\n        var dimensions = setTextureFromArray(gl, tex, src, options);\n        width  = dimensions.width;\n        height = dimensions.height;\n      } else if (Array.isArray(src) && typeof (src[0]) === 'string') {\n        loadCubemapFromUrls(gl, tex, options, callback);\n      } else if (src instanceof HTMLElement) {\n        setTextureFromElement(gl, tex, src, options);\n        width  = src.width;\n        height = src.height;\n      } else {\n        throw \"unsupported src type\";\n      }\n    } else {\n      setEmptyTexture(gl, tex, options);\n    }\n    if (options.auto !== false) {\n      setTextureFilteringForSize(gl, tex, options, width, height);\n    }\n    setTextureParameters(gl, tex, options);\n    return tex;\n  }\n\n  /**\n   * Resizes a texture based on the options passed in.\n   *\n   * Note: This is not a generic resize anything function.\n   * It's mostly used by {@link module:twgl.resizeFramebufferInfo}\n   * It will use `options.src` if it exists to try to determine a `type`\n   * otherwise it will assume `gl.UNSIGNED_BYTE`. No data is provided\n   * for the texture. Texture parameters will be set accordingly\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the texture to resize\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   * @param {number} [width] the new width. If not passed in will use `options.width`\n   * @param {number} [height] the new height. If not passed in will use `options.height`\n   * @memberOf module:twgl/textures\n   */\n  function resizeTexture(gl, tex, options, width, height) {\n    width = width || options.width;\n    height = height || options.height;\n    var target = options.target || gl.TEXTURE_2D;\n    gl.bindTexture(target, tex);\n    var format = options.format || gl.RGBA;\n    var type;\n    var src = options.src;\n    if (!src) {\n      type = options.type || gl.UNSIGNED_BYTE;\n    } else if (isArrayBuffer(src) || (Array.isArray(src) && typeof (src[0]) === 'number')) {\n      type = options.type || getTextureTypeForArrayType(gl, src);\n    } else {\n      type = options.type || gl.UNSIGNED_BYTE;\n    }\n    if (target === gl.TEXTURE_CUBE_MAP) {\n      for (var ii = 0; ii < 6; ++ii) {\n        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, format, width, height, 0, format, type, null);\n      }\n    } else {\n      gl.texImage2D(target, 0, format, width, height, 0, format, type, null);\n    }\n  }\n\n  /**\n   * Check if a src is an async request.\n   * if src is a string we're going to download an image\n   * if src is an array of strings we're going to download cubemap images\n   * @param {*} src The src from a TextureOptions\n   * @returns {bool} true if src is async.\n   */\n  function isAsyncSrc(src) {\n    return typeof src === 'string' ||\n           (Array.isArray(src) && typeof src[0] === 'string');\n  }\n\n  /**\n   * Creates a bunch of textures based on the passed in options.\n   *\n   * Example:\n   *\n   *     var textures = twgl.createTextures(gl, {\n   *       // a power of 2 image\n   *       hftIcon: { src: \"images/hft-icon-16.png\", mag: gl.NEAREST },\n   *       // a non-power of 2 image\n   *       clover: { src: \"images/clover.jpg\" },\n   *       // From a canvas\n   *       fromCanvas: { src: ctx.canvas },\n   *       // A cubemap from 6 images\n   *       yokohama: {\n   *         target: gl.TEXTURE_CUBE_MAP,\n   *         src: [\n   *           'images/yokohama/posx.jpg',\n   *           'images/yokohama/negx.jpg',\n   *           'images/yokohama/posy.jpg',\n   *           'images/yokohama/negy.jpg',\n   *           'images/yokohama/posz.jpg',\n   *           'images/yokohama/negz.jpg',\n   *         ],\n   *       },\n   *       // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)\n   *       goldengate: {\n   *         target: gl.TEXTURE_CUBE_MAP,\n   *         src: 'images/goldengate.jpg',\n   *       },\n   *       // A 2x2 pixel texture from a JavaScript array\n   *       checker: {\n   *         mag: gl.NEAREST,\n   *         min: gl.LINEAR,\n   *         src: [\n   *           255,255,255,255,\n   *           192,192,192,255,\n   *           192,192,192,255,\n   *           255,255,255,255,\n   *         ],\n   *       },\n   *       // a 1x2 pixel texture from a typed array.\n   *       stripe: {\n   *         mag: gl.NEAREST,\n   *         min: gl.LINEAR,\n   *         format: gl.LUMINANCE,\n   *         src: new Uint8Array([\n   *           255,\n   *           128,\n   *           255,\n   *           128,\n   *           255,\n   *           128,\n   *           255,\n   *           128,\n   *         ]),\n   *         width: 1,\n   *       },\n   *     });\n   *\n   * Now\n   *\n   * *   `textures.hftIcon` will be a 2d texture\n   * *   `textures.clover` will be a 2d texture\n   * *   `textures.fromCanvas` will be a 2d texture\n   * *   `textures.yohohama` will be a cubemap texture\n   * *   `textures.goldengate` will be a cubemap texture\n   * *   `textures.checker` will be a 2d texture\n   * *   `textures.stripe` will be a 2d texture\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per texture.\n   * @param {module:twgl.TexturesReadyCallback} [callback] A callback called when all textures have been downloaded.\n   * @return {Object.<string,WebGLTexture>} the created textures by name\n   * @memberOf module:twgl/textures\n   */\n  function createTextures(gl, textureOptions, callback) {\n    callback = callback || noop;\n    var numDownloading = 0;\n    var errors = [];\n    var textures = {};\n    var images = {};\n\n    function callCallbackIfReady() {\n      if (numDownloading === 0) {\n        setTimeout(function() {\n          callback(errors.length ? errors : undefined, textures, images);\n        }, 0);\n      }\n    }\n\n    Object.keys(textureOptions).forEach(function(name) {\n      var options = textureOptions[name];\n      var onLoadFn;\n      if (isAsyncSrc(options.src)) {\n        onLoadFn = function(err, tex, img) {\n          images[name] = img;\n          --numDownloading;\n          if (err) {\n            errors.push(err);\n          }\n          callCallbackIfReady();\n        };\n        ++numDownloading;\n      }\n      textures[name] = createTexture(gl, options, onLoadFn);\n    });\n\n    // queue the callback if there are no images to download.\n    // We do this because if your code is structured to wait for\n    // images to download but then you comment out all the async\n    // images your code would break.\n    callCallbackIfReady();\n\n    return textures;\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  // No speed diff AFAICT.\n  return {\n    \"setDefaults_\": setDefaults,\n\n    \"createTexture\": createTexture,\n    \"setEmptyTexture\": setEmptyTexture,\n    \"setTextureFromArray\": setTextureFromArray,\n    \"loadTextureFromUrl\": loadTextureFromUrl,\n    \"setTextureFromElement\": setTextureFromElement,\n    \"setTextureFilteringForSize\": setTextureFilteringForSize,\n    \"setTextureParameters\": setTextureParameters,\n    \"setDefaultTextureColor\": setDefaultTextureColor,\n    \"createTextures\": createTextures,\n    \"resizeTexture\": resizeTexture,\n    \"getNumComponentsForFormat\": getNumComponentsForFormat,\n  };\n});\n\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/framebuffers',[\n    './textures',\n    './utils',\n  ], function(\n    textures,\n    utils) {\n  \n\n  /**\n   * Framebuffer related functions\n   *\n   * For backward compatibily they are available at both `twgl.framebuffer` and `twgl`\n   * itself\n   *\n   * See {@link module:twgl} for core functions\n   *\n   * @module twgl/framebuffers\n   */\n\n  // make sure we don't see a global gl\n  var gl = undefined;  // eslint-disable-line\n\n  var UNSIGNED_BYTE                  = 0x1401;\n\n  /* PixelFormat */\n  var DEPTH_COMPONENT                = 0x1902;\n  var RGBA                           = 0x1908;\n\n  /* Framebuffer Object. */\n  var RGBA4                          = 0x8056;\n  var RGB5_A1                        = 0x8057;\n  var RGB565                         = 0x8D62;\n  var DEPTH_COMPONENT16              = 0x81A5;\n  var STENCIL_INDEX                  = 0x1901;\n  var STENCIL_INDEX8                 = 0x8D48;\n  var DEPTH_STENCIL                  = 0x84F9;\n  var COLOR_ATTACHMENT0              = 0x8CE0;\n  var DEPTH_ATTACHMENT               = 0x8D00;\n  var STENCIL_ATTACHMENT             = 0x8D20;\n  var DEPTH_STENCIL_ATTACHMENT       = 0x821A;\n\n  /* TextureWrapMode */\n  var REPEAT                         = 0x2901;  // eslint-disable-line\n  var CLAMP_TO_EDGE                  = 0x812F;\n  var MIRRORED_REPEAT                = 0x8370;  // eslint-disable-line\n\n  /* TextureMagFilter */\n  var NEAREST                        = 0x2600;  // eslint-disable-line\n  var LINEAR                         = 0x2601;\n\n  /* TextureMinFilter */\n  var NEAREST_MIPMAP_NEAREST         = 0x2700;  // eslint-disable-line\n  var LINEAR_MIPMAP_NEAREST          = 0x2701;  // eslint-disable-line\n  var NEAREST_MIPMAP_LINEAR          = 0x2702;  // eslint-disable-line\n  var LINEAR_MIPMAP_LINEAR           = 0x2703;  // eslint-disable-line\n\n  /**\n   * The options for a framebuffer attachment.\n   *\n   * Note: For a `format` that is a texture include all the texture\n   * options from {@link module:twgl.TextureOptions} for example\n   * `min`, `mag`, `clamp`, etc... Note that unlike {@link module:twgl.TextureOptions}\n   * `auto` defaults to `false` for attachment textures but `min` and `mag` default\n   * to `gl.LINEAR` and `wrap` defaults to `CLAMP_TO_EDGE`\n   *\n   * @typedef {Object} AttachmentOptions\n   * @property {number} [attach] The attachment point. Defaults\n   *   to `gl.COLOR_ATTACTMENT0 + ndx` unless type is a depth or stencil type\n   *   then it's gl.DEPTH_ATTACHMENT or `gl.DEPTH_STENCIL_ATTACHMENT` depending\n   *   on the format or attachment type.\n   * @property {number} [format] The format. If one of `gl.RGBA4`,\n   *   `gl.RGB565`, `gl.RGB5_A1`, `gl.DEPTH_COMPONENT16`,\n   *   `gl.STENCIL_INDEX8` or `gl.DEPTH_STENCIL` then will create a\n   *   renderbuffer. Otherwise will create a texture. Default = `gl.RGBA`\n   * @property {number} [type] The type. Used for texture. Default = `gl.UNSIGNED_BYTE`.\n   * @property {number} [target] The texture target for `gl.framebufferTexture2D`.\n   *   Defaults to `gl.TEXTURE_2D`. Set to appropriate face for cube maps.\n   * @property {number} [level] level for `gl.framebufferTexture2D`. Defaults to 0.\n   * @property {WebGLObject} [attachment] An existing renderbuffer or texture.\n   *    If provided will attach this Object. This allows you to share\n   *    attachemnts across framebuffers.\n   * @memberOf module:twgl\n   */\n\n  var defaultAttachments = [\n    { format: RGBA, type: UNSIGNED_BYTE, min: LINEAR, wrap: CLAMP_TO_EDGE, },\n    { format: DEPTH_STENCIL, },\n  ];\n\n  var attachmentsByFormat = {};\n  attachmentsByFormat[DEPTH_STENCIL] = DEPTH_STENCIL_ATTACHMENT;\n  attachmentsByFormat[STENCIL_INDEX] = STENCIL_ATTACHMENT;\n  attachmentsByFormat[STENCIL_INDEX8] = STENCIL_ATTACHMENT;\n  attachmentsByFormat[DEPTH_COMPONENT] = DEPTH_ATTACHMENT;\n  attachmentsByFormat[DEPTH_COMPONENT16] = DEPTH_ATTACHMENT;\n\n  function getAttachmentPointForFormat(format) {\n    return attachmentsByFormat[format];\n  }\n\n  var renderbufferFormats = {};\n  renderbufferFormats[RGBA4] = true;\n  renderbufferFormats[RGB5_A1] = true;\n  renderbufferFormats[RGB565] = true;\n  renderbufferFormats[DEPTH_STENCIL] = true;\n  renderbufferFormats[DEPTH_COMPONENT16] = true;\n  renderbufferFormats[STENCIL_INDEX] = true;\n  renderbufferFormats[STENCIL_INDEX8] = true;\n\n  function isRenderbufferFormat(format) {\n    return renderbufferFormats[format];\n  }\n\n  /**\n   * @typedef {Object} FramebufferInfo\n   * @property {WebGLFramebuffer} framebuffer The WebGLFramebuffer for this framebufferInfo\n   * @property {WebGLObject[]} attachments The created attachments in the same order as passed in to {@link module:twgl.createFramebufferInfo}.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Creates a framebuffer and attachments.\n   *\n   * This returns a {@link module:twgl.FramebufferInfo} because it needs to return the attachments as well as the framebuffer.\n   *\n   * The simplest usage\n   *\n   *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer\n   *     var fbi = twgl.createFramebuffer(gl);\n   *\n   * More complex usage\n   *\n   *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer\n   *     var attachments = [\n   *       { format: RGB565, mag: NEAREST },\n   *       { format: STENCIL_INDEX8 },\n   *     ]\n   *     var fbi = twgl.createFramebuffer(gl, attachments);\n   *\n   * Passing in a specific size\n   *\n   *     var width = 256;\n   *     var height = 256;\n   *     var fbi = twgl.createFramebuffer(gl, attachments, width, height);\n   *\n   * **Note!!** It is up to you to check if the framebuffer is renderable by calling `gl.checkFramebufferStatus`.\n   * [WebGL only guarantees 3 combinations of attachments work](https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.6).\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {module:twgl.AttachmentOptions[]} [attachments] which attachments to create. If not provided the default is a framebuffer with an\n   *    `RGBA`, `UNSIGNED_BYTE` texture `COLOR_ATTACHMENT0` and a `DEPTH_STENCIL` renderbuffer `DEPTH_STENCIL_ATTACHMENT`.\n   * @param {number} [width] the width for the attachments. Default = size of drawingBuffer\n   * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer\n   * @return {module:twgl.FramebufferInfo} the framebuffer and attachments.\n   * @memberOf module:twgl/framebuffers\n   */\n  function createFramebufferInfo(gl, attachments, width, height) {\n    var target = gl.FRAMEBUFFER;\n    var fb = gl.createFramebuffer();\n    gl.bindFramebuffer(target, fb);\n    width  = width  || gl.drawingBufferWidth;\n    height = height || gl.drawingBufferHeight;\n    attachments = attachments || defaultAttachments;\n    var colorAttachmentCount = 0;\n    var framebufferInfo = {\n      framebuffer: fb,\n      attachments: [],\n      width: width,\n      height: height,\n    };\n    attachments.forEach(function(attachmentOptions) {\n      var attachment = attachmentOptions.attachment;\n      var format = attachmentOptions.format;\n      var attachmentPoint = getAttachmentPointForFormat(format);\n      if (!attachmentPoint) {\n        attachmentPoint = COLOR_ATTACHMENT0 + colorAttachmentCount++;\n      }\n      if (!attachment) {\n        if (isRenderbufferFormat(format)) {\n          attachment = gl.createRenderbuffer();\n          gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);\n          gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);\n        } else {\n          var textureOptions = utils.shallowCopy(attachmentOptions);\n          textureOptions.width = width;\n          textureOptions.height = height;\n          if (textureOptions.auto === undefined) {\n            textureOptions.auto = false;\n            textureOptions.min = textureOptions.min || gl.LINEAR;\n            textureOptions.mag = textureOptions.mag || gl.LINEAR;\n            textureOptions.wrapS = textureOptions.wrapS || textureOptions.wrap || gl.CLAMP_TO_EDGE;\n            textureOptions.wrapT = textureOptions.wrapT || textureOptions.wrap || gl.CLAMP_TO_EDGE;\n          }\n          attachment = textures.createTexture(gl, textureOptions);\n        }\n      }\n      if (attachment instanceof WebGLRenderbuffer) {\n        gl.framebufferRenderbuffer(target, attachmentPoint, gl.RENDERBUFFER, attachment);\n      } else if (attachment instanceof WebGLTexture) {\n        gl.framebufferTexture2D(\n            target,\n            attachmentPoint,\n            attachmentOptions.texTarget || gl.TEXTURE_2D,\n            attachment,\n            attachmentOptions.level || 0);\n      } else {\n        throw \"unknown attachment type\";\n      }\n      framebufferInfo.attachments.push(attachment);\n    });\n    return framebufferInfo;\n  }\n\n  /**\n   * Resizes the attachments of a framebuffer.\n   *\n   * You need to pass in the same `attachments` as you passed in {@link module:twgl.createFramebuffer}\n   * because TWGL has no idea the format/type of each attachment.\n   *\n   * The simplest usage\n   *\n   *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer\n   *     var fbi = twgl.createFramebuffer(gl);\n   *\n   *     ...\n   *\n   *     function render() {\n   *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {\n   *         // resize the attachments\n   *         twgl.resizeFramebufferInfo(gl, fbi);\n   *       }\n   *\n   * More complex usage\n   *\n   *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer\n   *     var attachments = [\n   *       { format: RGB565, mag: NEAREST },\n   *       { format: STENCIL_INDEX8 },\n   *     ]\n   *     var fbi = twgl.createFramebuffer(gl, attachments);\n   *\n   *     ...\n   *\n   *     function render() {\n   *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {\n   *         // resize the attachments to match\n   *         twgl.resizeFramebufferInfo(gl, fbi, attachments);\n   *       }\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {module:twgl.FramebufferInfo} framebufferInfo a framebufferInfo as returned from {@link module:twgl.createFramebuffer}.\n   * @param {module:twgl.AttachmentOptions[]} [attachments] the same attachments options as passed to {@link module:twgl.createFramebuffer}.\n   * @param {number} [width] the width for the attachments. Default = size of drawingBuffer\n   * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer\n   * @memberOf module:twgl/framebuffers\n   */\n  function resizeFramebufferInfo(gl, framebufferInfo, attachments, width, height) {\n    width  = width  || gl.drawingBufferWidth;\n    height = height || gl.drawingBufferHeight;\n    framebufferInfo.width = width;\n    framebufferInfo.height = height;\n    attachments = attachments || defaultAttachments;\n    attachments.forEach(function(attachmentOptions, ndx) {\n      var attachment = framebufferInfo.attachments[ndx];\n      var format = attachmentOptions.format;\n      if (attachment instanceof WebGLRenderbuffer) {\n        gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);\n        gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);\n      } else if (attachment instanceof WebGLTexture) {\n        textures.resizeTexture(gl, attachment, attachmentOptions, width, height);\n      } else {\n        throw \"unknown attachment type\";\n      }\n    });\n  }\n\n  /**\n   * Binds a framebuffer\n   *\n   * This function pretty much soley exists because I spent hours\n   * trying to figure out why something I wrote wasn't working only\n   * to realize I forget to set the viewport dimensions.\n   * My hope is this function will fix that.\n   *\n   * It is effectively the same as\n   *\n   *     gl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);\n   *     gl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {module:twgl.FramebufferInfo} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebuffer}.\n   *   If not passed will bind the canvas.\n   * @param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.\n   * @memberOf module:twgl/framebuffers\n   */\n\n  function bindFramebufferInfo(gl, framebufferInfo, target) {\n    target = target || gl.FRAMEBUFFER;\n    if (framebufferInfo) {\n      gl.bindFramebuffer(target, framebufferInfo.framebuffer);\n      gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);\n    } else {\n      gl.bindFramebuffer(target, null);\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    }\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  // No speed diff AFAICT.\n  return {\n    \"bindFramebufferInfo\": bindFramebufferInfo,\n    \"createFramebufferInfo\": createFramebufferInfo,\n    \"resizeFramebufferInfo\": resizeFramebufferInfo,\n  };\n});\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/twgl',[\n    './attributes',\n    './draw',\n    './framebuffers',\n    './programs',\n    './textures',\n    './typedarrays',\n    './utils',\n  ], function(\n    attributes,\n    draw,\n    framebuffers,\n    programs,\n    textures,\n    typedArrays,\n    utils) {\n  \n\n  /**\n   * The main TWGL module.\n   *\n   * For most use cases you shouldn't need anything outside this module.\n   * Exceptions between the stuff added to twgl-full (v3, m4, primitives)\n   *\n   * @module twgl\n   * @borrows module:twgl/attributes.setAttribInfoBufferFromArray as setAttribInfoBufferFromArray\n   * @borrows module:twgl/attributes.createBufferInfoFromArrays as createBufferInfoFromArrays\n   * @borrows module:twgl/attributes.createVertexArrayInfo as createVertexArrayInfo\n   * @borrows module:twgl/draw.drawBufferInfo as drawBufferInfo\n   * @borrows module:twgl/draw.drawObjectList as drawObjectList\n   * @borrows module:twgl/framebuffers.createFramebufferInfo as createFramebufferInfo\n   * @borrows module:twgl/framebuffers.resizeFramebufferInfo as resizeFramebufferInfo\n   * @borrows module:twgl/framebuffers.bindFramebufferInfo as bindFramebufferInfo\n   * @borrows module:twgl/programs.createProgramInfo as createProgramInfo\n   * @borrows module:twgl/programs.createUniformBlockInfo as createUniformBlockInfo\n   * @borrows module:twgl/programs.bindUniformBlock as bindUniformBlock\n   * @borrows module:twgl/programs.setUniformBlock as setUniformBlock\n   * @borrows module:twgl/programs.setBlockUniforms as setBlockUniforms\n   * @borrows module:twgl/programs.setUniforms as setUniforms\n   * @borrows module:twgl/programs.setBuffersAndAttributes as setBuffersAndAttributes\n   * @borrows module:twgl/textures.setTextureFromArray as setTextureFromArray\n   * @borrows module:twgl/textures.createTexture as createTexture\n   * @borrows module:twgl/textures.resizeTexture as resizeTexture\n   * @borrows module:twgl/textures.createTextures as createTextures\n   */\n\n  // make sure we don't see a global gl\n  var gl = undefined;  // eslint-disable-line\n  var defaults = {\n    enableVertexArrayObjects: true,\n  };\n\n  /**\n   * Various default settings for twgl.\n   *\n   * Note: You can call this any number of times. Example:\n   *\n   *     twgl.setDefaults({ textureColor: [1, 0, 0, 1] });\n   *     twgl.setDefaults({ attribPrefix: 'a_' });\n   *\n   * is equivalent to\n   *\n   *     twgl.setDefaults({\n   *       textureColor: [1, 0, 0, 1],\n   *       attribPrefix: 'a_',\n   *     });\n   *\n   * @typedef {Object} Defaults\n   * @property {string} attribPrefix The prefix to stick on attributes\n   *\n   *   When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`\n   *   as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.\n   *\n   *   In otherwords I'll create arrays of geometry like this\n   *\n   *       var arrays = {\n   *         position: ...\n   *         normal: ...\n   *         texcoord: ...\n   *       };\n   *\n   *   But need those mapped to attributes and my attributes start with `a_`.\n   *\n   *   Default: `\"\"`\n   *\n   * @property {number[]} textureColor Array of 4 values in the range 0 to 1\n   *\n   *   The default texture color is used when loading textures from\n   *   urls. Because the URL will be loaded async we'd like to be\n   *   able to use the texture immediately. By putting a 1x1 pixel\n   *   color in the texture we can start using the texture before\n   *   the URL has loaded.\n   *\n   *   Default: `[0.5, 0.75, 1, 1]`\n   *\n   * @property {string} crossOrigin\n   *\n   *   If not undefined sets the crossOrigin attribute on images\n   *   that twgl creates when downloading images for textures.\n   *\n   *   Also see {@link module:twgl.TextureOptions}.\n   *\n   * @property {bool} enableVertexArrayObjects\n   *\n   *   If true then in WebGL 1.0 will attempt to get the `OES_vertex_array_object` extension.\n   *   If successful it will copy create/bind/delete/isVertexArrayOES from the extension to\n   *   the WebGLRenderingContext removing the OES at the end which is the standard entry point\n   *   for WebGL 2.\n   *\n   *   Note: According to webglstats.com 90% of devices support `OES_vertex_array_object`.\n   *   If you just want to count on support I suggest using [this polyfill](https://github.com/KhronosGroup/WebGL/blob/master/sdk/demos/google/resources/OESVertexArrayObject.js)\n   *   or ignoring devices that don't support them.\n   *\n   *   Default: `true`\n   *\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Sets various defaults for twgl.\n   *\n   * In the interest of terseness which is kind of the point\n   * of twgl I've integrated a few of the older functions here\n   *\n   * @param {module:twgl.Defaults} newDefaults The default settings.\n   * @memberOf module:twgl\n   */\n  function setDefaults(newDefaults) {\n    utils.copyExistingProperties(newDefaults, defaults);\n    attributes.setDefaults_(newDefaults);  // eslint-disable-line\n    textures.setDefaults_(newDefaults);  // eslint-disable-line\n  }\n\n  /**\n   * Adds Vertex Array Objects to WebGL 1 GL contexts if available\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   */\n  function addVertexArrayObjectSupport(gl) {\n    if (!gl || !defaults.enableVertexArrayObjects) {\n      return;\n    }\n    if (utils.isWebGL1(gl)) {\n      var ext = gl.getExtension(\"OES_vertex_array_object\");\n      if (ext) {\n        gl.createVertexArray = function() {\n          return ext.createVertexArrayOES();\n        };\n        gl.deleteVertexArray = function(v) {\n          ext.deleteVertexArrayOES(v);\n        };\n        gl.isVertexArray = function(v) {\n          return ext.isVertexArrayOES(v);\n        };\n        gl.bindVertexArray = function(v) {\n          ext.bindVertexArrayOES(v);\n        };\n        gl.VERTEX_ARRAY_BINDING = ext.VERTEX_ARRAY_BINDING_OES;\n      }\n    }\n  }\n\n  /**\n   * Creates a webgl context.\n   * @param {HTMLCanvasElement} canvas The canvas tag to get\n   *     context from. If one is not passed in one will be\n   *     created.\n   * @return {WebGLRenderingContext} The created context.\n   */\n  function create3DContext(canvas, opt_attribs) {\n    var names = [\"webgl\", \"experimental-webgl\"];\n    var context = null;\n    for (var ii = 0; ii < names.length; ++ii) {\n      try {\n        context = canvas.getContext(names[ii], opt_attribs);\n      } catch(e) {}  // eslint-disable-line\n      if (context) {\n        break;\n      }\n    }\n    return context;\n  }\n\n  /**\n   * Gets a WebGL context.\n   * @param {HTMLCanvasElement} canvas a canvas element.\n   * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes\n   * @memberOf module:twgl\n   */\n  function getWebGLContext(canvas, opt_attribs) {\n    var gl = create3DContext(canvas, opt_attribs);\n    addVertexArrayObjectSupport(gl);\n    return gl;\n  }\n\n  /**\n   * Creates a webgl context.\n   *\n   * Will return a WebGL2 context if possible.\n   *\n   * You can check if it's WebGL2 with\n   *\n   *     twgl.isWebGL2(gl);\n   *\n   * @param {HTMLCanvasElement} canvas The canvas tag to get\n   *     context from. If one is not passed in one will be\n   *     created.\n   * @return {WebGLRenderingContext} The created context.\n   */\n  function createContext(canvas, opt_attribs) {\n    var names = [\"webgl2\", \"experimental-webgl2\", \"webgl\", \"experimental-webgl\"];\n    var context = null;\n    for (var ii = 0; ii < names.length; ++ii) {\n      try {\n        context = canvas.getContext(names[ii], opt_attribs);\n      } catch(e) {}  // eslint-disable-line\n      if (context) {\n        break;\n      }\n    }\n    return context;\n  }\n\n  /**\n   * Gets a WebGL context.  Will create a WebGL2 context if possible.\n   *\n   * You can check if it's WebGL2 with\n   *\n   *    function isWebGL2(gl) {\n   *      return gl.getParameter(gl.VERSION).indexOf(\"WebGL 2.0 \") == 0;\n   *    }\n   *\n   * @param {HTMLCanvasElement} canvas a canvas element.\n   * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes\n   * @return {WebGLRenderingContext} The created context.\n   * @memberOf module:twgl\n   */\n  function getContext(canvas, opt_attribs) {\n    var gl = createContext(canvas, opt_attribs);\n    addVertexArrayObjectSupport(gl);\n    return gl;\n  }\n\n  /**\n   * Resize a canvas to match the size it's displayed.\n   * @param {HTMLCanvasElement} canvas The canvas to resize.\n   * @param {number} [multiplier] So you can pass in `window.devicePixelRatio` if you want to.\n   * @return {boolean} true if the canvas was resized.\n   * @memberOf module:twgl\n   */\n  function resizeCanvasToDisplaySize(canvas, multiplier) {\n    multiplier = multiplier || 1;\n    multiplier = Math.max(1, multiplier);\n    var width  = canvas.clientWidth  * multiplier | 0;\n    var height = canvas.clientHeight * multiplier | 0;\n    if (canvas.width !== width ||\n        canvas.height !== height) {\n      canvas.width = width;\n      canvas.height = height;\n      return true;\n    }\n    return false;\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  // No speed diff AFAICT.\n  var api = {\n    \"getContext\": getContext,\n    \"getWebGLContext\": getWebGLContext,\n    \"isWebGL1\": utils.isWebGL1,\n    \"isWebGL2\": utils.isWebGL2,\n    \"resizeCanvasToDisplaySize\": resizeCanvasToDisplaySize,\n    \"setDefaults\": setDefaults,\n  };\n\n  function notPrivate(name) {\n    return name[name.length - 1] !== '_';\n  }\n\n  function copyPublicProperties(src, dst) {\n    Object.keys(src).filter(notPrivate).forEach(function(key) {\n      dst[key] = src[key];\n    });\n    return dst;\n  }\n\n  var apis = {\n    attributes: attributes,\n    draw: draw,\n    framebuffers: framebuffers,\n    programs: programs,\n    textures: textures,\n    typedArrays: typedArrays,\n  };\n  Object.keys(apis).forEach(function(name) {\n    var srcApi = apis[name];\n    copyPublicProperties(srcApi, api);\n    api[name] = copyPublicProperties(srcApi, {});\n  });\n\n  return api;\n\n});\n\n\ndefine('main', [\n    'twgl/twgl',\n  ], function(\n    twgl\n  ) {\n    return twgl;\n})\n\nnotrequirebecasebrowserifymessesup(['main'], function(main) {\n  return main;\n}, undefined, true);   // forceSync = true\n\n\n\n\n;\ndefine(\"build/js/twgl-includer\", function(){});\n\n    return notrequirebecasebrowserifymessesup('main');\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/twgl-base.js/dist/2.x/twgl.js\n// module id = 8\n// module chunks = 0"],"sourceRoot":""}