{"version":3,"sources":["webpack:///webglImageDisplacement.js","webpack:///webpack/bootstrap 0bca145b94796779a478","webpack:///./index.js","webpack:///./~/babel-runtime/helpers/classCallCheck.js","webpack:///./~/babel-runtime/core-js/object/keys.js","webpack:///./~/core-js/library/fn/object/keys.js","webpack:///./~/core-js/library/modules/es6.object.keys.js","webpack:///./~/core-js/library/modules/_to-object.js","webpack:///./~/core-js/library/modules/_defined.js","webpack:///./~/core-js/library/modules/_object-keys.js","webpack:///./~/core-js/library/modules/_object-keys-internal.js","webpack:///./~/core-js/library/modules/_has.js","webpack:///./~/core-js/library/modules/_to-iobject.js","webpack:///./~/core-js/library/modules/_iobject.js","webpack:///./~/core-js/library/modules/_cof.js","webpack:///./~/core-js/library/modules/_array-includes.js","webpack:///./~/core-js/library/modules/_to-length.js","webpack:///./~/core-js/library/modules/_to-integer.js","webpack:///./~/core-js/library/modules/_to-index.js","webpack:///./~/core-js/library/modules/_shared-key.js","webpack:///./~/core-js/library/modules/_shared.js","webpack:///./~/core-js/library/modules/_global.js","webpack:///./~/core-js/library/modules/_uid.js","webpack:///./~/core-js/library/modules/_enum-bug-keys.js","webpack:///./~/core-js/library/modules/_object-sap.js","webpack:///./~/core-js/library/modules/_export.js","webpack:///./~/core-js/library/modules/_core.js","webpack:///./~/core-js/library/modules/_ctx.js","webpack:///./~/core-js/library/modules/_a-function.js","webpack:///./~/core-js/library/modules/_hide.js","webpack:///./~/core-js/library/modules/_object-dp.js","webpack:///./~/core-js/library/modules/_an-object.js","webpack:///./~/core-js/library/modules/_is-object.js","webpack:///./~/core-js/library/modules/_ie8-dom-define.js","webpack:///./~/core-js/library/modules/_descriptors.js","webpack:///./~/core-js/library/modules/_fails.js","webpack:///./~/core-js/library/modules/_dom-create.js","webpack:///./~/core-js/library/modules/_to-primitive.js","webpack:///./~/core-js/library/modules/_property-desc.js","webpack:///./shaders/noise.frag","webpack:///./shaders/main.frag","webpack:///./shaders/main.vert","webpack:///./~/twgl-base.js/dist/2.x/twgl.js"],"names":["ImageDisplacement","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck2","_classCallCheck3","_keys","_keys2","_noise","_noise2","_main","_main2","_main3","_main4","_twglBase","baseStyle","display","backgroundColor","height","width","applyStyles","element","styles","forEach","style","arrays","position","numComponents","data","calculateRelativeCoords","_element$getBoundingC","getBoundingClientRect","top","left","clientX","clientY","elementX","Math","min","max","elementY","options","_this","this","updateMouse","event","touches","length","elementMousePos","pos","intensity","abs","render","time","intensityD","parralax","delta","noiseUniforms","Period","Parralax","resolution","gl","canvas","uniforms","Frequency","Amplitude","Intensity","u_texSampler","texture","u_noiseSampler","framebufferInfo","attachments","resizeCanvasToDisplaySize","bindFramebufferInfo","useProgram","noiseProgramInfo","program","setBuffersAndAttributes","bufferInfo","setUniforms","drawBufferInfo","programInfo","requestAnimationFrame","subsideScale","imageSrc","document","body","createElement","getWebGLContext","error","appendChild","window","addEventListener","createProgramInfo","createBufferInfoFromArrays","createFramebufferInfo","createTexture","src","wrap","CLAMP_TO_EDGE","fallBackImage","instance","Constructor","TypeError","Object","keys","toObject","$keys","it","defined","undefined","enumBugKeys","O","has","toIObject","arrayIndexOf","IE_PROTO","object","names","key","i","result","push","hasOwnProperty","IObject","cof","propertyIsEnumerable","split","toString","slice","toLength","toIndex","IS_INCLUDES","$this","el","fromIndex","value","index","toInteger","ceil","floor","isNaN","shared","uid","global","SHARED","store","self","Function","__g","px","random","concat","$export","core","fails","KEY","exec","fn","exp","S","F","ctx","hide","PROTOTYPE","type","name","source","own","out","IS_FORCED","IS_GLOBAL","G","IS_STATIC","IS_PROTO","P","IS_BIND","B","IS_WRAP","W","expProto","target","C","a","b","arguments","apply","virtual","R","U","version","__e","aFunction","that","dP","createDesc","f","anObject","IE8_DOM_DEFINE","toPrimitive","defineProperty","Attributes","e","isObject","get","is","val","valueOf","bitmap","enumerable","configurable","writable","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","twgl","notrequirebecasebrowserifymessesupjs","notrequirebecasebrowserifymessesup","define","undef","hasProp","prop","hasOwn","normalize","baseName","nameParts","nameSegment","mapValue","foundMap","lastIndex","foundI","foundStarMap","starI","j","part","baseParts","map","config","starMap","charAt","nodeIdCompat","jsSuffixRegExp","test","replace","splice","join","indexOf","substring","makeRequire","relName","forceSync","args","aps","req","makeNormalize","makeLoad","depName","callDep","waiting","defining","main","Error","splitPrefix","prefix","makeConfig","makeMap","handlers","prototype","plugin","parts","n","pr","uri","deps","callback","cjsModule","ret","usingExports","callbackType","load","alt","setTimeout","cfg","_defined","amd","jQuery","getGLTypeForTypedArray","typedArray","Int8Array","BYTE","Uint8Array","UNSIGNED_BYTE","Uint8ClampedArray","Int16Array","SHORT","Uint16Array","UNSIGNED_SHORT","Int32Array","INT","Uint32Array","UNSIGNED_INT","Float32Array","FLOAT","getTypedArrayTypeForGLType","isArrayBuffer","buffer","ArrayBuffer","shallowCopy","dst","copyNamedProperties","copyExistingProperties","getVersionAsNumber","parseFloat","getParameter","VERSION","substr","isWebGL2","isWebGL1","console","bind","warn","typedArrays","utils","setAttributePrefix","defaults","attribPrefix","setDefaults","newDefaults","setBufferFromTypedArray","array","drawType","bindBuffer","bufferData","STATIC_DRAW","createBufferFromTypedArray","WebGLBuffer","ARRAY_BUFFER","createBuffer","isIndices","getNormalizationForTypedArray","getArray","guessNumComponentsFromName","texcoordRE","colorRE","getNumComponents","arrayName","size","makeTypedArray","Array","isArray","Type","createAttribsFromArrays","attribs","attribName","attrib","stride","offset","setAttribInfoBufferFromArray","attribInfo","bufferSubData","indices","ELEMENT_ARRAY_BUFFER","numElements","elementType","getNumElementsFromNonIndexedArrays","createBufferFromArray","createBuffersFromArrays","buffers","createVertexArrayInfo","programInfos","vao","createVertexArray","bindVertexArray","vertexArrayObject","positionKeys","ii","setDefaults_","getNumComponents_","getArray_","getBindPointForSamplerType","typeMap","bindPoint","floatSetter","location","v","uniform1f","floatArraySetter","uniform1fv","floatVec2Setter","uniform2fv","floatVec3Setter","uniform3fv","floatVec4Setter","uniform4fv","intSetter","uniform1i","intArraySetter","uniform1iv","intVec2Setter","uniform2iv","intVec3Setter","uniform3iv","intVec4Setter","uniform4iv","uintSetter","uniform1ui","uintArraySetter","uniform1uiv","uintVec2Setter","uniform2uiv","uintVec3Setter","uniform3uiv","uintVec4Setter","uniform4uiv","floatMat2Setter","uniformMatrix2fv","floatMat3Setter","uniformMatrix3fv","floatMat4Setter","uniformMatrix4fv","floatMat23Setter","uniformMatrix2x3fv","floatMat32Setter","uniformMatrix3x2fv","floatMat24Setter","uniformMatrix2x4fv","floatMat42Setter","uniformMatrix4x2fv","floatMat34Setter","uniformMatrix3x4fv","floatMat43Setter","uniformMatrix4x3fv","samplerSetter","unit","activeTexture","TEXTURE0","bindTexture","samplerArraySetter","units","textures","addLineNumbers","lineOffset","line","ndx","loadShader","shaderSource","shaderType","opt_errorCallback","errFn","shader","createShader","spaceRE","compileShader","compiled","getShaderParameter","COMPILE_STATUS","lastError","getShaderInfoLog","deleteShader","createProgram","shaders","opt_attribs","opt_locations","attachShader","bindAttribLocation","linkProgram","linked","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","createShaderFromScript","scriptId","opt_shaderType","shaderScript","getElementById","text","VERTEX_SHADER","FRAGMENT_SHADER","createProgramFromScripts","shaderScriptIds","defaultShaderType","createProgramFromSources","shaderSources","createUniformSetters","createUniformSetter","uniformInfo","getUniformLocation","typeInfo","textureUnit","arraySetter","setter","uniformSetters","numUniforms","ACTIVE_UNIFORMS","getActiveUniform","createUniformBlockSpecFromProgram","uniformData","uniformIndices","pair","pname","getActiveUniforms","blockSpecs","numUniformBlocks","ACTIVE_UNIFORM_BLOCKS","getActiveUniformBlockName","blockSpec","usedByVertexShader","getActiveUniformBlockParameter","UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER","usedByFragmentShader","UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER","UNIFORM_BLOCK_DATA_SIZE","UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES","used","usedByVertexSahder","createUniformBlockInfoFromProgram","uniformBlockSpec","blockName","uniformBufferIndex","UNIFORM_BUFFER","uniformBlockBinding","arraySuffixRE","uniformNdx","BYTES_PER_ELEMENT","asFloat","createUniformBlockInfo","bindUniformBlock","uniformBlockInfo","bufferBindIndex","bindBufferRange","byteLength","setUniformBlock","DYNAMIC_DRAW","setBlockUniforms","values","set","setters","actualSetters","numArgs","andx","vals","numValues","createAttributeSetters","createAttribSetter","enableVertexAttribArray","vertexAttribPointer","createMatAttribSetter","defaultSize","count","rowOffset","attribSetters","numAttribs","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","attrTypeMap","setAttributes","createProgramInfoFromProgram","good","script","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","INT_VEC2","INT_VEC3","INT_VEC4","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","SAMPLER_2D","SAMPLER_CUBE","SAMPLER_3D","SAMPLER_2D_SHADOW","FLOAT_MAT2x3","FLOAT_MAT2x4","FLOAT_MAT3x2","FLOAT_MAT3x4","FLOAT_MAT4x2","FLOAT_MAT4x3","SAMPLER_2D_ARRAY","SAMPLER_2D_ARRAY_SHADOW","SAMPLER_CUBE_SHADOW","UNSIGNED_INT_VEC2","UNSIGNED_INT_VEC3","UNSIGNED_INT_VEC4","INT_SAMPLER_2D","INT_SAMPLER_3D","INT_SAMPLER_CUBE","INT_SAMPLER_2D_ARRAY","UNSIGNED_INT_SAMPLER_2D","UNSIGNED_INT_SAMPLER_3D","UNSIGNED_INT_SAMPLER_CUBE","UNSIGNED_INT_SAMPLER_2D_ARRAY","TEXTURE_2D","TEXTURE_CUBE_MAP","TEXTURE_3D","TEXTURE_2D_ARRAY","programs","TRIANGLES","drawElements","drawArrays","drawObjectList","objectsToDraw","lastUsedProgramInfo","lastUsedBufferInfo","active","vertexArrayInfo","bindBuffers","setDefaultTextureColor","color","textureColor","savePackState","colorspaceConversion","lastPackState","UNPACK_COLORSPACE_CONVERSION_WEBGL","pixelStorei","premultiplyAlpha","UNPACK_PREMULTIPLY_ALPHA_WEBGL","flipY","UNPACK_FLIP_Y_WEBGL","restorePackState","setTextureParameters","tex","texParameteri","TEXTURE_MIN_FILTER","mag","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_WRAP_R","wrapR","wrapS","wrapT","minLod","TEXTURE_MIN_LOD","maxLod","TEXTURE_MAX_LOD","baseLevel","TEXTURE_BASE_LEVEL","maxLevel","TEXTURE_MAX_LEVEL","make1Pixel","isPowerOf2","setTextureFilteringForSize","textureOptions","generateMipmap","LINEAR","getCubeFaceOrder","cubeFaceOrder","TEXTURE_CUBE_MAP_POSITIVE_X","TEXTURE_CUBE_MAP_NEGATIVE_X","TEXTURE_CUBE_MAP_POSITIVE_Y","TEXTURE_CUBE_MAP_NEGATIVE_Y","TEXTURE_CUBE_MAP_POSITIVE_Z","TEXTURE_CUBE_MAP_NEGATIVE_Z","getCubeFacesWithNdx","faces","facesWithNdx","face","sort","noop","loadImage","url","crossOrigin","clearEventHandlers","img","removeEventListener","onError","onLoad","msg","Image","setTextureTo1PixelColor","texImage2D","RGBA","texImage3D","loadTextureFromUrl","err","setTextureFromElement","loadCubemapFromUrls","uploadImg","faceTarget","numToLoad","errors","otherTarget","format","imgs","urls","getNumComponentsForFormat","ALPHA","LUMINANCE","LUMINANCE_ALPHA","RGB","getTextureTypeForArrayType","guessDimensions","sqrt","setTextureFromArray","depth","internalFormat","glEnumToString","dimensions","cbrt","UNPACK_ALIGNMENT","unpackAlignment","faceSize","subarray","setEmptyTexture","HTMLElement","auto","resizeTexture","isAsyncSrc","createTextures","callCallbackIfReady","numDownloading","images","onLoadFn","init","enums","getContext","slices","imgWidth","imgHeight","nodeName","xOffset","yOffset","drawImage","smallest","largest","xMult","yMult","d","srcX","srcY","srcW","srcH","dstX","dstY","dstW","dstH","texSubImage3D","getAttachmentPointForFormat","attachmentsByFormat","isRenderbufferFormat","renderbufferFormats","FRAMEBUFFER","fb","createFramebuffer","bindFramebuffer","drawingBufferWidth","drawingBufferHeight","defaultAttachments","colorAttachmentCount","framebuffer","attachmentOptions","attachment","attachmentPoint","COLOR_ATTACHMENT0","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","WebGLRenderbuffer","framebufferRenderbuffer","WebGLTexture","framebufferTexture2D","texTarget","level","resizeFramebufferInfo","viewport","DEPTH_COMPONENT","RGBA4","RGB5_A1","RGB565","DEPTH_COMPONENT16","STENCIL_INDEX","STENCIL_INDEX8","DEPTH_STENCIL","DEPTH_ATTACHMENT","STENCIL_ATTACHMENT","DEPTH_STENCIL_ATTACHMENT","attributes","draw","framebuffers","addVertexArrayObjectSupport","enableVertexArrayObjects","ext","getExtension","createVertexArrayOES","deleteVertexArray","deleteVertexArrayOES","isVertexArray","isVertexArrayOES","bindVertexArrayOES","VERTEX_ARRAY_BINDING","VERTEX_ARRAY_BINDING_OES","create3DContext","context","createContext","multiplier","clientWidth","clientHeight","notPrivate","copyPublicProperties","filter","api","apis","srcApi"],"mappings":"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","file":"webglImageDisplacement.js","sourcesContent":["var ImageDisplacement =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _classCallCheck2 = __webpack_require__(2);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _keys = __webpack_require__(3);\n\t\n\tvar _keys2 = _interopRequireDefault(_keys);\n\t\n\tvar _noise = __webpack_require__(38);\n\t\n\tvar _noise2 = _interopRequireDefault(_noise);\n\t\n\tvar _main = __webpack_require__(39);\n\t\n\tvar _main2 = _interopRequireDefault(_main);\n\t\n\tvar _main3 = __webpack_require__(40);\n\t\n\tvar _main4 = _interopRequireDefault(_main3);\n\t\n\tvar _twglBase = __webpack_require__(41);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar baseStyle = { display: 'block', backgroundColor: 'black', height: '100%', width: '100%' };\n\t\n\tvar applyStyles = function applyStyles(element, styles) {\n\t  (0, _keys2.default)(styles).forEach(function (style) {\n\t    element.style[style] = styles[style];\n\t  });\n\t};\n\t\n\tvar arrays = {\n\t  position: { numComponents: 2, data: [1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1] }\n\t};\n\t\n\tvar calculateRelativeCoords = function calculateRelativeCoords(position, element) {\n\t  var _element$getBoundingC = element.getBoundingClientRect(),\n\t      top = _element$getBoundingC.top,\n\t      left = _element$getBoundingC.left,\n\t      width = _element$getBoundingC.width,\n\t      height = _element$getBoundingC.height;\n\t\n\t  var clientX = position.clientX,\n\t      clientY = position.clientY;\n\t\n\t  var elementX = Math.min(Math.max((clientX - left) / width, 0), 1);\n\t  var elementY = Math.min(Math.max((clientY - top) / height, 0), 1);\n\t  return { elementX: elementX, elementY: elementY };\n\t};\n\t\n\tvar ImageDisplacement = function ImageDisplacement(options) {\n\t  var _this = this;\n\t\n\t  (0, _classCallCheck3.default)(this, ImageDisplacement);\n\t\n\t  this.updateMouse = function (event) {\n\t    if (event.touches && event.touches.length > 1) {\n\t      return;\n\t    }\n\t    var touches = event.touches;\n\t    if (!touches) {\n\t      touches = [{ clientX: event.clientX, clientY: event.clientY }];\n\t    }\n\t    var elementMousePos = calculateRelativeCoords(touches[0], _this.element);\n\t    var pos = [elementMousePos.elementY, elementMousePos.elementX];\n\t    var intensity = Math.abs(pos[0] - 0.5) * 2;\n\t    if (intensity < 0.1) intensity = 0;\n\t    _this.intensity = intensity;\n\t    _this.pos = pos;\n\t  };\n\t\n\t  this.render = function (time) {\n\t    if (true) {\n\t      _this.intensityD -= (_this.intensityD - _this.intensity) / 20;\n\t      _this.parralax[1] -= (_this.parralax[1] - (_this.pos[1] - 0.5) / 5) / 20;\n\t      _this.parralax[0] -= (_this.parralax[0] - (_this.pos[0] - 0.5) / 5) / 20;\n\t      if (_this.delta > 0) _this.delta -= 1;\n\t      var noiseUniforms = {\n\t        time: time,\n\t        Period: 0.0002,\n\t        Parralax: [_this.parralax[1], _this.parralax[0]],\n\t        resolution: [_this.gl.canvas.width, _this.gl.canvas.height]\n\t      };\n\t      var uniforms = {\n\t        Frequency: 0.7,\n\t        Amplitude: 0.5,\n\t        Intensity: _this.intensityD,\n\t        u_texSampler: _this.texture,\n\t        u_noiseSampler: _this.framebufferInfo.attachments[0],\n\t        resolution: [_this.gl.canvas.width, _this.gl.canvas.height]\n\t      };\n\t      (0, _twglBase.resizeCanvasToDisplaySize)(_this.gl.canvas);\n\t      (0, _twglBase.bindFramebufferInfo)(_this.gl, _this.framebufferInfo);\n\t\n\t      _this.gl.useProgram(_this.noiseProgramInfo.program);\n\t      (0, _twglBase.setBuffersAndAttributes)(_this.gl, _this.noiseProgramInfo, _this.bufferInfo);\n\t      (0, _twglBase.setUniforms)(_this.noiseProgramInfo, noiseUniforms);\n\t      (0, _twglBase.drawBufferInfo)(_this.gl, _this.bufferInfo);\n\t\n\t      (0, _twglBase.bindFramebufferInfo)(_this.gl, null);\n\t      _this.gl.useProgram(_this.programInfo.program);\n\t      (0, _twglBase.setBuffersAndAttributes)(_this.gl, _this.programInfo, _this.bufferInfo);\n\t      (0, _twglBase.setUniforms)(_this.programInfo, uniforms);\n\t      (0, _twglBase.drawBufferInfo)(_this.gl, _this.bufferInfo);\n\t    }\n\t    requestAnimationFrame(_this.render);\n\t  };\n\t\n\t  this.pos = [0, 0];\n\t  this.parralax = [0, 0];\n\t  this.intensity = this.intensityD = 0;\n\t  this.subsideScale = 500;\n\t  this.imageSrc = options.imageSrc;\n\t  this.element = options.element || document.body;\n\t  var canvas = document.createElement('canvas');\n\t  applyStyles(canvas, baseStyle);\n\t  try {\n\t    this.gl = (0, _twglBase.getWebGLContext)(canvas);\n\t  } catch (error) {\n\t    this.gl = null;\n\t  }\n\t  if (this.gl !== null) {\n\t    this.element.appendChild(canvas);\n\t    window.addEventListener('mousemove', this.updateMouse);\n\t    window.addEventListener('touchmove', this.updateMouse);\n\t    this.programInfo = (0, _twglBase.createProgramInfo)(this.gl, [_main4.default, _main2.default]);\n\t    this.noiseProgramInfo = (0, _twglBase.createProgramInfo)(this.gl, [_main4.default, _noise2.default]);\n\t    this.bufferInfo = (0, _twglBase.createBufferInfoFromArrays)(this.gl, arrays);\n\t    this.framebufferInfo = (0, _twglBase.createFramebufferInfo)(this.gl);\n\t    this.texture = (0, _twglBase.createTexture)(this.gl, { src: this.imageSrc, wrap: this.gl.CLAMP_TO_EDGE }, function () {\n\t      _this.render();\n\t    });\n\t  } else {\n\t    var fallBackImage = document.createElement('img');\n\t    applyStyles(fallBackImage, baseStyle);\n\t    fallBackImage.src = this.imageSrc;\n\t    this.element.appendChild(fallBackImage);\n\t  }\n\t};\n\t\n\tmodule.exports = function (options) {\n\t  return new ImageDisplacement(options);\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\texports.default = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(4), __esModule: true };\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(5);\n\tmodule.exports = __webpack_require__(25).Object.keys;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 Object.keys(O)\n\tvar toObject = __webpack_require__(6)\n\t  , $keys    = __webpack_require__(8);\n\t\n\t__webpack_require__(23)('keys', function(){\n\t  return function keys(it){\n\t    return $keys(toObject(it));\n\t  };\n\t});\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(7);\n\tmodule.exports = function(it){\n\t  return Object(defined(it));\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\tvar $keys       = __webpack_require__(9)\n\t  , enumBugKeys = __webpack_require__(22);\n\t\n\tmodule.exports = Object.keys || function keys(O){\n\t  return $keys(O, enumBugKeys);\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar has          = __webpack_require__(10)\n\t  , toIObject    = __webpack_require__(11)\n\t  , arrayIndexOf = __webpack_require__(14)(false)\n\t  , IE_PROTO     = __webpack_require__(18)('IE_PROTO');\n\t\n\tmodule.exports = function(object, names){\n\t  var O      = toIObject(object)\n\t    , i      = 0\n\t    , result = []\n\t    , key;\n\t  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n\t  // Don't enum bug & hidden keys\n\t  while(names.length > i)if(has(O, key = names[i++])){\n\t    ~arrayIndexOf(result, key) || result.push(key);\n\t  }\n\t  return result;\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(12)\n\t  , defined = __webpack_require__(7);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(13);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// false -> Array#indexOf\n\t// true  -> Array#includes\n\tvar toIObject = __webpack_require__(11)\n\t  , toLength  = __webpack_require__(15)\n\t  , toIndex   = __webpack_require__(17);\n\tmodule.exports = function(IS_INCLUDES){\n\t  return function($this, el, fromIndex){\n\t    var O      = toIObject($this)\n\t      , length = toLength(O.length)\n\t      , index  = toIndex(fromIndex, length)\n\t      , value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    if(IS_INCLUDES && el != el)while(length > index){\n\t      value = O[index++];\n\t      if(value != value)return true;\n\t    // Array#toIndex ignores holes, Array#includes - not\n\t    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n\t      if(O[index] === el)return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.15 ToLength\n\tvar toInteger = __webpack_require__(16)\n\t  , min       = Math.min;\n\tmodule.exports = function(it){\n\t  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(16)\n\t  , max       = Math.max\n\t  , min       = Math.min;\n\tmodule.exports = function(index, length){\n\t  index = toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shared = __webpack_require__(19)('keys')\n\t  , uid    = __webpack_require__(21);\n\tmodule.exports = function(key){\n\t  return shared[key] || (shared[key] = uid(key));\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(20)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t// IE 8- don't enum bug keys\n\tmodule.exports = (\n\t  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n\t).split(',');\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// most Object methods by ES6 should accept primitives\n\tvar $export = __webpack_require__(24)\n\t  , core    = __webpack_require__(25)\n\t  , fails   = __webpack_require__(34);\n\tmodule.exports = function(KEY, exec){\n\t  var fn  = (core.Object || {})[KEY] || Object[KEY]\n\t    , exp = {};\n\t  exp[KEY] = exec(fn);\n\t  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(20)\n\t  , core      = __webpack_require__(25)\n\t  , ctx       = __webpack_require__(26)\n\t  , hide      = __webpack_require__(28)\n\t  , PROTOTYPE = 'prototype';\n\t\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , expProto  = exports[PROTOTYPE]\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(a, b, c){\n\t        if(this instanceof C){\n\t          switch(arguments.length){\n\t            case 0: return new C;\n\t            case 1: return new C(a);\n\t            case 2: return new C(a, b);\n\t          } return new C(a, b, c);\n\t        } return C.apply(this, arguments);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n\t    if(IS_PROTO){\n\t      (exports.virtual || (exports.virtual = {}))[key] = out;\n\t      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n\t      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n\t    }\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library` \n\tmodule.exports = $export;\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '2.4.0'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(27);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP         = __webpack_require__(29)\n\t  , createDesc = __webpack_require__(37);\n\tmodule.exports = __webpack_require__(33) ? function(object, key, value){\n\t  return dP.f(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject       = __webpack_require__(30)\n\t  , IE8_DOM_DEFINE = __webpack_require__(32)\n\t  , toPrimitive    = __webpack_require__(36)\n\t  , dP             = Object.defineProperty;\n\t\n\texports.f = __webpack_require__(33) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return dP(O, P, Attributes);\n\t  } catch(e){ /* empty */ }\n\t  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n\t  if('value' in Attributes)O[P] = Attributes.value;\n\t  return O;\n\t};\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(31);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = !__webpack_require__(33) && !__webpack_require__(34)(function(){\n\t  return Object.defineProperty(__webpack_require__(35)('div'), 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(34)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(31)\n\t  , document = __webpack_require__(20).document\n\t  // in old IE typeof document.createElement is 'object'\n\t  , is = isObject(document) && isObject(document.createElement);\n\tmodule.exports = function(it){\n\t  return is ? document.createElement(it) : {};\n\t};\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\tvar isObject = __webpack_require__(31);\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tmodule.exports = function(it, S){\n\t  if(!isObject(it))return it;\n\t  var fn, val;\n\t  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n/***/ },\n/* 37 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"precision highp float;\\n#define GLSLIFY 1\\nuniform vec2 resolution;\\nuniform sampler2D u_mySampler;\\nuniform float time;\\nuniform float Period;\\nuniform vec2 Parralax;\\nvarying vec2 v_position;\\n\\n// http://www.nutty.ca/?page_id=352&link=refraction\\n// Description : Array and textureless GLSL 3D simplex noise function.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\\nfloat snoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n  // First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n  // Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n  // Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n  //Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n  // Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\\n\\nvoid main() {\\n  float z = time * Period;\\n  vec2 uv = (v_position + Parralax) * 1.5;\\n  float value = (snoise(vec3(uv, z)) + 1.0) * 0.5;\\n  vec4 greyscale = vec4(value, value, value, 1.0);\\n  gl_FragColor = greyscale;\\n}\\n\"\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"precision highp float;\\n#define GLSLIFY 1\\nuniform vec2 resolution;\\nuniform sampler2D u_noiseSampler;\\nuniform sampler2D u_texSampler;\\nuniform float Amplitude;\\nuniform float Frequency;\\nuniform float Intensity;\\n\\nvarying vec2 v_position;\\nvarying vec2 v_texcoord;\\n\\nvec3 GetNormal () {\\n  float sobelX[9];\\n  sobelX[0] = 1.0; sobelX[1] = 0.0; sobelX[2] = -1.0;\\n  sobelX[3] = 2.0; sobelX[4] = 0.0; sobelX[5] = -2.0;\\n  sobelX[6] = 1.0; sobelX[7] = 0.0; sobelX[8] = -1.0;\\n\\n  float sobelY[9];\\n  sobelY[0] = 1.0; sobelY[1] = 2.0; sobelY[2] =  1.0;\\n  sobelY[3] = 0.0; sobelY[4] = 0.0; sobelY[5] =  0.0;\\n  sobelY[6] = -1.0; sobelY[7] = -2.0; sobelY[8] = -1.0;\\n\\n  float texelX[9];\\n  float texelY[9];\\n  vec2 uv = (v_texcoord) * Frequency;\\n  for (int i = 0; i < 9; i++)\\n  {\\n      vec4 otherTexel = texture2D(u_noiseSampler, uv);\\n      float average = (otherTexel.x + otherTexel.y + otherTexel.z) / 3.0;\\n      texelX[i] = average  * sobelX[i];\\n      texelY[i] = average  * sobelY[i];\\n  }\\n  vec3 normal = vec3(\\n    (texelX[0] + texelX[3] + texelX[6]) +\\n    (texelX[2] + texelX[5] + texelX[8]),\\n    (texelY[1] + texelY[2] + texelY[3]) +\\n    (texelY[6] + texelY[7] + texelY[8]),\\n    1.0 / Amplitude);\\n\\n  return normalize(normal);\\n}\\n\\nvoid main() {\\n  vec3 normal = GetNormal();\\n  vec2 offset = (normal.xy + vec2(0, 0.25)) * Intensity;\\n  vec2 uv = v_position * vec2(1.0, -0.5) + vec2(0, 0.5);\\n  gl_FragColor.xyz = texture2D(u_texSampler, uv + offset).xyz;\\n  gl_FragColor.w = 1.0;\\n}\\n\"\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"#define GLSLIFY 1\\nattribute vec2 position;\\nvarying vec2 v_position;\\nvarying vec2 v_texcoord;\\n\\nvoid main() {\\n  gl_Position = vec4(position, 0, 1);\\n  v_position = position;\\n  v_texcoord = position.xy * 0.5 + 0.5;\\n}\\n\"\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n\t * @license twgl.js 2.1.0 Copyright (c) 2015, Gregg Tavares All Rights Reserved.\n\t * Available via the MIT license.\n\t * see: http://github.com/greggman/twgl.js for details\n\t */\n\t/**\n\t * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n\t * Available via the MIT or new BSD license.\n\t * see: http://github.com/jrburke/almond for details\n\t */\n\t(function (root, factory) {\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } if (typeof module !== 'undefined' && module.exports) {\n\t        module.exports = factory();\n\t    } else {\n\t        root.twgl = factory();\n\t    }\n\t}(this, function () {\n\t\n\t/**\n\t * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n\t * Available via the MIT or new BSD license.\n\t * see: http://github.com/jrburke/almond for details\n\t */\n\t//Going sloppy to avoid 'use strict' string cost, but strict practices should\n\t//be followed.\n\t/*jslint sloppy: true */\n\t/*global setTimeout: false */\n\t\n\tvar notrequirebecasebrowserifymessesupjs, notrequirebecasebrowserifymessesup, define;\n\t(function (undef) {\n\t    var main, req, makeMap, handlers,\n\t        defined = {},\n\t        waiting = {},\n\t        config = {},\n\t        defining = {},\n\t        hasOwn = Object.prototype.hasOwnProperty,\n\t        aps = [].slice,\n\t        jsSuffixRegExp = /\\.js$/;\n\t\n\t    function hasProp(obj, prop) {\n\t        return hasOwn.call(obj, prop);\n\t    }\n\t\n\t    /**\n\t     * Given a relative module name, like ./something, normalize it to\n\t     * a real name that can be mapped to a path.\n\t     * @param {String} name the relative name\n\t     * @param {String} baseName a real name that the name arg is relative\n\t     * to.\n\t     * @returns {String} normalized name\n\t     */\n\t    function normalize(name, baseName) {\n\t        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n\t            foundI, foundStarMap, starI, i, j, part,\n\t            baseParts = baseName && baseName.split(\"/\"),\n\t            map = config.map,\n\t            starMap = (map && map['*']) || {};\n\t\n\t        //Adjust any relative paths.\n\t        if (name && name.charAt(0) === \".\") {\n\t            //If have a base name, try to normalize against it,\n\t            //otherwise, assume it is a top-level notrequirebecasebrowserifymessesup that will\n\t            //be relative to baseUrl in the end.\n\t            if (baseName) {\n\t                name = name.split('/');\n\t                lastIndex = name.length - 1;\n\t\n\t                // Node .js allowance:\n\t                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n\t                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n\t                }\n\t\n\t                //Lop off the last part of baseParts, so that . matches the\n\t                //\"directory\" and not name of the baseName's module. For instance,\n\t                //baseName of \"one/two/three\", maps to \"one/two/three.js\", but we\n\t                //want the directory, \"one/two\" for this normalization.\n\t                name = baseParts.slice(0, baseParts.length - 1).concat(name);\n\t\n\t                //start trimDots\n\t                for (i = 0; i < name.length; i += 1) {\n\t                    part = name[i];\n\t                    if (part === \".\") {\n\t                        name.splice(i, 1);\n\t                        i -= 1;\n\t                    } else if (part === \"..\") {\n\t                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n\t                            //End of the line. Keep at least one non-dot\n\t                            //path segment at the front so it can be mapped\n\t                            //correctly to disk. Otherwise, there is likely\n\t                            //no path mapping for a path starting with '..'.\n\t                            //This can still fail, but catches the most reasonable\n\t                            //uses of ..\n\t                            break;\n\t                        } else if (i > 0) {\n\t                            name.splice(i - 1, 2);\n\t                            i -= 2;\n\t                        }\n\t                    }\n\t                }\n\t                //end trimDots\n\t\n\t                name = name.join(\"/\");\n\t            } else if (name.indexOf('./') === 0) {\n\t                // No baseName, so this is ID is resolved relative\n\t                // to baseUrl, pull off the leading dot.\n\t                name = name.substring(2);\n\t            }\n\t        }\n\t\n\t        //Apply map config if available.\n\t        if ((baseParts || starMap) && map) {\n\t            nameParts = name.split('/');\n\t\n\t            for (i = nameParts.length; i > 0; i -= 1) {\n\t                nameSegment = nameParts.slice(0, i).join(\"/\");\n\t\n\t                if (baseParts) {\n\t                    //Find the longest baseName segment match in the config.\n\t                    //So, do joins on the biggest to smallest lengths of baseParts.\n\t                    for (j = baseParts.length; j > 0; j -= 1) {\n\t                        mapValue = map[baseParts.slice(0, j).join('/')];\n\t\n\t                        //baseName segment has  config, find if it has one for\n\t                        //this name.\n\t                        if (mapValue) {\n\t                            mapValue = mapValue[nameSegment];\n\t                            if (mapValue) {\n\t                                //Match, update name to the new value.\n\t                                foundMap = mapValue;\n\t                                foundI = i;\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t\n\t                if (foundMap) {\n\t                    break;\n\t                }\n\t\n\t                //Check for a star map match, but just hold on to it,\n\t                //if there is a shorter segment match later in a matching\n\t                //config, then favor over this star map.\n\t                if (!foundStarMap && starMap && starMap[nameSegment]) {\n\t                    foundStarMap = starMap[nameSegment];\n\t                    starI = i;\n\t                }\n\t            }\n\t\n\t            if (!foundMap && foundStarMap) {\n\t                foundMap = foundStarMap;\n\t                foundI = starI;\n\t            }\n\t\n\t            if (foundMap) {\n\t                nameParts.splice(0, foundI, foundMap);\n\t                name = nameParts.join('/');\n\t            }\n\t        }\n\t\n\t        return name;\n\t    }\n\t\n\t    function makeRequire(relName, forceSync) {\n\t        return function () {\n\t            //A version of a notrequirebecasebrowserifymessesup function that passes a moduleName\n\t            //value for items that may need to\n\t            //look up paths relative to the moduleName\n\t            var args = aps.call(arguments, 0);\n\t\n\t            //If first arg is not notrequirebecasebrowserifymessesup('string'), and there is only\n\t            //one arg, it is the array form without a callback. Insert\n\t            //a null so that the following concat is correct.\n\t            if (typeof args[0] !== 'string' && args.length === 1) {\n\t                args.push(null);\n\t            }\n\t            return req.apply(undef, args.concat([relName, forceSync]));\n\t        };\n\t    }\n\t\n\t    function makeNormalize(relName) {\n\t        return function (name) {\n\t            return normalize(name, relName);\n\t        };\n\t    }\n\t\n\t    function makeLoad(depName) {\n\t        return function (value) {\n\t            defined[depName] = value;\n\t        };\n\t    }\n\t\n\t    function callDep(name) {\n\t        if (hasProp(waiting, name)) {\n\t            var args = waiting[name];\n\t            delete waiting[name];\n\t            defining[name] = true;\n\t            main.apply(undef, args);\n\t        }\n\t\n\t        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n\t            throw new Error('No ' + name);\n\t        }\n\t        return defined[name];\n\t    }\n\t\n\t    //Turns a plugin!resource to [plugin, resource]\n\t    //with the plugin being undefined if the name\n\t    //did not have a plugin prefix.\n\t    function splitPrefix(name) {\n\t        var prefix,\n\t            index = name ? name.indexOf('!') : -1;\n\t        if (index > -1) {\n\t            prefix = name.substring(0, index);\n\t            name = name.substring(index + 1, name.length);\n\t        }\n\t        return [prefix, name];\n\t    }\n\t\n\t    /**\n\t     * Makes a name map, normalizing the name, and using a plugin\n\t     * for normalization if necessary. Grabs a ref to plugin\n\t     * too, as an optimization.\n\t     */\n\t    makeMap = function (name, relName) {\n\t        var plugin,\n\t            parts = splitPrefix(name),\n\t            prefix = parts[0];\n\t\n\t        name = parts[1];\n\t\n\t        if (prefix) {\n\t            prefix = normalize(prefix, relName);\n\t            plugin = callDep(prefix);\n\t        }\n\t\n\t        //Normalize according\n\t        if (prefix) {\n\t            if (plugin && plugin.normalize) {\n\t                name = plugin.normalize(name, makeNormalize(relName));\n\t            } else {\n\t                name = normalize(name, relName);\n\t            }\n\t        } else {\n\t            name = normalize(name, relName);\n\t            parts = splitPrefix(name);\n\t            prefix = parts[0];\n\t            name = parts[1];\n\t            if (prefix) {\n\t                plugin = callDep(prefix);\n\t            }\n\t        }\n\t\n\t        //Using ridiculous property names for space reasons\n\t        return {\n\t            f: prefix ? prefix + '!' + name : name, //fullName\n\t            n: name,\n\t            pr: prefix,\n\t            p: plugin\n\t        };\n\t    };\n\t\n\t    function makeConfig(name) {\n\t        return function () {\n\t            return (config && config.config && config.config[name]) || {};\n\t        };\n\t    }\n\t\n\t    handlers = {\n\t        notrequirebecasebrowserifymessesup: function (name) {\n\t            return makeRequire(name);\n\t        },\n\t        exports: function (name) {\n\t            var e = defined[name];\n\t            if (typeof e !== 'undefined') {\n\t                return e;\n\t            } else {\n\t                return (defined[name] = {});\n\t            }\n\t        },\n\t        module: function (name) {\n\t            return {\n\t                id: name,\n\t                uri: '',\n\t                exports: defined[name],\n\t                config: makeConfig(name)\n\t            };\n\t        }\n\t    };\n\t\n\t    main = function (name, deps, callback, relName) {\n\t        var cjsModule, depName, ret, map, i,\n\t            args = [],\n\t            callbackType = typeof callback,\n\t            usingExports;\n\t\n\t        //Use name if no relName\n\t        relName = relName || name;\n\t\n\t        //Call the callback to define the module, if necessary.\n\t        if (callbackType === 'undefined' || callbackType === 'function') {\n\t            //Pull out the defined dependencies and pass the ordered\n\t            //values to the callback.\n\t            //Default to [notrequirebecasebrowserifymessesup, exports, module] if no deps\n\t            deps = !deps.length && callback.length ? ['notrequirebecasebrowserifymessesup', 'exports', 'module'] : deps;\n\t            for (i = 0; i < deps.length; i += 1) {\n\t                map = makeMap(deps[i], relName);\n\t                depName = map.f;\n\t\n\t                //Fast path CommonJS standard dependencies.\n\t                if (depName === \"notrequirebecasebrowserifymessesup\") {\n\t                    args[i] = handlers.notrequirebecasebrowserifymessesup(name);\n\t                } else if (depName === \"exports\") {\n\t                    //CommonJS module spec 1.1\n\t                    args[i] = handlers.exports(name);\n\t                    usingExports = true;\n\t                } else if (depName === \"module\") {\n\t                    //CommonJS module spec 1.1\n\t                    cjsModule = args[i] = handlers.module(name);\n\t                } else if (hasProp(defined, depName) ||\n\t                           hasProp(waiting, depName) ||\n\t                           hasProp(defining, depName)) {\n\t                    args[i] = callDep(depName);\n\t                } else if (map.p) {\n\t                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n\t                    args[i] = defined[depName];\n\t                } else {\n\t                    throw new Error(name + ' missing ' + depName);\n\t                }\n\t            }\n\t\n\t            ret = callback ? callback.apply(defined[name], args) : undefined;\n\t\n\t            if (name) {\n\t                //If setting exports via \"module\" is in play,\n\t                //favor that over return value and exports. After that,\n\t                //favor a non-undefined return value over exports use.\n\t                if (cjsModule && cjsModule.exports !== undef &&\n\t                        cjsModule.exports !== defined[name]) {\n\t                    defined[name] = cjsModule.exports;\n\t                } else if (ret !== undef || !usingExports) {\n\t                    //Use the return value from the function.\n\t                    defined[name] = ret;\n\t                }\n\t            }\n\t        } else if (name) {\n\t            //May just be an object definition for the module. Only\n\t            //worry about defining if have a module name.\n\t            defined[name] = callback;\n\t        }\n\t    };\n\t\n\t    notrequirebecasebrowserifymessesupjs = notrequirebecasebrowserifymessesup = req = function (deps, callback, relName, forceSync, alt) {\n\t        if (typeof deps === \"string\") {\n\t            if (handlers[deps]) {\n\t                //callback in this case is really relName\n\t                return handlers[deps](callback);\n\t            }\n\t            //Just return the module wanted. In this scenario, the\n\t            //deps arg is the module name, and second arg (if passed)\n\t            //is just the relName.\n\t            //Normalize module name, if it contains . or ..\n\t            return callDep(makeMap(deps, callback).f);\n\t        } else if (!deps.splice) {\n\t            //deps is a config object, not an array.\n\t            config = deps;\n\t            if (config.deps) {\n\t                req(config.deps, config.callback);\n\t            }\n\t            if (!callback) {\n\t                return;\n\t            }\n\t\n\t            if (callback.splice) {\n\t                //callback is an array, which means it is a dependency list.\n\t                //Adjust args if there are dependencies\n\t                deps = callback;\n\t                callback = relName;\n\t                relName = null;\n\t            } else {\n\t                deps = undef;\n\t            }\n\t        }\n\t\n\t        //Support notrequirebecasebrowserifymessesup(['a'])\n\t        callback = callback || function () {};\n\t\n\t        //If relName is a function, it is an errback handler,\n\t        //so remove it.\n\t        if (typeof relName === 'function') {\n\t            relName = forceSync;\n\t            forceSync = alt;\n\t        }\n\t\n\t        //Simulate async callback;\n\t        if (forceSync) {\n\t            main(undef, deps, callback, relName);\n\t        } else {\n\t            //Using a non-zero value because of concern for what old browsers\n\t            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n\t            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n\t            //If want a value immediately, use notrequirebecasebrowserifymessesup('id') instead -- something\n\t            //that works in almond on the global level, but not guaranteed and\n\t            //unlikely to work in other AMD implementations.\n\t            setTimeout(function () {\n\t                main(undef, deps, callback, relName);\n\t            }, 4);\n\t        }\n\t\n\t        return req;\n\t    };\n\t\n\t    /**\n\t     * Just drops the config on the floor, but returns req in case\n\t     * the config return value is used.\n\t     */\n\t    req.config = function (cfg) {\n\t        return req(cfg);\n\t    };\n\t\n\t    /**\n\t     * Expose module registry for debugging and tooling\n\t     */\n\t    notrequirebecasebrowserifymessesupjs._defined = defined;\n\t\n\t    define = function (name, deps, callback) {\n\t        if (typeof name !== 'string') {\n\t            throw new Error('See almond README: incorrect module build, no module name');\n\t        }\n\t\n\t        //This module may not have dependencies\n\t        if (!deps.splice) {\n\t            //deps is not an array, so probably means\n\t            //an object literal or factory function for\n\t            //the value. Adjust args.\n\t            callback = deps;\n\t            deps = [];\n\t        }\n\t\n\t        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n\t            waiting[name] = [name, deps, callback];\n\t        }\n\t    };\n\t\n\t    define.amd = {\n\t        jQuery: true\n\t    };\n\t}());\n\t\n\tdefine(\"node_modules/almond/almond.js\", function(){});\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\tdefine('twgl/typedarrays',[], function() {\n\t\n\t\n\t  /**\n\t   * Low level shader typed array related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.typedArray` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/typedArray\n\t   */\n\t\n\t\n\t  // make sure we don't see a global gl\n\t  var gl = undefined;  // eslint-disable-line\n\t\n\t  /* DataType */\n\t  var BYTE                           = 0x1400;\n\t  var UNSIGNED_BYTE                  = 0x1401;\n\t  var SHORT                          = 0x1402;\n\t  var UNSIGNED_SHORT                 = 0x1403;\n\t  var INT                            = 0x1404;\n\t  var UNSIGNED_INT                   = 0x1405;\n\t  var FLOAT                          = 0x1406;\n\t\n\t  /**\n\t   * Get the GL type for a typedArray\n\t   * @param {ArrayBuffer|ArrayBufferView} typedArray a typedArray\n\t   * @return {number} the GL type for array. For example pass in an `Int8Array` and `gl.BYTE` will\n\t   *   be returned. Pass in a `Uint32Array` and `gl.UNSIGNED_INT` will be returned\n\t   * @memberOf module:twgl/typedArray\n\t   */\n\t  function getGLTypeForTypedArray(typedArray) {\n\t    if (typedArray instanceof Int8Array)         { return BYTE; }           // eslint-disable-line\n\t    if (typedArray instanceof Uint8Array)        { return UNSIGNED_BYTE; }  // eslint-disable-line\n\t    if (typedArray instanceof Uint8ClampedArray) { return UNSIGNED_BYTE; }  // eslint-disable-line\n\t    if (typedArray instanceof Int16Array)        { return SHORT; }          // eslint-disable-line\n\t    if (typedArray instanceof Uint16Array)       { return UNSIGNED_SHORT; } // eslint-disable-line\n\t    if (typedArray instanceof Int32Array)        { return INT; }            // eslint-disable-line\n\t    if (typedArray instanceof Uint32Array)       { return UNSIGNED_INT; }   // eslint-disable-line\n\t    if (typedArray instanceof Float32Array)      { return FLOAT; }          // eslint-disable-line\n\t    throw \"unsupported typed array type\";\n\t  }\n\t\n\t  /**\n\t   * Get the typed array constructor for a given GL type\n\t   * @param {number} type the GL type. (eg: `gl.UNSIGNED_INT`)\n\t   * @return {function} the constructor for a the corresponding typed array. (eg. `Uint32Array`).\n\t   * @memberOf module:twgl/typedArray\n\t   */\n\t  function getTypedArrayTypeForGLType(type) {\n\t    switch (type) {\n\t      case BYTE:           return Int8Array;     // eslint-disable-line\n\t      case UNSIGNED_BYTE:  return Uint8Array;    // eslint-disable-line\n\t      case SHORT:          return Int16Array;    // eslint-disable-line\n\t      case UNSIGNED_SHORT: return Uint16Array;   // eslint-disable-line\n\t      case INT:            return Int32Array;    // eslint-disable-line\n\t      case UNSIGNED_INT:   return Uint32Array;   // eslint-disable-line\n\t      case FLOAT:          return Float32Array;  // eslint-disable-line\n\t      default:\n\t        throw \"unknown gl type\";\n\t    }\n\t  }\n\t\n\t  function isArrayBuffer(a) {\n\t    return a && a.buffer && a.buffer instanceof ArrayBuffer;\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  return {\n\t    \"getGLTypeForTypedArray\": getGLTypeForTypedArray,\n\t    \"getTypedArrayTypeForGLType\": getTypedArrayTypeForGLType,\n\t    \"isArrayBuffer\": isArrayBuffer,\n\t  };\n\t});\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/utils',[], function() {\n\t\n\t\n\t  /**\n\t   * Copy an object 1 level deep\n\t   * @param {object} src object to copy\n\t   * @return {object} the copy\n\t   */\n\t  function shallowCopy(src) {\n\t    var dst = {};\n\t    Object.keys(src).forEach(function(key) {\n\t      dst[key] = src[key];\n\t    });\n\t    return dst;\n\t  }\n\t\n\t  /**\n\t   * Copy named properties\n\t   *\n\t   * @param {string[]} names names of properties to copy\n\t   * @param {object} src object to copy properties from\n\t   * @param {object} dst object to copy properties to\n\t   */\n\t  function copyNamedProperties(names, src, dst) {\n\t    names.forEach(function(name) {\n\t      var value = src[name];\n\t      if (value !== undefined) {\n\t        dst[name] = value;\n\t      }\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Copies properties from source to dest only if a matching key is in dest\n\t   *\n\t   * @param {Object.<string, ?>} src the source\n\t   * @param {Object.<string, ?>} dst the dest\n\t   */\n\t  function copyExistingProperties(src, dst) {\n\t    Object.keys(dst).forEach(function(key) {\n\t      if (dst.hasOwnProperty(key) && src.hasOwnProperty(key)) {\n\t        dst[key] = src[key];\n\t      }\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Gets the gl version as a number\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @return {number} version of gl\n\t   */\n\t  function getVersionAsNumber(gl) {\n\t    return parseFloat(gl.getParameter(gl.VERSION).substr(6));\n\t  }\n\t\n\t  /**\n\t   * Check if context is WebGL 2.0\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @return {bool} true if it's WebGL 2.0\n\t   * @memberOf module:twgl\n\t   */\n\t  function isWebGL2(gl) {\n\t    return gl.getParameter(gl.VERSION).indexOf(\"WebGL 2.0\") === 0;\n\t  }\n\t\n\t  /**\n\t   * Check if context is WebGL 1.0\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @return {bool} true if it's WebGL 1.0\n\t   * @memberOf module:twgl\n\t   */\n\t  function isWebGL1(gl) {\n\t    var version = getVersionAsNumber(gl);\n\t    return version <= 1.0 && version > 0.0;  // because as of 2016/5 Edge returns 0.96\n\t  }\n\t\n\t  var error =\n\t      (    window.console\n\t        && window.console.error\n\t        && typeof window.console.error === \"function\"\n\t      )\n\t      ? window.console.error.bind(window.console)\n\t      : function() { };\n\t\n\t  var warn =\n\t      (    window.console\n\t        && window.console.warn\n\t        && typeof window.console.warn === \"function\"\n\t      )\n\t      ? window.console.warn.bind(window.console)\n\t      : function() { };\n\t\n\t  return {\n\t    copyExistingProperties: copyExistingProperties,\n\t    copyNamedProperties: copyNamedProperties,\n\t    shallowCopy: shallowCopy,\n\t    isWebGL1: isWebGL1,\n\t    isWebGL2: isWebGL2,\n\t    error: error,\n\t    warn: warn,\n\t  };\n\t});\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/attributes',[\n\t    './typedarrays',\n\t    './utils',\n\t  ], function(\n\t    typedArrays,\n\t    utils) {\n\t\n\t\n\t  /**\n\t   * Low level attribute and buffer related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.attributes` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/attributes\n\t   */\n\t\n\t  // make sure we don't see a global gl\n\t  var gl = undefined;  // eslint-disable-line\n\t  var defaults = {\n\t    attribPrefix: \"\",\n\t  };\n\t\n\t  /**\n\t   * Sets the default attrib prefix\n\t   *\n\t   * When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`\n\t   * as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.\n\t   *\n\t   * In otherwords I'll create arrays of geometry like this\n\t   *\n\t   *     var arrays = {\n\t   *       position: ...\n\t   *       normal: ...\n\t   *       texcoord: ...\n\t   *     };\n\t   *\n\t   * But need those mapped to attributes and my attributes start with `a_`.\n\t   *\n\t   * @deprecated see {@link module:twgl.setDefaults}\n\t   * @param {string} prefix prefix for attribs\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function setAttributePrefix(prefix) {\n\t    defaults.attribPrefix = prefix;\n\t  }\n\t\n\t  function setDefaults(newDefaults) {\n\t    utils.copyExistingProperties(newDefaults, defaults);\n\t  }\n\t\n\t  function setBufferFromTypedArray(gl, type, buffer, array, drawType) {\n\t    gl.bindBuffer(type, buffer);\n\t    gl.bufferData(type, array, drawType || gl.STATIC_DRAW);\n\t  }\n\t\n\t  /**\n\t   * Given typed array creates a WebGLBuffer and copies the typed array\n\t   * into it.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {ArrayBuffer|ArrayBufferView|WebGLBuffer} typedArray the typed array. Note: If a WebGLBuffer is passed in it will just be returned. No action will be taken\n\t   * @param {number} [type] the GL bind type for the buffer. Default = `gl.ARRAY_BUFFER`.\n\t   * @param {number} [drawType] the GL draw type for the buffer. Default = 'gl.STATIC_DRAW`.\n\t   * @return {WebGLBuffer} the created WebGLBuffer\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBufferFromTypedArray(gl, typedArray, type, drawType) {\n\t    if (typedArray instanceof WebGLBuffer) {\n\t      return typedArray;\n\t    }\n\t    type = type || gl.ARRAY_BUFFER;\n\t    var buffer = gl.createBuffer();\n\t    setBufferFromTypedArray(gl, type, buffer, typedArray, drawType);\n\t    return buffer;\n\t  }\n\t\n\t  function isIndices(name) {\n\t    return name === \"indices\";\n\t  }\n\t\n\t  // This is really just a guess. Though I can't really imagine using\n\t  // anything else? Maybe for some compression?\n\t  function getNormalizationForTypedArray(typedArray) {\n\t    if (typedArray instanceof Int8Array)    { return true; }  // eslint-disable-line\n\t    if (typedArray instanceof Uint8Array)   { return true; }  // eslint-disable-line\n\t    return false;\n\t  }\n\t\n\t  function getArray(array) {\n\t    return array.length ? array : array.data;\n\t  }\n\t\n\t  var texcoordRE = /coord|texture/i;\n\t  var colorRE = /color|colour/i;\n\t\n\t  function guessNumComponentsFromName(name, length) {\n\t    var numComponents;\n\t    if (texcoordRE.test(name)) {\n\t      numComponents = 2;\n\t    } else if (colorRE.test(name)) {\n\t      numComponents = 4;\n\t    } else {\n\t      numComponents = 3;  // position, normals, indices ...\n\t    }\n\t\n\t    if (length % numComponents > 0) {\n\t      throw \"Can not guess numComponents for attribute '\" + name + \"'. Tried \" +\n\t            numComponents + \" but \" + length +\n\t            \" values is not evenly divisible by \" + numComponents +\n\t            \". You should specify it.\";\n\t    }\n\t\n\t    return numComponents;\n\t  }\n\t\n\t  function getNumComponents(array, arrayName) {\n\t    return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);\n\t  }\n\t\n\t  function makeTypedArray(array, name) {\n\t    if (typedArrays.isArrayBuffer(array)) {\n\t      return array;\n\t    }\n\t\n\t    if (typedArrays.isArrayBuffer(array.data)) {\n\t      return array.data;\n\t    }\n\t\n\t    if (Array.isArray(array)) {\n\t      array = {\n\t        data: array,\n\t      };\n\t    }\n\t\n\t    var Type = array.type;\n\t    if (!Type) {\n\t      if (isIndices(name)) {\n\t        Type = Uint16Array;\n\t      } else {\n\t        Type = Float32Array;\n\t      }\n\t    }\n\t    return new Type(array.data);\n\t  }\n\t\n\t  /**\n\t   * The info for an attribute. This is effectively just the arguments to `gl.vertexAttribPointer` plus the WebGLBuffer\n\t   * for the attribute.\n\t   *\n\t   * @typedef {Object} AttribInfo\n\t   * @property {number} [numComponents] the number of components for this attribute.\n\t   * @property {number} [size] synonym for `numComponents`.\n\t   * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`\n\t   * @property {boolean} [normalized] whether or not to normalize the data. Default = false\n\t   * @property {number} [offset] offset into buffer in bytes. Default = 0\n\t   * @property {number} [stride] the stride in bytes per element. Default = 0\n\t   * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute\n\t   * @property {number} [drawType] the draw type passed to gl.bufferData. Default = gl.STATIC_DRAW\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Use this type of array spec when TWGL can't guess the type or number of compoments of an array\n\t   * @typedef {Object} FullArraySpec\n\t   * @property {(number[]|ArrayBuffer)} data The data of the array.\n\t   * @property {number} [numComponents] number of components for `vertexAttribPointer`. Default is based on the name of the array.\n\t   *    If `coord` is in the name assumes `numComponents = 2`.\n\t   *    If `color` is in the name assumes `numComponents = 4`.\n\t   *    otherwise assumes `numComponents = 3`\n\t   * @property {constructor} type The type. This is only used if `data` is a JavaScript array. It is the constructor for the typedarray. (eg. `Uint8Array`).\n\t   * For example if you want colors in a `Uint8Array` you might have a `FullArraySpec` like `{ type: Uint8Array, data: [255,0,255,255, ...], }`.\n\t   * @property {number} [size] synonym for `numComponents`.\n\t   * @property {boolean} [normalize] normalize for `vertexAttribPointer`. Default is true if type is `Int8Array` or `Uint8Array` otherwise false.\n\t   * @property {number} [stride] stride for `vertexAttribPointer`. Default = 0\n\t   * @property {number} [offset] offset for `vertexAttribPointer`. Default = 0\n\t   * @property {string} [attrib] name of attribute this array maps to. Defaults to same name as array prefixed by the default attribPrefix.\n\t   * @property {string} [name] synonym for `attrib`.\n\t   * @property {string} [attribName] synonym for `attrib`.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * An individual array in {@link module:twgl.Arrays}\n\t   *\n\t   * When passed to {@link module:twgl.createBufferInfoFromArrays} if an ArraySpec is `number[]` or `ArrayBuffer`\n\t   * the types will be guessed based on the name. `indices` will be `Uint16Array`, everything else will\n\t   * be `Float32Array`\n\t   *\n\t   * @typedef {(number[]|ArrayBuffer|module:twgl.FullArraySpec)} ArraySpec\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * This is a JavaScript object of arrays by name. The names should match your shader's attributes. If your\n\t   * attributes have a common prefix you can specify it by calling {@link module:twgl.setAttributePrefix}.\n\t   *\n\t   *     Bare JavaScript Arrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: [-1, 1, 0],\n\t   *            normal: [0, 1, 0],\n\t   *            ...\n\t   *         }\n\t   *\n\t   *     Bare TypedArrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: new Float32Array([-1, 1, 0]),\n\t   *            color: new Uint8Array([255, 128, 64, 255]),\n\t   *            ...\n\t   *         }\n\t   *\n\t   * *   Will guess at `numComponents` if not specified based on name.\n\t   *\n\t   *     If `coord` is in the name assumes `numComponents = 2`\n\t   *\n\t   *     If `color` is in the name assumes `numComponents = 4`\n\t   *\n\t   *     otherwise assumes `numComponents = 3`\n\t   *\n\t   * Objects with various fields. See {@link module:twgl.FullArraySpec}.\n\t   *\n\t   *     var arrays = {\n\t   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n\t   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n\t   *     };\n\t   *\n\t   * @typedef {Object.<string, module:twgl.ArraySpec>} Arrays\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t\n\t  /**\n\t   * Creates a set of attribute data and WebGLBuffers from set of arrays\n\t   *\n\t   * Given\n\t   *\n\t   *      var arrays = {\n\t   *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n\t   *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },\n\t   *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n\t   *      };\n\t   *\n\t   * returns something like\n\t   *\n\t   *      var attribs = {\n\t   *        position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n\t   *        texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n\t   *        normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n\t   *        color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },\n\t   *      };\n\t   *\n\t   * notes:\n\t   *\n\t   * *   Arrays can take various forms\n\t   *\n\t   *     Bare JavaScript Arrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: [-1, 1, 0],\n\t   *            normal: [0, 1, 0],\n\t   *            ...\n\t   *         }\n\t   *\n\t   *     Bare TypedArrays\n\t   *\n\t   *         var arrays = {\n\t   *            position: new Float32Array([-1, 1, 0]),\n\t   *            color: new Uint8Array([255, 128, 64, 255]),\n\t   *            ...\n\t   *         }\n\t   *\n\t   * *   Will guess at `numComponents` if not specified based on name.\n\t   *\n\t   *     If `coord` is in the name assumes `numComponents = 2`\n\t   *\n\t   *     If `color` is in the name assumes `numComponents = 4`\n\t   *\n\t   *     otherwise assumes `numComponents = 3`\n\t   *\n\t   * @param {WebGLRenderingContext} gl The webgl rendering context.\n\t   * @param {module:twgl.Arrays} arrays The arrays\n\t   * @return {Object.<string, module:twgl.AttribInfo>} the attribs\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createAttribsFromArrays(gl, arrays) {\n\t    var attribs = {};\n\t    Object.keys(arrays).forEach(function(arrayName) {\n\t      if (!isIndices(arrayName)) {\n\t        var array = arrays[arrayName];\n\t        var attribName = array.attrib || array.name || array.attribName || (defaults.attribPrefix + arrayName);\n\t        var typedArray = makeTypedArray(array, arrayName);\n\t        attribs[attribName] = {\n\t          buffer:        createBufferFromTypedArray(gl, typedArray, undefined, array.drawType),\n\t          numComponents: getNumComponents(array, arrayName),\n\t          type:          typedArrays.getGLTypeForTypedArray(typedArray),\n\t          normalize:     array.normalize !== undefined ? array.normalize : getNormalizationForTypedArray(typedArray),\n\t          stride:        array.stride || 0,\n\t          offset:        array.offset || 0,\n\t          drawType:      array.drawType,\n\t        };\n\t      }\n\t    });\n\t    return attribs;\n\t  }\n\t\n\t  /**\n\t   * Sets the contents of a buffer attached to an attribInfo\n\t   *\n\t   * This is helper function to dynamically update a buffer.\n\t   *\n\t   * Let's say you make a bufferInfo\n\t   *\n\t   *     var arrays = {\n\t   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n\t   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n\t   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n\t   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n\t   *     };\n\t   *     var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\n\t   *\n\t   *  And you want to dynamically upate the positions. You could do this\n\t   *\n\t   *     // assuming arrays.position has already been updated with new data.\n\t   *     twgl.setAttribInfoBufferFromArray(gl, bufferInfo.attribs.position, arrays.position);\n\t   *\n\t   * @param {WebGLRenderingContext} gl\n\t   * @param {AttribInfo} attribInfo The attribInfo who's buffer contents to set. NOTE: If you have an attribute prefix\n\t   *   the name of the attribute will include the prefix.\n\t   * @param {ArraySpec} array Note: it is arguably ineffient to pass in anything but a typed array because anything\n\t   *    else will have to be converted to a typed array before it can be used by WebGL. During init time that\n\t   *    inefficiency is usually not important but if you're updating data dynamically best to be efficient.\n\t   * @param {number} [offset] an optional offset into the buffer. This is only an offset into the WebGL buffer\n\t   *    not the array. To pass in an offset into the array itself use a typed array and create an `ArrayBufferView`\n\t   *    for the portion of the array you want to use.\n\t   *\n\t   *        var someArray = new Float32Array(1000); // an array with 1000 floats\n\t   *        var someSubArray = new Float32Array(someArray.buffer, offsetInBytes, sizeInUnits); // a view into someArray\n\t   *\n\t   *    Now you can pass `someSubArray` into setAttribInfoBufferFromArray`\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function setAttribInfoBufferFromArray(gl, attribInfo, array, offset) {\n\t    array = makeTypedArray(array);\n\t    if (offset) {\n\t      gl.bindBuffer(gl.ARRAY_BUFFER, attribInfo.buffer);\n\t      gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);\n\t    } else {\n\t      setBufferFromTypedArray(gl, gl.ARRAY_BUFFER, attribInfo.buffer, array, attribInfo.drawType);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * tries to get the number of elements from a set of arrays.\n\t   */\n\t\n\t  var getNumElementsFromNonIndexedArrays = (function() {\n\t    var positionKeys = ['position', 'positions', 'a_position'];\n\t\n\t    return function getNumElementsFromNonIndexedArrays(arrays) {\n\t      var key;\n\t      for (var ii = 0; ii < positionKeys.length; ++ii) {\n\t        key = positionKeys[ii];\n\t        if (key in arrays) {\n\t          break;\n\t        }\n\t      }\n\t      if (ii === positionKeys.length) {\n\t        key = Object.keys(arrays)[0];\n\t      }\n\t      var array = arrays[key];\n\t      var length = getArray(array).length;\n\t      var numComponents = getNumComponents(array, key);\n\t      var numElements = length / numComponents;\n\t      if (length % numComponents > 0) {\n\t        throw \"numComponents \" + numComponents + \" not correct for length \" + length;\n\t      }\n\t      return numElements;\n\t    };\n\t  }());\n\t\n\t  /**\n\t   * @typedef {Object} BufferInfo\n\t   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n\t   * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..\n\t   * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.\n\t   * @property {Object.<string, module:twgl.AttribInfo>} [attribs] The attribs approriate to call `setAttributes`\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * @typedef {Object} VertexArrayInfo\n\t   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n\t   * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..\n\t   * @property {WebGLVertexArrayObject> [vertexArrayObject] a vertex array object\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Creates a BufferInfo from an object of arrays.\n\t   *\n\t   * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to\n\t   * {@link module:twgl:drawBufferInfo}.\n\t   *\n\t   * Given an object like\n\t   *\n\t   *     var arrays = {\n\t   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n\t   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n\t   *     };\n\t   *\n\t   *  Creates an BufferInfo like this\n\t   *\n\t   *     bufferInfo = {\n\t   *       numElements: 4,        // or whatever the number of elements is\n\t   *       indices: WebGLBuffer,  // this property will not exist if there are no indices\n\t   *       attribs: {\n\t   *         a_position: { buffer: WebGLBuffer, numComponents: 3, },\n\t   *         a_normal:   { buffer: WebGLBuffer, numComponents: 3, },\n\t   *         a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },\n\t   *       },\n\t   *     };\n\t   *\n\t   *  The properties of arrays can be JavaScript arrays in which case the number of components\n\t   *  will be guessed.\n\t   *\n\t   *     var arrays = {\n\t   *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],\n\t   *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],\n\t   *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],\n\t   *        indices:  [0, 1, 2, 1, 2, 3],\n\t   *     };\n\t   *\n\t   *  They can also by TypedArrays\n\t   *\n\t   *     var arrays = {\n\t   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n\t   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n\t   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n\t   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n\t   *     };\n\t   *\n\t   *  Or augmentedTypedArrays\n\t   *\n\t   *     var positions = createAugmentedTypedArray(3, 4);\n\t   *     var texcoords = createAugmentedTypedArray(2, 4);\n\t   *     var normals   = createAugmentedTypedArray(3, 4);\n\t   *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);\n\t   *\n\t   *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);\n\t   *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);\n\t   *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);\n\t   *     indices.push([0, 1, 2, 1, 2, 3]);\n\t   *\n\t   *     var arrays = {\n\t   *        position: positions,\n\t   *        texcoord: texcoords,\n\t   *        normal:   normals,\n\t   *        indices:  indices,\n\t   *     };\n\t   *\n\t   * For the last example it is equivalent to\n\t   *\n\t   *     var bufferInfo = {\n\t   *       attribs: {\n\t   *         a_position: { numComponents: 3, buffer: gl.createBuffer(), },\n\t   *         a_texcoods: { numComponents: 2, buffer: gl.createBuffer(), },\n\t   *         a_normals: { numComponents: 3, buffer: gl.createBuffer(), },\n\t   *       },\n\t   *       indices: gl.createBuffer(),\n\t   *       numElements: 6,\n\t   *     };\n\t   *\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_position.buffer);\n\t   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_texcoord.buffer);\n\t   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_normal.buffer);\n\t   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);\n\t   *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);\n\t   *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {module:twgl.Arrays} arrays Your data\n\t   * @return {module:twgl.BufferInfo} A BufferInfo\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBufferInfoFromArrays(gl, arrays) {\n\t    var bufferInfo = {\n\t      attribs: createAttribsFromArrays(gl, arrays),\n\t    };\n\t    var indices = arrays.indices;\n\t    if (indices) {\n\t      indices = makeTypedArray(indices, \"indices\");\n\t      bufferInfo.indices = createBufferFromTypedArray(gl, indices, gl.ELEMENT_ARRAY_BUFFER);\n\t      bufferInfo.numElements = indices.length;\n\t      bufferInfo.elementType = typedArrays.getGLTypeForTypedArray(indices);\n\t    } else {\n\t      bufferInfo.numElements = getNumElementsFromNonIndexedArrays(arrays);\n\t    }\n\t\n\t    return bufferInfo;\n\t  }\n\t\n\t  /**\n\t   * Creates a buffer from an array, typed array, or array spec\n\t   *\n\t   * Given something like this\n\t   *\n\t   *     [1, 2, 3],\n\t   *\n\t   * or\n\t   *\n\t   *     new Uint16Array([1,2,3]);\n\t   *\n\t   * or\n\t   *\n\t   *     {\n\t   *        data: [1, 2, 3],\n\t   *        type: Uint8Array,\n\t   *     }\n\t   *\n\t   * returns a WebGLBuffer that constains the given data.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n\t   * @param {module:twgl.ArraySpec} array an array, typed array, or array spec.\n\t   * @param {string} arrayName name of array. Used to guess the type if type can not be dervied other wise.\n\t   * @return {WebGLBuffer} a WebGLBuffer containing the data in array.\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBufferFromArray(gl, array, arrayName) {\n\t    var type = arrayName === \"indices\" ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n\t    var typedArray = makeTypedArray(array, arrayName);\n\t    return createBufferFromTypedArray(gl, typedArray, type);\n\t  }\n\t\n\t  /**\n\t   * Creates buffers from arrays or typed arrays\n\t   *\n\t   * Given something like this\n\t   *\n\t   *     var arrays = {\n\t   *        positions: [1, 2, 3],\n\t   *        normals: [0, 0, 1],\n\t   *     }\n\t   *\n\t   * returns something like\n\t   *\n\t   *     buffers = {\n\t   *       positions: WebGLBuffer,\n\t   *       normals: WebGLBuffer,\n\t   *     }\n\t   *\n\t   * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n\t   * @param {module:twgl.Arrays} arrays\n\t   * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createBuffersFromArrays(gl, arrays) {\n\t    var buffers = { };\n\t    Object.keys(arrays).forEach(function(key) {\n\t      buffers[key] = createBufferFromArray(gl, arrays[key], key);\n\t    });\n\t\n\t    return buffers;\n\t  }\n\t\n\t  /**\n\t   * Creates a BufferInfo from an object of arrays.\n\t   *\n\t   * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to\n\t   * {@link module:twgl:drawBufferInfo}.\n\t   *\n\t   * > **IMPORTANT:** Vertex Array Objects are **not** a direct analog for a BufferInfo. Vertex Array Objects\n\t   *   assign buffers to specific attributes at creation time. That means they can only be used with programs\n\t   *   who's attributes use the same attribute locations for the same purposes.\n\t   *\n\t   * > Bind your attribute locations by passing an array of attribute names to {@link module:twgl.createProgramInfo}\n\t   *   or use WebGL 2's GLSL ES 3's `layout(location = <num>)` to make sure locations match.\n\t   *\n\t   * also\n\t   *\n\t   * > **IMPORTANT:** After calling twgl.setBuffersAndAttribute with a BufferInfo that uses a Vertex Array Object\n\t   *   that Vertex Array Object will be bound. That means **ANY MANIPULATION OF ELEMENT_ARRAY_BUFFER or ATTRIBUTES**\n\t   *   will affect the Vertex Array Object state.\n\t   *\n\t   * > Call `gl.bindVertexArray(null)` to get back manipulating the global attributes and ELEMENT_ARRAY_BUFFER.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {module:twgl.ProgramInfo|module:twgl.ProgramInfo[]} programInfo a programInfo or array of programInfos\n\t   *\n\t   *    You need to make sure every attribute that will be used is bound. So for example assume shader 1\n\t   *    uses attributes A, B, C and shader 2 uses attributes A, B, D. If you only pass in the programInfo\n\t   *    for shader 1 then only attributes A, B, and C will have their attributes set because TWGL doesn't\n\t   *    now attribute D's location.\n\t   *\n\t   *    So, you can pass in both shader 1 and shader 2's programInfo\n\t   *\n\t   * @return {module:twgl.VertexArrayInfo} The created VertexArrayInfo\n\t   *\n\t   * @memberOf module:twgl/attributes\n\t   */\n\t  function createVertexArrayInfo(gl, programInfos, bufferInfo) {\n\t    var vao = gl.createVertexArray();\n\t    gl.bindVertexArray(vao);\n\t    if (!programInfos.length) {\n\t      programInfos = [programInfos];\n\t    }\n\t    programInfos.forEach(function(programInfo) {\n\t      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n\t    });\n\t    gl.bindVertexArray(null);\n\t    return {\n\t      numElements: bufferInfo.numElements,\n\t      elementType: bufferInfo.elementType,\n\t      vertexArrayObject: vao,\n\t    };\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"createAttribsFromArrays\": createAttribsFromArrays,\n\t    \"createBuffersFromArrays\": createBuffersFromArrays,\n\t    \"createBufferFromArray\": createBufferFromArray,\n\t    \"createBufferFromTypedArray\": createBufferFromTypedArray,\n\t    \"createBufferInfoFromArrays\": createBufferInfoFromArrays,\n\t    \"setAttribInfoBufferFromArray\": setAttribInfoBufferFromArray,\n\t\n\t    \"createVertexArrayInfo\": createVertexArrayInfo,\n\t\n\t    \"setAttributePrefix\": setAttributePrefix,\n\t\n\t    \"setDefaults_\": setDefaults,\n\t    \"getNumComponents_\": getNumComponents,\n\t    \"getArray_\": getArray,\n\t  };\n\t\n\t});\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/programs',[\n\t    './utils',\n\t  ], function(\n\t    utils) {\n\t\n\t\n\t  /**\n\t   * Low level shader program related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.programs` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/programs\n\t   */\n\t\n\t  var error = utils.error;\n\t  var warn = utils.warn;\n\t\n\t  var FLOAT                         = 0x1406;\n\t  var FLOAT_VEC2                    = 0x8B50;\n\t  var FLOAT_VEC3                    = 0x8B51;\n\t  var FLOAT_VEC4                    = 0x8B52;\n\t  var INT                           = 0x1404;\n\t  var INT_VEC2                      = 0x8B53;\n\t  var INT_VEC3                      = 0x8B54;\n\t  var INT_VEC4                      = 0x8B55;\n\t  var BOOL                          = 0x8B56;\n\t  var BOOL_VEC2                     = 0x8B57;\n\t  var BOOL_VEC3                     = 0x8B58;\n\t  var BOOL_VEC4                     = 0x8B59;\n\t  var FLOAT_MAT2                    = 0x8B5A;\n\t  var FLOAT_MAT3                    = 0x8B5B;\n\t  var FLOAT_MAT4                    = 0x8B5C;\n\t  var SAMPLER_2D                    = 0x8B5E;\n\t  var SAMPLER_CUBE                  = 0x8B60;\n\t  var SAMPLER_3D                    = 0x8B5F;\n\t  var SAMPLER_2D_SHADOW             = 0x8B62;\n\t  var FLOAT_MAT2x3                  = 0x8B65;\n\t  var FLOAT_MAT2x4                  = 0x8B66;\n\t  var FLOAT_MAT3x2                  = 0x8B67;\n\t  var FLOAT_MAT3x4                  = 0x8B68;\n\t  var FLOAT_MAT4x2                  = 0x8B69;\n\t  var FLOAT_MAT4x3                  = 0x8B6A;\n\t  var SAMPLER_2D_ARRAY              = 0x8DC1;\n\t  var SAMPLER_2D_ARRAY_SHADOW       = 0x8DC4;\n\t  var SAMPLER_CUBE_SHADOW           = 0x8DC5;\n\t  var UNSIGNED_INT                  = 0x1405;\n\t  var UNSIGNED_INT_VEC2             = 0x8DC6;\n\t  var UNSIGNED_INT_VEC3             = 0x8DC7;\n\t  var UNSIGNED_INT_VEC4             = 0x8DC8;\n\t  var INT_SAMPLER_2D                = 0x8DCA;\n\t  var INT_SAMPLER_3D                = 0x8DCB;\n\t  var INT_SAMPLER_CUBE              = 0x8DCC;\n\t  var INT_SAMPLER_2D_ARRAY          = 0x8DCF;\n\t  var UNSIGNED_INT_SAMPLER_2D       = 0x8DD2;\n\t  var UNSIGNED_INT_SAMPLER_3D       = 0x8DD3;\n\t  var UNSIGNED_INT_SAMPLER_CUBE     = 0x8DD4;\n\t  var UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;\n\t\n\t  var TEXTURE_2D                    = 0x0DE1;\n\t  var TEXTURE_CUBE_MAP              = 0x8513;\n\t  var TEXTURE_3D                    = 0x806F;\n\t  var TEXTURE_2D_ARRAY              = 0x8C1A;\n\t\n\t  var typeMap = {};\n\t\n\t  /**\n\t   * Returns the corresponding bind point for a given sampler type\n\t   */\n\t  function getBindPointForSamplerType(gl, type) {\n\t    return typeMap[type].bindPoint;\n\t  }\n\t\n\t  // This kind of sucks! If you could compose functions as in `var fn = gl[name];`\n\t  // this code could be a lot smaller but that is sadly really slow (T_T)\n\t\n\t  function floatSetter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform1f(location, v);\n\t    };\n\t  }\n\t\n\t  function floatArraySetter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform1fv(location, v);\n\t    };\n\t  }\n\t\n\t  function floatVec2Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform2fv(location, v);\n\t    };\n\t  }\n\t\n\t  function floatVec3Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform3fv(location, v);\n\t    };\n\t  }\n\t\n\t  function floatVec4Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform4fv(location, v);\n\t    };\n\t  }\n\t\n\t  function intSetter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform1i(location, v);\n\t    };\n\t  }\n\t\n\t  function intArraySetter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform1iv(location, v);\n\t    };\n\t  }\n\t\n\t  function intVec2Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform2iv(location, v);\n\t    };\n\t  }\n\t\n\t  function intVec3Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform3iv(location, v);\n\t    };\n\t  }\n\t\n\t  function intVec4Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform4iv(location, v);\n\t    };\n\t  }\n\t\n\t  function uintSetter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform1ui(location, v);\n\t    };\n\t  }\n\t\n\t  function uintArraySetter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform1uiv(location, v);\n\t    };\n\t  }\n\t\n\t  function uintVec2Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform2uiv(location, v);\n\t    };\n\t  }\n\t\n\t  function uintVec3Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform3uiv(location, v);\n\t    };\n\t  }\n\t\n\t  function uintVec4Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniform4uiv(location, v);\n\t    };\n\t  }\n\t\n\t  function floatMat2Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix2fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat3Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix3fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat4Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix4fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat23Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix2x3fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat32Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix3x2fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat24Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix2x4fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat42Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix4x2fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat34Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix3x4fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function floatMat43Setter(gl, location) {\n\t    return function(v) {\n\t      gl.uniformMatrix4x3fv(location, false, v);\n\t    };\n\t  }\n\t\n\t  function samplerSetter(gl, type, unit, location) {\n\t    var bindPoint = getBindPointForSamplerType(gl, type);\n\t    return function(texture) {\n\t      gl.uniform1i(location, unit);\n\t      gl.activeTexture(gl.TEXTURE0 + unit);\n\t      gl.bindTexture(bindPoint, texture);\n\t    };\n\t  }\n\t\n\t  function samplerArraySetter(gl, type, unit, location, size) {\n\t    var bindPoint = getBindPointForSamplerType(gl, type);\n\t    var units = new Int32Array(size);\n\t    for (var ii = 0; ii < size; ++ii) {\n\t      units[ii] = unit + ii;\n\t    }\n\t\n\t    return function(textures) {\n\t      gl.uniform1iv(location, units);\n\t      textures.forEach(function(texture, index) {\n\t        gl.activeTexture(gl.TEXTURE0 + units[index]);\n\t        gl.bindTexture(bindPoint, texture);\n\t      });\n\t    };\n\t  }\n\t\n\t  typeMap[FLOAT]                         = { Type: Float32Array, size:  4, setter: floatSetter,      arraySetter: floatArraySetter, };\n\t  typeMap[FLOAT_VEC2]                    = { Type: Float32Array, size:  8, setter: floatVec2Setter,  };\n\t  typeMap[FLOAT_VEC3]                    = { Type: Float32Array, size: 12, setter: floatVec3Setter,  };\n\t  typeMap[FLOAT_VEC4]                    = { Type: Float32Array, size: 16, setter: floatVec4Setter,  };\n\t  typeMap[INT]                           = { Type: Int32Array,   size:  4, setter: intSetter,        arraySetter: intArraySetter, };\n\t  typeMap[INT_VEC2]                      = { Type: Int32Array,   size:  8, setter: intVec2Setter,    };\n\t  typeMap[INT_VEC3]                      = { Type: Int32Array,   size: 12, setter: intVec3Setter,    };\n\t  typeMap[INT_VEC4]                      = { Type: Int32Array,   size: 16, setter: intVec4Setter,    };\n\t  typeMap[UNSIGNED_INT]                  = { Type: Uint32Array,  size:  4, setter: uintSetter,       arraySetter: uintArraySetter, };\n\t  typeMap[UNSIGNED_INT_VEC2]             = { Type: Uint32Array,  size:  8, setter: uintVec2Setter,   };\n\t  typeMap[UNSIGNED_INT_VEC3]             = { Type: Uint32Array,  size: 12, setter: uintVec3Setter,   };\n\t  typeMap[UNSIGNED_INT_VEC4]             = { Type: Uint32Array,  size: 16, setter: uintVec4Setter,   };\n\t  typeMap[BOOL]                          = { Type: Uint32Array,  size:  4, setter: intSetter,        arraySetter: intArraySetter, };\n\t  typeMap[BOOL_VEC2]                     = { Type: Uint32Array,  size:  8, setter: intVec2Setter,    };\n\t  typeMap[BOOL_VEC3]                     = { Type: Uint32Array,  size: 12, setter: intVec3Setter,    };\n\t  typeMap[BOOL_VEC4]                     = { Type: Uint32Array,  size: 16, setter: intVec4Setter,    };\n\t  typeMap[FLOAT_MAT2]                    = { Type: Float32Array, size: 16, setter: floatMat2Setter,  };\n\t  typeMap[FLOAT_MAT3]                    = { Type: Float32Array, size: 36, setter: floatMat3Setter,  };\n\t  typeMap[FLOAT_MAT4]                    = { Type: Float32Array, size: 64, setter: floatMat4Setter,  };\n\t  typeMap[FLOAT_MAT2x3]                  = { Type: Float32Array, size: 24, setter: floatMat23Setter, };\n\t  typeMap[FLOAT_MAT2x4]                  = { Type: Float32Array, size: 32, setter: floatMat24Setter, };\n\t  typeMap[FLOAT_MAT3x2]                  = { Type: Float32Array, size: 24, setter: floatMat32Setter, };\n\t  typeMap[FLOAT_MAT3x4]                  = { Type: Float32Array, size: 48, setter: floatMat34Setter, };\n\t  typeMap[FLOAT_MAT4x2]                  = { Type: Float32Array, size: 32, setter: floatMat42Setter, };\n\t  typeMap[FLOAT_MAT4x3]                  = { Type: Float32Array, size: 48, setter: floatMat43Setter, };\n\t  typeMap[SAMPLER_2D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n\t  typeMap[SAMPLER_CUBE]                  = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n\t  typeMap[SAMPLER_3D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };\n\t  typeMap[SAMPLER_2D_SHADOW]             = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n\t  typeMap[SAMPLER_2D_ARRAY]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n\t  typeMap[SAMPLER_2D_ARRAY_SHADOW]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n\t  typeMap[SAMPLER_CUBE_SHADOW]           = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n\t  typeMap[INT_SAMPLER_2D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n\t  typeMap[INT_SAMPLER_3D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };\n\t  typeMap[INT_SAMPLER_CUBE]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n\t  typeMap[INT_SAMPLER_2D_ARRAY]          = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n\t  typeMap[UNSIGNED_INT_SAMPLER_2D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n\t  typeMap[UNSIGNED_INT_SAMPLER_3D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };\n\t  typeMap[UNSIGNED_INT_SAMPLER_CUBE]     = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n\t  typeMap[UNSIGNED_INT_SAMPLER_2D_ARRAY] = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n\t\n\t  var attrTypeMap = {};\n\t  attrTypeMap[FLOAT_MAT2] = { size:  4, count: 2, };\n\t  attrTypeMap[FLOAT_MAT3] = { size:  9, count: 3, };\n\t  attrTypeMap[FLOAT_MAT4] = { size: 16, count: 4, };\n\t\n\t  // make sure we don't see a global gl\n\t  var gl = undefined;  // eslint-disable-line\n\t\n\t  /**\n\t   * Error Callback\n\t   * @callback ErrorCallback\n\t   * @param {string} msg error message.\n\t   * @param {number} [lineOffset] amount to add to line number\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  function addLineNumbers(src, lineOffset) {\n\t    lineOffset = lineOffset || 0;\n\t    ++lineOffset;\n\t\n\t    return src.split(\"\\n\").map(function(line, ndx) {\n\t      return (ndx + lineOffset) + \": \" + line;\n\t    }).join(\"\\n\");\n\t  }\n\t\n\t  var spaceRE = /^[ \\t]*\\n/;\n\t\n\t  /**\n\t   * Loads a shader.\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {string} shaderSource The shader source.\n\t   * @param {number} shaderType The type of shader.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors.\n\t   * @return {WebGLShader} The created shader.\n\t   */\n\t  function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\n\t    var errFn = opt_errorCallback || error;\n\t    // Create the shader object\n\t    var shader = gl.createShader(shaderType);\n\t\n\t    // Remove the first end of line because WebGL 2.0 notrequirebecasebrowserifymessesups\n\t    // #version 300 es\n\t    // as the first line. No whitespace allowed before that line\n\t    // so\n\t    //\n\t    // <script>\n\t    // #version 300 es\n\t    // </script>\n\t    //\n\t    // Has one line before it which is invalid according to GLSL ES 3.00\n\t    //\n\t    var lineOffset = 0;\n\t    if (spaceRE.test(shaderSource)) {\n\t      lineOffset = 1;\n\t      shaderSource = shaderSource.replace(spaceRE, '');\n\t    }\n\t\n\t    // Load the shader source\n\t    gl.shaderSource(shader, shaderSource);\n\t\n\t    // Compile the shader\n\t    gl.compileShader(shader);\n\t\n\t    // Check the compile status\n\t    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\t    if (!compiled) {\n\t      // Something went wrong during compilation; get the error\n\t      var lastError = gl.getShaderInfoLog(shader);\n\t      errFn(addLineNumbers(shaderSource, lineOffset) + \"\\n*** Error compiling shader: \" + lastError);\n\t      gl.deleteShader(shader);\n\t      return null;\n\t    }\n\t\n\t    return shader;\n\t  }\n\t\n\t  /**\n\t   * Creates a program, attaches shaders, binds attrib locations, links the\n\t   * program and calls useProgram.\n\t   *\n\t   * NOTE: There are 3 signatures for this function\n\t   *\n\t   *     twgl.createProgram(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLShader[]} shaders The shaders to attach\n\t   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {WebGLProgram?} the created program or null if error.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgram(\n\t      gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {\n\t    if (typeof opt_locations === 'function') {\n\t      opt_errorCallback = opt_locations;\n\t      opt_locations = undefined;\n\t    }\n\t    if (typeof opt_attribs === 'function') {\n\t      opt_errorCallback = opt_attribs;\n\t      opt_attribs = undefined;\n\t    }\n\t    var errFn = opt_errorCallback || error;\n\t    var program = gl.createProgram();\n\t    shaders.forEach(function(shader) {\n\t      gl.attachShader(program, shader);\n\t    });\n\t    if (opt_attribs) {\n\t      opt_attribs.forEach(function(attrib,  ndx) {\n\t        gl.bindAttribLocation(\n\t            program,\n\t            opt_locations ? opt_locations[ndx] : ndx,\n\t            attrib);\n\t      });\n\t    }\n\t    gl.linkProgram(program);\n\t\n\t    // Check the link status\n\t    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\t    if (!linked) {\n\t        // something went wrong with the link\n\t        var lastError = gl.getProgramInfoLog(program);\n\t        errFn(\"Error in program linking:\" + lastError);\n\t\n\t        gl.deleteProgram(program);\n\t        return null;\n\t    }\n\t    return program;\n\t  }\n\t\n\t  /**\n\t   * Loads a shader from a script tag.\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n\t   * @param {string} scriptId The id of the script tag.\n\t   * @param {number} [opt_shaderType] The type of shader. If not passed in it will\n\t   *     be derived from the type of the script tag.\n\t   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors.\n\t   * @return {WebGLShader?} The created shader or null if error.\n\t   */\n\t  function createShaderFromScript(\n\t      gl, scriptId, opt_shaderType, opt_errorCallback) {\n\t    var shaderSource = \"\";\n\t    var shaderType;\n\t    var shaderScript = document.getElementById(scriptId);\n\t    if (!shaderScript) {\n\t      throw \"*** Error: unknown script element\" + scriptId;\n\t    }\n\t    shaderSource = shaderScript.text;\n\t\n\t    if (!opt_shaderType) {\n\t      if (shaderScript.type === \"x-shader/x-vertex\") {\n\t        shaderType = gl.VERTEX_SHADER;\n\t      } else if (shaderScript.type === \"x-shader/x-fragment\") {\n\t        shaderType = gl.FRAGMENT_SHADER;\n\t      } else if (shaderType !== gl.VERTEX_SHADER && shaderType !== gl.FRAGMENT_SHADER) {\n\t        throw \"*** Error: unknown shader type\";\n\t      }\n\t    }\n\t\n\t    return loadShader(\n\t        gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,\n\t        opt_errorCallback);\n\t  }\n\t\n\t  var defaultShaderType = [\n\t    \"VERTEX_SHADER\",\n\t    \"FRAGMENT_SHADER\",\n\t  ];\n\t\n\t  /**\n\t   * Creates a program from 2 script tags.\n\t   *\n\t   * NOTE: There are 3 signatures for this function\n\t   *\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {string[]} shaderScriptIds Array of ids of the script\n\t   *        tags for the shaders. The first is assumed to be the\n\t   *        vertex shader, the second the fragment shader.\n\t   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {WebGLProgram} The created program.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramFromScripts(\n\t      gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {\n\t    var shaders = [];\n\t    for (var ii = 0; ii < shaderScriptIds.length; ++ii) {\n\t      var shader = createShaderFromScript(\n\t          gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], opt_errorCallback);\n\t      if (!shader) {\n\t        return null;\n\t      }\n\t      shaders.push(shader);\n\t    }\n\t    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n\t  }\n\t\n\t  /**\n\t   * Creates a program from 2 sources.\n\t   *\n\t   * NOTE: There are 3 signatures for this function\n\t   *\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {string[]} shaderSourcess Array of sources for the\n\t   *        shaders. The first is assumed to be the vertex shader,\n\t   *        the second the fragment shader.\n\t   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {WebGLProgram} The created program.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramFromSources(\n\t      gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n\t    var shaders = [];\n\t    for (var ii = 0; ii < shaderSources.length; ++ii) {\n\t      var shader = loadShader(\n\t          gl, shaderSources[ii], gl[defaultShaderType[ii]], opt_errorCallback);\n\t      if (!shader) {\n\t        return null;\n\t      }\n\t      shaders.push(shader);\n\t    }\n\t    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n\t  }\n\t\n\t  /**\n\t   * Creates setter functions for all uniforms of a shader\n\t   * program.\n\t   *\n\t   * @see {@link module:twgl.setUniforms}\n\t   *\n\t   * @param {WebGLProgram} program the program to create setters for.\n\t   * @returns {Object.<string, function>} an object with a setter by name for each uniform\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformSetters(gl, program) {\n\t    var textureUnit = 0;\n\t\n\t    /**\n\t     * Creates a setter for a uniform of the given program with it's\n\t     * location embedded in the setter.\n\t     * @param {WebGLProgram} program\n\t     * @param {WebGLUniformInfo} uniformInfo\n\t     * @returns {function} the created setter.\n\t     */\n\t    function createUniformSetter(program, uniformInfo) {\n\t      var location = gl.getUniformLocation(program, uniformInfo.name);\n\t      var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === \"[0]\");\n\t      var type = uniformInfo.type;\n\t      var typeInfo = typeMap[type];\n\t      if (!typeInfo) {\n\t        throw (\"unknown type: 0x\" + type.toString(16)); // we should never get here.\n\t      }\n\t      if (typeInfo.bindPoint) {\n\t        // it's a sampler\n\t        var unit = textureUnit;\n\t        textureUnit += uniformInfo.size;\n\t\n\t        if (isArray) {\n\t          return typeInfo.arraySetter(gl, type, unit, location, uniformInfo.size);\n\t        } else {\n\t          return typeInfo.setter(gl, type, unit, location, uniformInfo.size);\n\t        }\n\t      } else {\n\t        if (typeInfo.arraySetter && isArray) {\n\t          return typeInfo.arraySetter(gl, location);\n\t        } else {\n\t          return typeInfo.setter(gl, location);\n\t        }\n\t      }\n\t    }\n\t\n\t    var uniformSetters = { };\n\t    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\t\n\t    for (var ii = 0; ii < numUniforms; ++ii) {\n\t      var uniformInfo = gl.getActiveUniform(program, ii);\n\t      if (!uniformInfo) {\n\t        break;\n\t      }\n\t      var name = uniformInfo.name;\n\t      // remove the array suffix.\n\t      if (name.substr(-3) === \"[0]\") {\n\t        name = name.substr(0, name.length - 3);\n\t      }\n\t      var setter = createUniformSetter(program, uniformInfo);\n\t      uniformSetters[name] = setter;\n\t    }\n\t    return uniformSetters;\n\t  }\n\t\n\t  /**\n\t   * @typedef {Object} UniformData\n\t   * @property {number} type The WebGL type enum for this uniform\n\t   * @property {number} size The number of elements for this uniform\n\t   * @property {number} blockNdx The block index this uniform appears in\n\t   * @property {number} offset The byte offset in the block for this uniform's value\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * The specification for one UniformBlockObject\n\t   *\n\t   * @typedef {Object} BlockSpec\n\t   * @property {number} index The index of the block.\n\t   * @property {number} size The size in bytes needed for the block\n\t   * @property {number[]} uniformIndices The indices of the uniforms used by the block. These indices\n\t   *    correspond to entries in a UniformData array in the {@link module:twgl.UniformBlockSpec}.\n\t   * @property {bool} usedByVertexShader Self explanitory\n\t   * @property {bool} usedByFragmentShader Self explanitory\n\t   * @property {bool} used Self explanitory\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * A `UniformBlockSpec` represents the data needed to create and bind\n\t   * UniformBlockObjects for a given program\n\t   *\n\t   * @typedef {Object} UniformBlockSpec\n\t   * @property {Object.<string, module:twgl.BlockSpec> blockSpecs The BlockSpec for each block by block name\n\t   * @property {UniformData[]} uniformData An array of data for each uniform by uniform index.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Creates a UniformBlockSpec for the given program.\n\t   *\n\t   * A UniformBlockSpec represents the data needed to create and bind\n\t   * UniformBlockObjects\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL2 Rendering Context\n\t   * @param {WebGLProgram} program A WebGLProgram for a successfully linked program\n\t   * @return {module:twgl.UniformBlockSpec} The created UniformBlockSpec\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformBlockSpecFromProgram(gl, program) {\n\t    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\t    var uniformData = [];\n\t    var uniformIndices = [];\n\t\n\t    for (var ii = 0; ii < numUniforms; ++ii) {\n\t      uniformIndices.push(ii);\n\t      uniformData.push({});\n\t      var uniformInfo = gl.getActiveUniform(program, ii);\n\t      if (!uniformInfo) {\n\t        break;\n\t      }\n\t      // REMOVE [0]?\n\t      uniformData[ii].name = uniformInfo.name;\n\t    }\n\t\n\t    [\n\t      [ \"UNIFORM_TYPE\", \"type\" ],\n\t      [ \"UNIFORM_SIZE\", \"size\" ],  // num elements\n\t      [ \"UNIFORM_BLOCK_INDEX\", \"blockNdx\" ],\n\t      [ \"UNIFORM_OFFSET\", \"offset\", ],\n\t    ].forEach(function(pair) {\n\t      var pname = pair[0];\n\t      var key = pair[1];\n\t      gl.getActiveUniforms(program, uniformIndices, gl[pname]).forEach(function(value, ndx) {\n\t        uniformData[ndx][key] = value;\n\t      });\n\t    });\n\t\n\t    var blockSpecs = {};\n\t\n\t    var numUniformBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n\t    for (ii = 0; ii < numUniformBlocks; ++ii) {\n\t      var name = gl.getActiveUniformBlockName(program, ii);\n\t      var blockSpec = {\n\t        index: ii,\n\t        usedByVertexShader: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),\n\t        usedByFragmentShader: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),\n\t        size: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_DATA_SIZE),\n\t        uniformIndices: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),\n\t      };\n\t      blockSpec.used = blockSpec.usedByVertexSahder || blockSpec.usedByFragmentShader;\n\t      blockSpecs[name] = blockSpec;\n\t    }\n\t\n\t    return {\n\t      blockSpecs: blockSpecs,\n\t      uniformData: uniformData,\n\t    };\n\t  }\n\t\n\t  var arraySuffixRE = /\\[\\d+\\]\\.$/;  // better way to check?\n\t\n\t  /**\n\t   * Represents a UniformBlockObject including an ArrayBuffer with all the uniform values\n\t   * and a corresponding WebGLBuffer to hold those values on the GPU\n\t   *\n\t   * @typedef {Object} UniformBlockInfo\n\t   * @property {string} name The name of the block\n\t   * @property {ArrayBuffer} array The array buffer that contains the uniform values\n\t   * @property {Float32Array} asFloat A float view on the array buffer. This is useful\n\t   *    inspecting the contents of the buffer in the debugger.\n\t   * @property {WebGLBuffer} buffer A WebGL buffer that will hold a copy of the uniform values for rendering.\n\t   * @property {number} [offset] offset into buffer\n\t   * @property {Object.<string, ArrayBufferView>} uniforms A uniform name to ArrayBufferView map.\n\t   *   each Uniform has a correctly typed `ArrayBufferView` into array at the correct offset\n\t   *   and length of that uniform. So for example a float uniform would have a 1 float `Float32Array`\n\t   *   view. A single mat4 would have a 16 element `Float32Array` view. An ivec2 would have an\n\t   *   `Int32Array` view, etc.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Creates a `UniformBlockInfo` for the specified block\n\t   *\n\t   * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy\n\t   * `UniformBlockInfo` is returned**. This is because when debugging GLSL\n\t   * it is common to comment out large portions of a shader or for example set\n\t   * the final output to a constant. When that happens blocks get optimized out.\n\t   * If this function did not create dummy blocks your code would crash when debugging.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext\n\t   * @param {WebGLProgram} program A WebGLProgram\n\t   * @param {module:twgl.UniformBlockSpec} uinformBlockSpec. A UniformBlockSpec as returned\n\t   *     from {@link module:twgl.createUniformBlockSpecFromProgram}.\n\t   * @param {string} blockName The name of the block.\n\t   * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformBlockInfoFromProgram(gl, program, uniformBlockSpec, blockName) {\n\t    var blockSpecs = uniformBlockSpec.blockSpecs;\n\t    var uniformData = uniformBlockSpec.uniformData;\n\t    var blockSpec = blockSpecs[blockName];\n\t    if (!blockSpec) {\n\t      warn(\"no uniform block object named:\", blockName);\n\t      return {\n\t        name: blockName,\n\t        uniforms: {},\n\t      };\n\t    }\n\t    var array = new ArrayBuffer(blockSpec.size);\n\t    var buffer = gl.createBuffer();\n\t    var uniformBufferIndex = blockSpec.index;\n\t    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);\n\t    gl.uniformBlockBinding(program, blockSpec.index, uniformBufferIndex);\n\t\n\t    var prefix = blockName + \".\";\n\t    if (arraySuffixRE.test(prefix)) {\n\t      prefix = prefix.replace(arraySuffixRE, \".\");\n\t    }\n\t    var uniforms = {};\n\t    blockSpec.uniformIndices.forEach(function(uniformNdx) {\n\t      var data = uniformData[uniformNdx];\n\t      var typeInfo = typeMap[data.type];\n\t      var Type = typeInfo.Type;\n\t      var length = data.size * typeInfo.size;\n\t      var name = data.name;\n\t      if (name.substr(0, prefix.length) === prefix) {\n\t        name = name.substr(prefix.length);\n\t      }\n\t      uniforms[name] = new Type(array, data.offset, length / Type.BYTES_PER_ELEMENT);\n\t    });\n\t    return {\n\t      name: blockName,\n\t      array: array,\n\t      asFloat: new Float32Array(array),  // for debugging\n\t      buffer: buffer,\n\t      uniforms: uniforms,\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Creates a `UniformBlockInfo` for the specified block\n\t   *\n\t   * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy\n\t   * `UniformBlockInfo` is returned**. This is because when debugging GLSL\n\t   * it is common to comment out large portions of a shader or for example set\n\t   * the final output to a constant. When that happens blocks get optimized out.\n\t   * If this function did not create dummy blocks your code would crash when debugging.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext\n\t   * @param {module:twgl.ProgramInfo} programInfo a `ProgramInfo`\n\t   *     as returned from {@link module:twgl.createProgramInfo}\n\t   * @param {string} blockName The name of the block.\n\t   * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createUniformBlockInfo(gl, programInfo, blockName) {\n\t    return createUniformBlockInfoFromProgram(gl, programInfo.program, programInfo.uniformBlockSpec, blockName);\n\t  }\n\t\n\t  /**\n\t   * Binds a unform block to the matching uniform block point.\n\t   * Matches by blocks by name so blocks must have the same name not just the same\n\t   * structure.\n\t   *\n\t   * If you have changed any values and you upload the valus into the corresponding WebGLBuffer\n\t   * call {@link module:twgl.setUniformBlock} instead.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.\n\t   * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`\n\t   *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as\n\t   *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.\n\t   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from\n\t   *     {@link module:twgl.createUniformBlockInfo}.\n\t   * @return {bool} true if buffer was bound. If the programInfo has no block with the same block name\n\t   *     no buffer is bound.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function bindUniformBlock(gl, programInfo, uniformBlockInfo) {\n\t    var uniformBlockSpec = programInfo.uniformBlockSpec || programInfo;\n\t    var blockSpec = uniformBlockSpec.blockSpecs[uniformBlockInfo.name];\n\t    if (blockSpec) {\n\t      var bufferBindIndex = blockSpec.index;\n\t      gl.bindBufferRange(gl.UNIFORM_BUFFER, bufferBindIndex, uniformBlockInfo.buffer, uniformBlockInfo.offset || 0, uniformBlockInfo.array.byteLength);\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  /**\n\t   * Uploads the current uniform values to the corresponding WebGLBuffer\n\t   * and binds that buffer to the program's corresponding bind point for the uniform block object.\n\t   *\n\t   * If you haven't changed any values and you only need to bind the uniform block object\n\t   * call {@link module:twgl.bindUniformBlock} instead.\n\t   *\n\t   * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.\n\t   * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`\n\t   *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as\n\t   *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.\n\t   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from\n\t   *     {@link module:twgl.createUniformBlockInfo}.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setUniformBlock(gl, programInfo, uniformBlockInfo) {\n\t    if (bindUniformBlock(gl, programInfo, uniformBlockInfo)) {\n\t      gl.bufferData(gl.UNIFORM_BUFFER, uniformBlockInfo.array, gl.DYNAMIC_DRAW);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Sets values of a uniform block object\n\t   *\n\t   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo A UniformBlockInfo as returned by {@link module:twgl.createUniformBlockInfo}.\n\t   * @param {Object.<string, ?>} values A uniform name to value map where the value is correct for the given\n\t   *    type of uniform. So for example given a block like\n\t   *\n\t   *       uniform SomeBlock {\n\t   *         float someFloat;\n\t   *         vec2 someVec2;\n\t   *         vec3 someVec3Array[2];\n\t   *         int someInt;\n\t   *       }\n\t   *\n\t   *  You can set the values of the uniform block with\n\t   *\n\t   *       twgl.setBlockUniforms(someBlockInfo, {\n\t   *          someFloat: 12.3,\n\t   *          someVec2: [1, 2],\n\t   *          someVec3Array: [1, 2, 3, 4, 5, 6],\n\t   *          someInt: 5,\n\t   *       }\n\t   *\n\t   *  Arrays can be JavaScript arrays or typed arrays\n\t   *\n\t   *  Any name that doesn't match will be ignored\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setBlockUniforms(uniformBlockInfo, values) {\n\t    var uniforms = uniformBlockInfo.uniforms;\n\t    for (var name in values) {\n\t      var array = uniforms[name];\n\t      if (array) {\n\t        var value = values[name];\n\t        if (value.length) {\n\t          array.set(value);\n\t        } else {\n\t          array[0] = value;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Set uniforms and binds related textures.\n\t   *\n\t   * example:\n\t   *\n\t   *     var programInfo = createProgramInfo(\n\t   *         gl, [\"some-vs\", \"some-fs\"]);\n\t   *\n\t   *     var tex1 = gl.createTexture();\n\t   *     var tex2 = gl.createTexture();\n\t   *\n\t   *     ... assume we setup the textures with data ...\n\t   *\n\t   *     var uniforms = {\n\t   *       u_someSampler: tex1,\n\t   *       u_someOtherSampler: tex2,\n\t   *       u_someColor: [1,0,0,1],\n\t   *       u_somePosition: [0,1,1],\n\t   *       u_someMatrix: [\n\t   *         1,0,0,0,\n\t   *         0,1,0,0,\n\t   *         0,0,1,0,\n\t   *         0,0,0,0,\n\t   *       ],\n\t   *     };\n\t   *\n\t   *     gl.useProgram(program);\n\t   *\n\t   * This will automatically bind the textures AND set the\n\t   * uniforms.\n\t   *\n\t   *     twgl.setUniforms(programInfo, uniforms);\n\t   *\n\t   * For the example above it is equivalent to\n\t   *\n\t   *     var texUnit = 0;\n\t   *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n\t   *     gl.bindTexture(gl.TEXTURE_2D, tex1);\n\t   *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n\t   *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n\t   *     gl.bindTexture(gl.TEXTURE_2D, tex2);\n\t   *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n\t   *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);\n\t   *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);\n\t   *     gl.uniformMatrix4fv(u_someMatrix, false, [\n\t   *         1,0,0,0,\n\t   *         0,1,0,0,\n\t   *         0,0,1,0,\n\t   *         0,0,0,0,\n\t   *       ]);\n\t   *\n\t   * Note it is perfectly reasonable to call `setUniforms` multiple times. For example\n\t   *\n\t   *     var uniforms = {\n\t   *       u_someSampler: tex1,\n\t   *       u_someOtherSampler: tex2,\n\t   *     };\n\t   *\n\t   *     var moreUniforms {\n\t   *       u_someColor: [1,0,0,1],\n\t   *       u_somePosition: [0,1,1],\n\t   *       u_someMatrix: [\n\t   *         1,0,0,0,\n\t   *         0,1,0,0,\n\t   *         0,0,1,0,\n\t   *         0,0,0,0,\n\t   *       ],\n\t   *     };\n\t   *\n\t   *     twgl.setUniforms(programInfo, uniforms);\n\t   *     twgl.setUniforms(programInfo, moreUniforms);\n\t   *\n\t   * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from\n\t   *        `createUniformSetters`.\n\t   * @param {Object.<string, ?>} values an object with values for the\n\t   *        uniforms.\n\t   *   You can pass multiple objects by putting them in an array or by calling with more arguments.For example\n\t   *\n\t   *     var sharedUniforms = {\n\t   *       u_fogNear: 10,\n\t   *       u_projection: ...\n\t   *       ...\n\t   *     };\n\t   *\n\t   *     var localUniforms = {\n\t   *       u_world: ...\n\t   *       u_diffuseColor: ...\n\t   *     };\n\t   *\n\t   *     twgl.setUniforms(programInfo, sharedUniforms, localUniforms);\n\t   *\n\t   *     // is the same as\n\t   *\n\t   *     twgl.setUniforms(programInfo, [sharedUniforms, localUniforms]);\n\t   *\n\t   *     // is the same as\n\t   *\n\t   *     twgl.setUniforms(programInfo, sharedUniforms);\n\t   *     twgl.setUniforms(programInfo, localUniforms};\n\t   *\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setUniforms(setters, values) {  // eslint-disable-line\n\t    var actualSetters = setters.uniformSetters || setters;\n\t    var numArgs = arguments.length;\n\t    for (var andx = 1; andx < numArgs; ++andx) {\n\t      var vals = arguments[andx];\n\t      if (Array.isArray(vals)) {\n\t        var numValues = vals.length;\n\t        for (var ii = 0; ii < numValues; ++ii) {\n\t          setUniforms(actualSetters, vals[ii]);\n\t        }\n\t      } else {\n\t        for (var name in vals) {\n\t          var setter = actualSetters[name];\n\t          if (setter) {\n\t            setter(vals[name]);\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Creates setter functions for all attributes of a shader\n\t   * program. You can pass this to {@link module:twgl.setBuffersAndAttributes} to set all your buffers and attributes.\n\t   *\n\t   * @see {@link module:twgl.setAttributes} for example\n\t   * @param {WebGLProgram} program the program to create setters for.\n\t   * @return {Object.<string, function>} an object with a setter for each attribute by name.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createAttributeSetters(gl, program) {\n\t    var attribSetters = {\n\t    };\n\t\n\t    function createAttribSetter(index) {\n\t      return function(b) {\n\t        gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n\t        gl.enableVertexAttribArray(index);\n\t        gl.vertexAttribPointer(\n\t            index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);\n\t      };\n\t    }\n\t\n\t    function createMatAttribSetter(index, typeInfo) {\n\t      var defaultSize = typeInfo.size;\n\t      var count = typeInfo.count;\n\t\n\t      return function(b) {\n\t        gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n\t        var numComponents = b.size || b.numComponents || defaultSize;\n\t        var size = numComponents / count;\n\t        var type = b.type || gl.FLOAT;\n\t        var typeInfo = typeMap[type];\n\t        var stride = typeInfo.size * numComponents;\n\t        var normalize = b.normalize || false;\n\t        var offset = b.offset || 0;\n\t        var rowOffset = stride / count;\n\t        for (var i = 0; i < count; ++i) {\n\t          gl.enableVertexAttribArray(index + i);\n\t          gl.vertexAttribPointer(\n\t              index + i, size, type, normalize, stride, offset + rowOffset * i);\n\t        }\n\t      };\n\t    }\n\t\n\t    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\t    for (var ii = 0; ii < numAttribs; ++ii) {\n\t      var attribInfo = gl.getActiveAttrib(program, ii);\n\t      if (!attribInfo) {\n\t        break;\n\t      }\n\t      var index = gl.getAttribLocation(program, attribInfo.name);\n\t      var typeInfo = attrTypeMap[attribInfo.type];\n\t      if (typeInfo) {\n\t        attribSetters[attribInfo.name] = createMatAttribSetter(index, typeInfo);\n\t      } else {\n\t        attribSetters[attribInfo.name] = createAttribSetter(index);\n\t      }\n\t    }\n\t\n\t    return attribSetters;\n\t  }\n\t\n\t  /**\n\t   * Sets attributes and binds buffers (deprecated... use {@link module:twgl.setBuffersAndAttributes})\n\t   *\n\t   * Example:\n\t   *\n\t   *     var program = createProgramFromScripts(\n\t   *         gl, [\"some-vs\", \"some-fs\");\n\t   *\n\t   *     var attribSetters = createAttributeSetters(program);\n\t   *\n\t   *     var positionBuffer = gl.createBuffer();\n\t   *     var texcoordBuffer = gl.createBuffer();\n\t   *\n\t   *     var attribs = {\n\t   *       a_position: {buffer: positionBuffer, numComponents: 3},\n\t   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n\t   *     };\n\t   *\n\t   *     gl.useProgram(program);\n\t   *\n\t   * This will automatically bind the buffers AND set the\n\t   * attributes.\n\t   *\n\t   *     setAttributes(attribSetters, attribs);\n\t   *\n\t   * Properties of attribs. For each attrib you can add\n\t   * properties:\n\t   *\n\t   * *   type: the type of data in the buffer. Default = gl.FLOAT\n\t   * *   normalize: whether or not to normalize the data. Default = false\n\t   * *   stride: the stride. Default = 0\n\t   * *   offset: offset into the buffer. Default = 0\n\t   *\n\t   * For example if you had 3 value float positions, 2 value\n\t   * float texcoord and 4 value uint8 colors you'd setup your\n\t   * attribs like this\n\t   *\n\t   *     var attribs = {\n\t   *       a_position: {buffer: positionBuffer, numComponents: 3},\n\t   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n\t   *       a_color: {\n\t   *         buffer: colorBuffer,\n\t   *         numComponents: 4,\n\t   *         type: gl.UNSIGNED_BYTE,\n\t   *         normalize: true,\n\t   *       },\n\t   *     };\n\t   *\n\t   * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters\n\t   * @param {Object.<string, module:twgl.AttribInfo>} buffers AttribInfos mapped by attribute name.\n\t   * @memberOf module:twgl/programs\n\t   * @deprecated use {@link module:twgl.setBuffersAndAttributes}\n\t   */\n\t  function setAttributes(setters, buffers) {\n\t    for (var name in buffers) {\n\t      var setter = setters[name];\n\t      if (setter) {\n\t        setter(buffers[name]);\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate\n\t   *\n\t   * Example:\n\t   *\n\t   *     var programInfo = createProgramInfo(\n\t   *         gl, [\"some-vs\", \"some-fs\");\n\t   *\n\t   *     var arrays = {\n\t   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n\t   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n\t   *     };\n\t   *\n\t   *     var bufferInfo = createBufferInfoFromArrays(gl, arrays);\n\t   *\n\t   *     gl.useProgram(programInfo.program);\n\t   *\n\t   * This will automatically bind the buffers AND set the\n\t   * attributes.\n\t   *\n\t   *     setBuffersAndAttributes(gl, programInfo, bufferInfo);\n\t   *\n\t   * For the example above it is equivilent to\n\t   *\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\t   *     gl.enableVertexAttribArray(a_positionLocation);\n\t   *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);\n\t   *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n\t   *     gl.enableVertexAttribArray(a_texcoordLocation);\n\t   *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n\t   * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters A `ProgramInfo` as returned from {@link module:twgl.createProgrmaInfo} or Attribute setters as returned from {@link module:twgl.createAttributeSetters}\n\t   * @param {(module:twgl.BufferInfo|module:twgl.vertexArrayInfo)} buffers a `BufferInfo` as returned from {@link module:twgl.createBufferInfoFromArrays}.\n\t   *   or a `VertexArrayInfo` as returned from {@link module:twgl.createVertexArrayInfo}\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function setBuffersAndAttributes(gl, programInfo, buffers) {\n\t    if (buffers.vertexArrayObject) {\n\t      gl.bindVertexArray(buffers.vertexArrayObject);\n\t    } else {\n\t      setAttributes(programInfo.attribSetters || programInfo, buffers.attribs);\n\t      if (buffers.indices) {\n\t        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * @typedef {Object} ProgramInfo\n\t   * @property {WebGLProgram} program A shader program\n\t   * @property {Object<string, function>} uniformSetters object of setters as returned from createUniformSetters,\n\t   * @property {Object<string, function>} attribSetters object of setters as returned from createAttribSetters,\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Creates a ProgramInfo from an existing program.\n\t   *\n\t   * A ProgramInfo contains\n\t   *\n\t   *     programInfo = {\n\t   *        program: WebGLProgram,\n\t   *        uniformSetters: object of setters as returned from createUniformSetters,\n\t   *        attribSetters: object of setters as returned from createAttribSetters,\n\t   *     }\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {WebGLProgram} program an existing WebGLProgram.\n\t   * @return {module:twgl.ProgramInfo} The created ProgramInfo.\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramInfoFromProgram(gl, program) {\n\t    var uniformSetters = createUniformSetters(gl, program);\n\t    var attribSetters = createAttributeSetters(gl, program);\n\t    var programInfo = {\n\t      program: program,\n\t      uniformSetters: uniformSetters,\n\t      attribSetters: attribSetters,\n\t    };\n\t\n\t    if (utils.isWebGL2(gl)) {\n\t      programInfo.uniformBlockSpec = createUniformBlockSpecFromProgram(gl, program);\n\t    }\n\t\n\t    return programInfo;\n\t  }\n\t\n\t  /**\n\t   * Creates a ProgramInfo from 2 sources.\n\t   *\n\t   * A ProgramInfo contains\n\t   *\n\t   *     programInfo = {\n\t   *        program: WebGLProgram,\n\t   *        uniformSetters: object of setters as returned from createUniformSetters,\n\t   *        attribSetters: object of setters as returned from createAttribSetters,\n\t   *     }\n\t   *\n\t   * NOTE: There are 3 signatures for this function\n\t   *\n\t   *     twgl.createProgramInfo(gl, [vs, fs], opt_errFunc);\n\t   *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_errFunc);\n\t   *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n\t   *\n\t   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n\t   *        to use.\n\t   * @param {string[]} shaderSourcess Array of sources for the\n\t   *        shaders or ids. The first is assumed to be the vertex shader,\n\t   *        the second the fragment shader.\n\t   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n\t   * @param {number[]} [opt_locations] The locations for the attributes. A parallel array to opt_attribs letting you assign locations.\n\t   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n\t   *        on error. If you want something else pass an callback. It's passed an error message.\n\t   * @return {module:twgl.ProgramInfo?} The created ProgramInfo or null if it failed to link or compile\n\t   * @memberOf module:twgl/programs\n\t   */\n\t  function createProgramInfo(\n\t      gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n\t    if (typeof opt_locations === 'function') {\n\t      opt_errorCallback = opt_locations;\n\t      opt_locations = undefined;\n\t    }\n\t    if (typeof opt_attribs === 'function') {\n\t      opt_errorCallback = opt_attribs;\n\t      opt_attribs = undefined;\n\t    }\n\t    var errFn = opt_errorCallback || error;\n\t    var good = true;\n\t    shaderSources = shaderSources.map(function(source) {\n\t      // Lets assume if there is no \\n it's an id\n\t      if (source.indexOf(\"\\n\") < 0) {\n\t        var script = document.getElementById(source);\n\t        if (!script) {\n\t          errFn(\"no element with id: \" + source);\n\t          good = false;\n\t        } else {\n\t          source = script.text;\n\t        }\n\t      }\n\t      return source;\n\t    });\n\t    if (!good) {\n\t      return null;\n\t    }\n\t    var program = createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback);\n\t    if (!program) {\n\t      return null;\n\t    }\n\t    return createProgramInfoFromProgram(gl, program);\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"createAttributeSetters\": createAttributeSetters,\n\t\n\t    \"createProgram\": createProgram,\n\t    \"createProgramFromScripts\": createProgramFromScripts,\n\t    \"createProgramFromSources\": createProgramFromSources,\n\t    \"createProgramInfo\": createProgramInfo,\n\t    \"createProgramInfoFromProgram\": createProgramInfoFromProgram,\n\t    \"createUniformSetters\": createUniformSetters,\n\t    \"createUniformBlockSpecFromProgram\": createUniformBlockSpecFromProgram,\n\t    \"createUniformBlockInfoFromProgram\": createUniformBlockInfoFromProgram,\n\t    \"createUniformBlockInfo\": createUniformBlockInfo,\n\t\n\t    \"setAttributes\": setAttributes,\n\t    \"setBuffersAndAttributes\": setBuffersAndAttributes,\n\t    \"setUniforms\": setUniforms,\n\t    \"setUniformBlock\": setUniformBlock,\n\t    \"setBlockUniforms\": setBlockUniforms,\n\t    \"bindUniformBlock\": bindUniformBlock,\n\t  };\n\t\n\t});\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/draw',[\n\t    './programs',\n\t  ], function(\n\t    programs) {\n\t\n\t\n\t  /**\n\t   * Drawing related functions\n\t   *\n\t   * For backward compatibily they are available at both `twgl.draw` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/draw\n\t   */\n\t\n\t  /**\n\t   * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate\n\t   *\n\t   * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself\n\t   * but calling this means if you switch from indexed data to non-indexed\n\t   * data you don't have to remember to update your draw call.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} bufferInfo A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays} or\n\t   *   a VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}\n\t   * @param {enum} [type] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...). Defaults to `gl.TRIANGLES`\n\t   * @param {number} [count] An optional count. Defaults to bufferInfo.numElements\n\t   * @param {number} [offset] An optional offset. Defaults to 0.\n\t   * @memberOf module:twgl/draw\n\t   */\n\t  function drawBufferInfo(gl, bufferInfo, type, count, offset) {\n\t    type = type === undefined ? gl.TRIANGLES : type;\n\t    var indices = bufferInfo.indices;\n\t    var elementType = bufferInfo.elementType;\n\t    var numElements = count === undefined ? bufferInfo.numElements : count;\n\t    offset = offset === undefined ? 0 : offset;\n\t    if (elementType || indices) {\n\t      gl.drawElements(type, numElements, elementType === undefined ? gl.UNSIGNED_SHORT : bufferInfo.elementType, offset);\n\t    } else {\n\t      gl.drawArrays(type, offset, numElements);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * A DrawObject is useful for putting objects in to an array and passing them to {@link module:twgl.drawObjectList}.\n\t   *\n\t   * You need either a `BufferInfo` or a `VertexArrayInfo`.\n\t   *\n\t   * @typedef {Object} DrawObject\n\t   * @property {boolean} [active] whether or not to draw. Default = `true` (must be `false` to be not true). In otherwords `undefined` = `true`\n\t   * @property {number} [type] type to draw eg. `gl.TRIANGLES`, `gl.LINES`, etc...\n\t   * @property {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}\n\t   * @property {module:twgl.BufferInfo} [bufferInfo] A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays}\n\t   * @property {module:twgl.VertexArrayInfo} [vertexArrayInfo] A VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}\n\t   * @property {Object<string, ?>} uniforms The values for the uniforms.\n\t   *   You can pass multiple objects by putting them in an array. For example\n\t   *\n\t   *     var sharedUniforms = {\n\t   *       u_fogNear: 10,\n\t   *       u_projection: ...\n\t   *       ...\n\t   *     };\n\t   *\n\t   *     var localUniforms = {\n\t   *       u_world: ...\n\t   *       u_diffuseColor: ...\n\t   *     };\n\t   *\n\t   *     var drawObj = {\n\t   *       ...\n\t   *       uniforms: [sharedUniforms, localUniforms],\n\t   *     };\n\t   *\n\t   * @property {number} [offset] the offset to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to 0.\n\t   * @property {number} [count] the count to pass to `gl.drawArrays` or `gl.drawElemnts`. Defaults to bufferInfo.numElements.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Draws a list of objects\n\t   * @param {DrawObject[]} objectsToDraw an array of objects to draw.\n\t   * @memberOf module:twgl/draw\n\t   */\n\t  function drawObjectList(gl, objectsToDraw) {\n\t    var lastUsedProgramInfo = null;\n\t    var lastUsedBufferInfo = null;\n\t\n\t    objectsToDraw.forEach(function(object) {\n\t      if (object.active === false) {\n\t        return;\n\t      }\n\t\n\t      var programInfo = object.programInfo;\n\t      var bufferInfo = object.vertexArrayInfo || object.bufferInfo;\n\t      var bindBuffers = false;\n\t      var type = object.type === undefined ? gl.TRIANGLES : object.type;\n\t\n\t      if (programInfo !== lastUsedProgramInfo) {\n\t        lastUsedProgramInfo = programInfo;\n\t        gl.useProgram(programInfo.program);\n\t\n\t        // We have to rebind buffers when changing programs because we\n\t        // only bind buffers the program uses. So if 2 programs use the same\n\t        // bufferInfo but the 1st one uses only positions the when the\n\t        // we switch to the 2nd one some of the attributes will not be on.\n\t        bindBuffers = true;\n\t      }\n\t\n\t      // Setup all the needed attributes.\n\t      if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {\n\t        if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject && !bufferInfo.vertexArrayObject) {\n\t          gl.bindVertexArray(null);\n\t        }\n\t        lastUsedBufferInfo = bufferInfo;\n\t        programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n\t      }\n\t\n\t      // Set the uniforms.\n\t      programs.setUniforms(programInfo, object.uniforms);\n\t\n\t      // Draw\n\t      drawBufferInfo(gl, bufferInfo, type, object.count, object.offset);\n\t    });\n\t\n\t    if (lastUsedBufferInfo.vertexArrayObject) {\n\t      gl.bindVertexArray(null);\n\t    }\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"drawBufferInfo\": drawBufferInfo,\n\t    \"drawObjectList\": drawObjectList,\n\t  };\n\t\n\t});\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/textures',[\n\t    './typedarrays',\n\t    './utils',\n\t  ], function(\n\t    typedArrays,\n\t    utils) {\n\t\n\t\n\t  /**\n\t   * Low level texture related functions\n\t   *\n\t   * You should generally not need to use these functions. They are provided\n\t   * for those cases where you're doing something out of the ordinary\n\t   * and you need lower level access.\n\t   *\n\t   * For backward compatibily they are available at both `twgl.textures` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/textures\n\t   */\n\t\n\t  // make sure we don't see a global gl\n\t  var gl = undefined;  // eslint-disable-line\n\t  var defaults = {\n\t    textureColor: new Uint8Array([128, 192, 255, 255]),\n\t    textureOptions: {},\n\t    crossOrigin: undefined,\n\t  };\n\t  var isArrayBuffer = typedArrays.isArrayBuffer;\n\t\n\t  /* PixelFormat */\n\t  var ALPHA                          = 0x1906;\n\t  var RGB                            = 0x1907;\n\t  var RGBA                           = 0x1908;\n\t  var LUMINANCE                      = 0x1909;\n\t  var LUMINANCE_ALPHA                = 0x190A;\n\t\n\t  /* TextureWrapMode */\n\t  var REPEAT                         = 0x2901;  // eslint-disable-line\n\t  var MIRRORED_REPEAT                = 0x8370;  // eslint-disable-line\n\t\n\t  /* TextureMagFilter */\n\t  var NEAREST                        = 0x2600;  // eslint-disable-line\n\t\n\t  /* TextureMinFilter */\n\t  var NEAREST_MIPMAP_NEAREST         = 0x2700;  // eslint-disable-line\n\t  var LINEAR_MIPMAP_NEAREST          = 0x2701;  // eslint-disable-line\n\t  var NEAREST_MIPMAP_LINEAR          = 0x2702;  // eslint-disable-line\n\t  var LINEAR_MIPMAP_LINEAR           = 0x2703;  // eslint-disable-line\n\t\n\t  /**\n\t   * Sets the default texture color.\n\t   *\n\t   * The default texture color is used when loading textures from\n\t   * urls. Because the URL will be loaded async we'd like to be\n\t   * able to use the texture immediately. By putting a 1x1 pixel\n\t   * color in the texture we can start using the texture before\n\t   * the URL has loaded.\n\t   *\n\t   * @param {number[]} color Array of 4 values in the range 0 to 1\n\t   * @deprecated see {@link module:twgl.setDefaults}\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setDefaultTextureColor(color) {\n\t    defaults.textureColor = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);\n\t  }\n\t\n\t  function setDefaults(newDefaults) {\n\t    utils.copyExistingProperties(newDefaults, defaults);\n\t    if (newDefaults.textureColor) {\n\t      setDefaultTextureColor(newDefaults.textureColor);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Gets a string for gl enum\n\t   *\n\t   * Note: Several enums are the same. Without more\n\t   * context (which function) it's impossible to always\n\t   * give the correct enum.\n\t   *\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {number} value the value of the enum you want to look up.\n\t   */\n\t  var glEnumToString = (function() {\n\t    var enums;\n\t\n\t    function init(gl) {\n\t      if (!enums) {\n\t        enums = {};\n\t        Object.keys(gl).forEach(function(key) {\n\t          if (typeof gl[key] === 'number') {\n\t            enums[gl[key]] = key;\n\t          }\n\t        });\n\t      }\n\t    }\n\t\n\t    return function glEnumToString(gl, value) {\n\t      init();\n\t      return enums[value] || (\"0x\" + value.toString(16));\n\t    };\n\t  }());\n\t\n\t  /**\n\t   * A function to generate the source for a texture.\n\t   * @callback TextureFunc\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} options the texture options\n\t   * @return {*} Returns any of the things documentented for `src` for {@link module:twgl.TextureOptions}.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Texture options passed to most texture functions. Each function will use whatever options\n\t   * are appropriate for its needs. This lets you pass the same options to all functions.\n\t   *\n\t   * @typedef {Object} TextureOptions\n\t   * @property {number} [target] the type of texture `gl.TEXTURE_2D` or `gl.TEXTURE_CUBE_MAP`. Defaults to `gl.TEXTURE_2D`.\n\t   * @property {number} [width] the width of the texture. Only used if src is an array or typed array or null.\n\t   * @property {number} [height] the height of a texture. Only used if src is an array or typed array or null.\n\t   * @property {number} [depth] the depth of a texture. Only used if src is an array or type array or null and target is `TEXTURE_3D` .\n\t   * @property {number} [min] the min filter setting (eg. `gl.LINEAR`). Defaults to `gl.NEAREST_MIPMAP_LINEAR`\n\t   *     or if texture is not a power of 2 on both dimensions then defaults to `gl.LINEAR`.\n\t   * @property {number} [mag] the mag filter setting (eg. `gl.LINEAR`). Defaults to `gl.LINEAR`\n\t   * @property {number} [internalFormat] internal format for texture. Defaults to `gl.RGBA`\n\t   * @property {number} [format] format for texture. Defaults to `gl.RGBA`.\n\t   * @property {number} [type] type for texture. Defaults to `gl.UNSIGNED_BYTE` unless `src` is ArrayBuffer. If `src`\n\t   *     is ArrayBuffer defaults to type that matches ArrayBuffer type.\n\t   * @property {number} [wrap] Texture wrapping for both S and T (and R if TEXTURE_3D). Defaults to `gl.REPEAT` for 2D unless src is WebGL1 and src not npot and `gl.CLAMP_TO_EDGE` for cube\n\t   * @property {number} [wrapS] Texture wrapping for S. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n\t   * @property {number} [wrapT] Texture wrapping for T. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n\t   * @property {number} [wrapR] Texture wrapping for R. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n\t   * @property {number} [minLod] TEXTURE_MIN_LOD setting\n\t   * @property {number} [maxLod] TEXTURE_MAX_LOD setting\n\t   * @property {number} [baseLevel] TEXTURE_BASE_LEVEL setting\n\t   * @property {number} [maxLevel] TEXTURE_MAX_LEVEL setting\n\t   * @property {number} [unpackAlignment] The `gl.UNPACK_ALIGNMENT` used when uploading an array. Defaults to 1.\n\t   * @property {number} [premultiplyAlpha] Whether or not to premultiply alpha. Defaults to whatever the current setting is.\n\t   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n\t   *     the current setting for specific textures.\n\t   * @property {number} [flipY] Whether or not to flip the texture vertically on upload. Defaults to whatever the current setting is.\n\t   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n\t   *     the current setting for specific textures.\n\t   * @property {number} [colorspaceConversion] Whether or not to let the browser do colorspace conversion of the texture on upload. Defaults to whatever the current setting is.\n\t   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n\t   *     the current setting for specific textures.\n\t   * @property {(number[]|ArrayBuffer)} color color used as temporary 1x1 pixel color for textures loaded async when src is a string.\n\t   *    If it's a JavaScript array assumes color is 0 to 1 like most GL colors as in `[1, 0, 0, 1] = red=1, green=0, blue=0, alpha=0`.\n\t   *    Defaults to `[0.5, 0.75, 1, 1]`. See {@link module:twgl.setDefaultTextureColor}. If `false` texture is set. Can be used to re-load a texture\n\t   * @property {boolean} [auto] If not `false` then texture working filtering is set automatically for non-power of 2 images and\n\t   *    mips are generated for power of 2 images.\n\t   * @property {number[]} [cubeFaceOrder] The order that cube faces are pulled out of an img or set of images. The default is\n\t   *\n\t   *     [gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n\t   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n\t   *      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n\t   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n\t   *      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n\t   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]\n\t   *\n\t   * @property {(number[]|ArrayBuffer|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement|string|string[]|module:twgl.TextureFunc)} [src] source for texture\n\t   *\n\t   *    If `string` then it's assumed to be a URL to an image. The image will be downloaded async. A usable\n\t   *    1x1 pixel texture will be returned immediatley. The texture will be updated once the image has downloaded.\n\t   *    If `target` is `gl.TEXTURE_CUBE_MAP` will attempt to divide image into 6 square pieces. 1x6, 6x1, 3x2, 2x3.\n\t   *    The pieces will be uploaded in `cubeFaceOrder`\n\t   *\n\t   *    If `string[]` then it must have 6 entries, one for each face of a cube map. Target must be `gl.TEXTURE_CUBE_MAP`.\n\t   *\n\t   *    If `HTMLElement` then it wil be used immediately to create the contents of the texture. Examples `HTMLImageElement`,\n\t   *    `HTMLCanvasElement`, `HTMLVideoElement`.\n\t   *\n\t   *    If `number[]` or `ArrayBuffer` it's assumed to be data for a texture. If `width` or `height` is\n\t   *    not specified it is guessed as follows. First the number of elements is computed by `src.length / numComponets`\n\t   *    where `numComponents` is derived from `format`. If `target` is `gl.TEXTURE_CUBE_MAP` then `numElements` is divided\n\t   *    by 6. Then\n\t   *\n\t   *    *   If neither `width` nor `height` are specified and `sqrt(numElements)` is an integer then width and height\n\t   *        are set to `sqrt(numElements)`. Otherwise `width = numElements` and `height = 1`.\n\t   *\n\t   *    *   If only one of `width` or `height` is specified then the other equals `numElements / specifiedDimension`.\n\t   *\n\t   * If `number[]` will be converted to `type`.\n\t   *\n\t   * If `src` is a function it will be called with a `WebGLRenderingContext` and these options.\n\t   * Whatever it returns is subject to these rules. So it can return a string url, an `HTMLElement`\n\t   * an array etc...\n\t   *\n\t   * If `src` is undefined then an empty texture will be created of size `width` by `height`.\n\t   *\n\t   * @property {string} [crossOrigin] What to set the crossOrigin property of images when they are downloaded.\n\t   *    default: undefined. Also see {@link module:twgl.setDefaults}.\n\t   *\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  // NOTE: While querying GL is considered slow it's not remotely as slow\n\t  // as uploading a texture. On top of that you're unlikely to call this in\n\t  // a perf critical loop. Even if upload a texture every frame that's unlikely\n\t  // to be more than 1 or 2 textures a frame. In other words, the benefits of\n\t  // making the API easy to use outweigh any supposed perf benefits\n\t  var lastPackState = {};\n\t\n\t  /**\n\t   * Saves any packing state that will be set based on the options.\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   */\n\t  function savePackState(gl, options) {\n\t    if (options.colorspaceConversion !== undefined) {\n\t      lastPackState.colorspaceConversion = gl.getParameter(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL);\n\t      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, options.colorspaceConversion);\n\t    }\n\t    if (options.premultiplyAlpha !== undefined) {\n\t      lastPackState.premultiplyAlpha = gl.getParameter(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL);\n\t      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlpha);\n\t    }\n\t    if (options.flipY !== undefined) {\n\t      lastPackState.flipY = gl.getParameter(gl.UNPACK_FLIP_Y_WEBGL);\n\t      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, options.flipY);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Restores any packing state that was set based on the options.\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   */\n\t  function restorePackState(gl, options) {\n\t    if (options.colorspaceConversion !== undefined) {\n\t      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, lastPackState.colorspaceConversion);\n\t    }\n\t    if (options.premultiplyAlpha !== undefined) {\n\t      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, lastPackState.premultiplyAlpha);\n\t    }\n\t    if (options.flipY !== undefined) {\n\t      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, lastPackState.flipY);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Sets the texture parameters of a texture.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureParameters(gl, tex, options) {\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    if (options.min) {\n\t      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, options.min);\n\t    }\n\t    if (options.mag) {\n\t      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, options.mag);\n\t    }\n\t    if (options.wrap) {\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_S, options.wrap);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_T, options.wrap);\n\t      if (target === gl.TEXTURE_3D) {\n\t        gl.texParameteri(target, gl.TEXTURE_WRAP_R, options.wrap);\n\t      }\n\t    }\n\t    if (options.wrapR) {\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_R, options.wrapR);\n\t    }\n\t    if (options.wrapS) {\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_S, options.wrapS);\n\t    }\n\t    if (options.wrapT) {\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_T, options.wrapT);\n\t    }\n\t    if (options.minLod) {\n\t      gl.texParameteri(target, gl.TEXTURE_MIN_LOD, options.minLod);\n\t    }\n\t    if (options.maxLod) {\n\t      gl.texParameteri(target, gl.TEXTURE_MAX_LOD, options.maxLod);\n\t    }\n\t    if (options.baseLevel) {\n\t      gl.texParameteri(target, gl.TEXTURE_BASE_LEVEL, options.baseLevel);\n\t    }\n\t    if (options.maxLevel) {\n\t      gl.texParameteri(target, gl.TEXTURE_MAX_LEVEL, options.maxLevel);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Makes a 1x1 pixel\n\t   * If no color is passed in uses the default color which can be set by calling `setDefaultTextureColor`.\n\t   * @param {(number[]|ArrayBuffer)} [color] The color using 0-1 values\n\t   * @return {Uint8Array} Unit8Array with color.\n\t   */\n\t  function make1Pixel(color) {\n\t    color = color || defaults.textureColor;\n\t    if (isArrayBuffer(color)) {\n\t      return color;\n\t    }\n\t    return new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);\n\t  }\n\t\n\t  /**\n\t   * Returns true if value is power of 2\n\t   * @param {number} value number to check.\n\t   * @return true if value is power of 2\n\t   */\n\t  function isPowerOf2(value) {\n\t    return (value & (value - 1)) === 0;\n\t  }\n\t\n\t  /**\n\t   * Sets filtering or generates mips for texture based on width or height\n\t   * If width or height is not passed in uses `options.width` and//or `options.height`\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @param {number} [width] width of texture\n\t   * @param {number} [height] height of texture\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureFilteringForSize(gl, tex, options, width, height) {\n\t    options = options || defaults.textureOptions;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    width = width || options.width;\n\t    height = height || options.height;\n\t    gl.bindTexture(target, tex);\n\t    if (!isPowerOf2(width) || !isPowerOf2(height)) {\n\t      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t    } else {\n\t      gl.generateMipmap(target);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Gets an array of cubemap face enums\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @return {number[]} cubemap face enums\n\t   */\n\t  function getCubeFaceOrder(gl, options) {\n\t    options = options || {};\n\t    return options.cubeFaceOrder || [\n\t        gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n\t        gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n\t        gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n\t        gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n\t        gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n\t        gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\n\t      ];\n\t  }\n\t\n\t  /**\n\t   * @typedef {Object} FaceInfo\n\t   * @property {number} face gl enum for texImage2D\n\t   * @property {number} ndx face index (0 - 5) into source data\n\t   * @ignore\n\t   */\n\t\n\t  /**\n\t   * Gets an array of FaceInfos\n\t   * There's a bug in some NVidia drivers that will crash the driver if\n\t   * `gl.TEXTURE_CUBE_MAP_POSITIVE_X` is not uploaded first. So, we take\n\t   * the user's desired order from his faces to WebGL and make sure we\n\t   * do the faces in WebGL order\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @return {FaceInfo[]} cubemap face infos. Arguably the `face` property of each element is redundent but\n\t   *    it's needed internally to sort the array of `ndx` properties by `face`.\n\t   */\n\t  function getCubeFacesWithNdx(gl, options) {\n\t    var faces = getCubeFaceOrder(gl, options);\n\t    // work around bug in NVidia drivers. We have to upload the first face first else the driver crashes :(\n\t    var facesWithNdx = faces.map(function(face, ndx) {\n\t      return { face: face, ndx: ndx };\n\t    });\n\t    facesWithNdx.sort(function(a, b) {\n\t      return a.face - b.face;\n\t    });\n\t    return facesWithNdx;\n\t  }\n\t\n\t  /**\n\t   * Set a texture from the contents of an element. Will also set\n\t   * texture filtering or generate mips based on the dimensions of the element\n\t   * unless `options.auto === false`. If `target === gl.TEXTURE_CUBE_MAP` will\n\t   * attempt to slice image into 1x6, 2x3, 3x2, or 6x1 images, one for each face.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {HTMLElement} element a canvas, img, or video element.\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   * @kind function\n\t   */\n\t  var setTextureFromElement = function() {\n\t    var ctx = document.createElement(\"canvas\").getContext(\"2d\");\n\t    return function setTextureFromElement(gl, tex, element, options) {\n\t      options = options || defaults.textureOptions;\n\t      var target = options.target || gl.TEXTURE_2D;\n\t      var width = element.width;\n\t      var height = element.height;\n\t      var format = options.format || gl.RGBA;\n\t      var internalFormat = options.internalFormat || format;\n\t      var type = options.type || gl.UNSIGNED_BYTE;\n\t      savePackState(gl, options);\n\t      gl.bindTexture(target, tex);\n\t      if (target === gl.TEXTURE_CUBE_MAP) {\n\t        // guess the parts\n\t        var imgWidth  = element.width;\n\t        var imgHeight = element.height;\n\t        var size;\n\t        var slices;\n\t        if (imgWidth / 6 === imgHeight) {\n\t          // It's 6x1\n\t          size = imgHeight;\n\t          slices = [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0];\n\t        } else if (imgHeight / 6 === imgWidth) {\n\t          // It's 1x6\n\t          size = imgWidth;\n\t          slices = [0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5];\n\t        } else if (imgWidth / 3 === imgHeight / 2) {\n\t          // It's 3x2\n\t          size = imgWidth / 3;\n\t          slices = [0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1];\n\t        } else if (imgWidth / 2 === imgHeight / 3) {\n\t          // It's 2x3\n\t          size = imgWidth / 2;\n\t          slices = [0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2];\n\t        } else {\n\t          throw \"can't figure out cube map from element: \" + (element.src ? element.src : element.nodeName);\n\t        }\n\t        ctx.canvas.width = size;\n\t        ctx.canvas.height = size;\n\t        width = size;\n\t        height = size;\n\t        getCubeFacesWithNdx(gl, options).forEach(function(f) {\n\t          var xOffset = slices[f.ndx * 2 + 0] * size;\n\t          var yOffset = slices[f.ndx * 2 + 1] * size;\n\t          ctx.drawImage(element, xOffset, yOffset, size, size, 0, 0, size, size);\n\t          gl.texImage2D(f.face, 0, internalFormat, format, type, ctx.canvas);\n\t        });\n\t        // Free up the canvas memory\n\t        ctx.canvas.width = 1;\n\t        ctx.canvas.height = 1;\n\t      } else if (target === gl.TEXTURE_3D) {\n\t        var smallest = Math.min(element.width, element.height);\n\t        var largest = Math.max(element.width, element.height);\n\t        var depth = largest / smallest;\n\t        if (depth % 1 !== 0) {\n\t          throw \"can not compute 3D dimensions of element\";\n\t        }\n\t        var xMult = element.width  === largest ? 1 : 0;\n\t        var yMult = element.height === largest ? 1 : 0;\n\t        gl.texImage3D(target, 0, internalFormat, smallest, smallest, smallest, 0, format, type, null);\n\t        // remove this is texSubImage3D gets width and height arguments\n\t        ctx.canvas.width = smallest;\n\t        ctx.canvas.height = smallest;\n\t        for (var d = 0; d < depth; ++d) {\n\t//          gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, d * smallest);\n\t//          gl.texSubImage3D(target, 0, 0, 0, d, format, type, element);\n\t            var srcX = d * smallest * xMult;\n\t            var srcY = d * smallest * yMult;\n\t            var srcW = smallest;\n\t            var srcH = smallest;\n\t            var dstX = 0;\n\t            var dstY = 0;\n\t            var dstW = smallest;\n\t            var dstH = smallest;\n\t            ctx.drawImage(element, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);\n\t            gl.texSubImage3D(target, 0, 0, 0, d, format, type, ctx.canvas);\n\t        }\n\t        ctx.canvas.width = 0;\n\t        ctx.canvas.height = 0;\n\t// FIX (save state)\n\t//        gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, 0);\n\t      } else {\n\t        gl.texImage2D(target, 0, internalFormat, format, type, element);\n\t      }\n\t      restorePackState(gl, options);\n\t      if (options.auto !== false) {\n\t        setTextureFilteringForSize(gl, tex, options, width, height);\n\t      }\n\t      setTextureParameters(gl, tex, options);\n\t    };\n\t  }();\n\t\n\t  function noop() {\n\t  }\n\t\n\t  /**\n\t   * Loads an image\n\t   * @param {string} url url to image\n\t   * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null\n\t   *     if there was an error\n\t   * @return {HTMLImageElement} the image being loaded.\n\t   */\n\t  function loadImage(url, crossOrigin, callback) {\n\t    callback = callback || noop;\n\t    var img = new Image();\n\t    crossOrigin = crossOrigin !== undefined ? crossOrigin : defaults.crossOrigin;\n\t    if (crossOrigin !== undefined) {\n\t      img.crossOrigin = crossOrigin;\n\t    }\n\t\n\t    function clearEventHandlers() {\n\t      img.removeEventListener('error', onError);  // eslint-disable-line\n\t      img.removeEventListener('load', onLoad);  // eslint-disable-line\n\t      img = null;\n\t    }\n\t\n\t    function onError() {\n\t      var msg = \"couldn't load image: \" + url;\n\t      utils.error(msg);\n\t      callback(msg, img);\n\t      clearEventHandlers();\n\t    }\n\t\n\t    function onLoad() {\n\t      callback(null, img);\n\t      clearEventHandlers();\n\t    }\n\t\n\t    img.addEventListener('error', onError);\n\t    img.addEventListener('load', onLoad);\n\t    img.src = url;\n\t    return img;\n\t  }\n\t\n\t  /**\n\t   * Sets a texture to a 1x1 pixel color. If `options.color === false` is nothing happens. If it's not set\n\t   * the default texture color is used which can be set by calling `setDefaultTextureColor`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureTo1PixelColor(gl, tex, options) {\n\t    options = options || defaults.textureOptions;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    if (options.color === false) {\n\t      return;\n\t    }\n\t    // Assume it's a URL\n\t    // Put 1x1 pixels in texture. That makes it renderable immediately regardless of filtering.\n\t    var color = make1Pixel(options.color);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      for (var ii = 0; ii < 6; ++ii) {\n\t        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n\t      }\n\t    } else if (target === gl.TEXTURE_3D) {\n\t      gl.texImage3D(target, 0, gl.RGBA, 1, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n\t    } else {\n\t      gl.texImage2D(target, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * The src image(s) used to create a texture.\n\t   *\n\t   * When you call {@link module:twgl.createTexture} or {@link module:twgl.createTextures}\n\t   * you can pass in urls for images to load into the textures. If it's a single url\n\t   * then this will be a single HTMLImageElement. If it's an array of urls used for a cubemap\n\t   * this will be a corresponding array of images for the cubemap.\n\t   *\n\t   * @typedef {HTMLImageElement|HTMLImageElement[]} TextureSrc\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * A callback for when an image finished downloading and been uploaded into a texture\n\t   * @callback TextureReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {WebGLTexture} texture the texture.\n\t   * @param {module:twgl.TextureSrc} souce image(s) used to as the src for the texture\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * A callback for when all images have finished downloading and been uploaded into their respective textures\n\t   * @callback TexturesReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {Object.<string, WebGLTexture>} textures the created textures by name. Same as returned by {@link module:twgl.createTextures}.\n\t   * @param {Object.<string, module:twgl.TextureSrc>} sources the image(s) used for the texture by name.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * A callback for when an image finished downloading and been uploaded into a texture\n\t   * @callback CubemapReadyCallback\n\t   * @param {*} err If truthy there was an error.\n\t   * @param {WebGLTexture} tex the texture.\n\t   * @param {HTMLImageElement[]} imgs the images for each face.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Loads a texture from an image from a Url as specified in `options.src`\n\t   * If `options.color !== false` will set the texture to a 1x1 pixel color so that the texture is\n\t   * immediately useable. It will be updated with the contents of the image once the image has finished\n\t   * downloading. Filtering options will be set as approriate for image unless `options.auto === false`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.TextureReadyCallback} [callback] A function to be called when the image has finished loading. err will\n\t   *    be non null if there was an error.\n\t   * @return {HTMLImageElement} the image being downloaded.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function loadTextureFromUrl(gl, tex, options, callback) {\n\t    callback = callback || noop;\n\t    options = options || defaults.textureOptions;\n\t    setTextureTo1PixelColor(gl, tex, options);\n\t    // Because it's async we need to copy the options.\n\t    options = utils.shallowCopy(options);\n\t    var img = loadImage(options.src, options.crossOrigin, function(err, img) {\n\t      if (err) {\n\t        callback(err, tex, img);\n\t      } else {\n\t        setTextureFromElement(gl, tex, img, options);\n\t        callback(null, tex, img);\n\t      }\n\t    });\n\t    return img;\n\t  }\n\t\n\t  /**\n\t   * Loads a cubemap from 6 urls as specified in `options.src`. Will set the cubemap to a 1x1 pixel color\n\t   * so that it is usable immediately unless `option.color === false`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.CubemapReadyCallback} [callback] A function to be called when all the images have finished loading. err will\n\t   *    be non null if there was an error.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function loadCubemapFromUrls(gl, tex, options, callback) {\n\t    callback = callback || noop;\n\t    var urls = options.src;\n\t    if (urls.length !== 6) {\n\t      throw \"there must be 6 urls for a cubemap\";\n\t    }\n\t    var format = options.format || gl.RGBA;\n\t    var type = options.type || gl.UNSIGNED_BYTE;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    if (target !== gl.TEXTURE_CUBE_MAP) {\n\t      throw \"target must be TEXTURE_CUBE_MAP\";\n\t    }\n\t    setTextureTo1PixelColor(gl, tex, options);\n\t    // Because it's async we need to copy the options.\n\t    options = utils.shallowCopy(options);\n\t    var numToLoad = 6;\n\t    var errors = [];\n\t    var imgs;\n\t    var faces = getCubeFaceOrder(gl, options);\n\t\n\t    function uploadImg(faceTarget) {\n\t      return function(err, img) {\n\t        --numToLoad;\n\t        if (err) {\n\t          errors.push(err);\n\t        } else {\n\t          if (img.width !== img.height) {\n\t            errors.push(\"cubemap face img is not a square: \" + img.src);\n\t          } else {\n\t            savePackState(gl, options);\n\t            gl.bindTexture(target, tex);\n\t\n\t            // So assuming this is the first image we now have one face that's img sized\n\t            // and 5 faces that are 1x1 pixel so size the other faces\n\t            if (numToLoad === 5) {\n\t              // use the default order\n\t              getCubeFaceOrder(gl).forEach(function(otherTarget) {\n\t                // Should we re-use the same face or a color?\n\t                gl.texImage2D(otherTarget, 0, format, format, type, img);\n\t              });\n\t            } else {\n\t              gl.texImage2D(faceTarget, 0, format, format, type, img);\n\t            }\n\t\n\t            restorePackState(gl, options);\n\t            gl.generateMipmap(target);\n\t          }\n\t        }\n\t\n\t        if (numToLoad === 0) {\n\t          callback(errors.length ? errors : undefined, imgs, tex);\n\t        }\n\t      };\n\t    }\n\t\n\t    imgs = urls.map(function(url, ndx) {\n\t      return loadImage(url, options.crossOrigin, uploadImg(faces[ndx]));\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Gets the number of compontents for a given image format.\n\t   * @param {number} format the format.\n\t   * @return {number} the number of components for the format.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function getNumComponentsForFormat(format) {\n\t    switch (format) {\n\t      case ALPHA:\n\t      case LUMINANCE:\n\t        return 1;\n\t      case LUMINANCE_ALPHA:\n\t        return 2;\n\t      case RGB:\n\t        return 3;\n\t      case RGBA:\n\t        return 4;\n\t      default:\n\t        throw \"unknown type: \" + format;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Gets the texture type for a given array type.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @return {number} the gl texture type\n\t   */\n\t  function getTextureTypeForArrayType(gl, src) {\n\t    if (isArrayBuffer(src)) {\n\t      return typedArrays.getGLTypeForTypedArray(src);\n\t    }\n\t    return gl.UNSIGNED_BYTE;\n\t  }\n\t\n\t  function guessDimensions(gl, target, width, height, numElements) {\n\t    if (numElements % 1 !== 0) {\n\t      throw \"can't guess dimensions\";\n\t    }\n\t    if (!width && !height) {\n\t      var size = Math.sqrt(numElements / (target === gl.TEXTURE_CUBE_MAP ? 6 : 1));\n\t      if (size % 1 === 0) {\n\t        width = size;\n\t        height = size;\n\t      } else {\n\t        width = numElements;\n\t        height = 1;\n\t      }\n\t    } else if (!height) {\n\t      height = numElements / width;\n\t      if (height % 1) {\n\t        throw \"can't guess dimensions\";\n\t      }\n\t    } else if (!width) {\n\t      width = numElements / height;\n\t      if (width % 1) {\n\t        throw \"can't guess dimensions\";\n\t      }\n\t    }\n\t    return {\n\t      width: width,\n\t      height: height,\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Sets a texture from an array or typed array. If the width or height is not provided will attempt to\n\t   * guess the size. See {@link module:twgl.TextureOptions}.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {(number[]|ArrayBuffer)} src An array or typed arry with texture data.\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   *   This is often the same options you passed in when you created the texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setTextureFromArray(gl, tex, src, options) {\n\t    options = options || defaults.textureOptions;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    var width = options.width;\n\t    var height = options.height;\n\t    var depth = options.depth;\n\t    var format = options.format || gl.RGBA;\n\t    var internalFormat = options.internalFormat || format;\n\t    var type = options.type || getTextureTypeForArrayType(gl, src);\n\t    var numComponents = getNumComponentsForFormat(format);\n\t    var numElements = src.length / numComponents;\n\t    if (numElements % 1) {\n\t      throw \"length wrong size for format: \" + glEnumToString(gl, format);\n\t    }\n\t    var dimensions;\n\t    if (target === gl.TEXTURE_3D) {\n\t      if (!width && !height && !depth) {\n\t        var size = Math.cbrt(numElements);\n\t        if (size % 1 !== 0) {\n\t          throw \"can't guess cube size of array of numElements: \" + numElements;\n\t        }\n\t        width = size;\n\t        height = size;\n\t        depth = size;\n\t      } else if (width && (!height || !depth)) {\n\t        dimensions = guessDimensions(gl, target, height, depth, numElements / width);\n\t        height = dimensions.width;\n\t        depth = dimensions.height;\n\t      } else if (height && (!width || !depth)) {\n\t        dimensions = guessDimensions(gl, target, width, depth, numElements / height);\n\t        width = dimensions.width;\n\t        depth = dimensions.height;\n\t      } else {\n\t        dimensions = guessDimensions(gl, target, width, height, numElements / depth);\n\t        width = dimensions.width;\n\t        height = dimensions.height;\n\t      }\n\t    } else {\n\t      dimensions = guessDimensions(gl, target, width, height, numElements);\n\t      width = dimensions.width;\n\t      height = dimensions.height;\n\t    }\n\t    if (!isArrayBuffer(src)) {\n\t      var Type = typedArrays.getTypedArrayTypeForGLType(type);\n\t      src = new Type(src);\n\t    } else {\n\t      if (src instanceof Uint8ClampedArray) {\n\t        src = new Uint8Array(src.buffer);\n\t      }\n\t    }\n\t    gl.pixelStorei(gl.UNPACK_ALIGNMENT, options.unpackAlignment || 1);\n\t    savePackState(gl, options);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      var faceSize = numElements / 6 * numComponents;\n\t      getCubeFacesWithNdx(gl, options).forEach(function(f) {\n\t        var offset = faceSize * f.ndx;\n\t        var data = src.subarray(offset, offset + faceSize);\n\t        gl.texImage2D(f.face, 0, internalFormat, width, height, 0, format, type, data);\n\t      });\n\t    } else if (target === gl.TEXTURE_3D) {\n\t      gl.texImage3D(target, 0, internalFormat, width, height, depth, 0, format, type, src);\n\t    } else {\n\t      gl.texImage2D(target, 0, internalFormat, width, height, 0, format, type, src);\n\t    }\n\t    restorePackState(gl, options);\n\t    return {\n\t      width: width,\n\t      height: height,\n\t      depth: depth,\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Sets a texture with no contents of a certain size. In other words calls `gl.texImage2D` with `null`.\n\t   * You must set `options.width` and `options.height`.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function setEmptyTexture(gl, tex, options) {\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    var format = options.format || gl.RGBA;\n\t    var internalFormat = options.internalFormat || format;\n\t    var type = options.type || gl.UNSIGNED_BYTE;\n\t    savePackState(gl, options);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      for (var ii = 0; ii < 6; ++ii) {\n\t        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, internalFormat, options.width, options.height, 0, format, type, null);\n\t      }\n\t    } else if (target === gl.TEXTURE_3D) {\n\t      gl.texImage3D(target, 0, internalFormat, options.width, options.height, options.depth, 0, format, type, null);\n\t    } else {\n\t      gl.texImage2D(target, 0, internalFormat, options.width, options.height, 0, format, type, null);\n\t    }\n\t    restorePackState(gl, options);\n\t  }\n\t\n\t  /**\n\t   * Creates a texture based on the options passed in.\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n\t   * @param {module:twgl.TextureReadyCallback} [callback] A callback called when an image has been downloaded and uploaded to the texture.\n\t   * @return {WebGLTexture} the created texture.\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function createTexture(gl, options, callback) {\n\t    callback = callback || noop;\n\t    options = options || defaults.textureOptions;\n\t    var tex = gl.createTexture();\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    var width  = options.width  || 1;\n\t    var height = options.height || 1;\n\t    gl.bindTexture(target, tex);\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      // this should have been the default for CUBEMAPS :(\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\t      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\t    }\n\t    var src = options.src;\n\t    if (src) {\n\t      if (typeof src === \"function\") {\n\t        src = src(gl, options);\n\t      }\n\t      if (typeof (src) === \"string\") {\n\t        loadTextureFromUrl(gl, tex, options, callback);\n\t      } else if (isArrayBuffer(src) ||\n\t                 (Array.isArray(src) && (\n\t                      typeof src[0] === 'number' ||\n\t                      Array.isArray(src[0]) ||\n\t                      isArrayBuffer(src[0]))\n\t                 )\n\t                ) {\n\t        var dimensions = setTextureFromArray(gl, tex, src, options);\n\t        width  = dimensions.width;\n\t        height = dimensions.height;\n\t      } else if (Array.isArray(src) && typeof (src[0]) === 'string') {\n\t        loadCubemapFromUrls(gl, tex, options, callback);\n\t      } else if (src instanceof HTMLElement) {\n\t        setTextureFromElement(gl, tex, src, options);\n\t        width  = src.width;\n\t        height = src.height;\n\t      } else {\n\t        throw \"unsupported src type\";\n\t      }\n\t    } else {\n\t      setEmptyTexture(gl, tex, options);\n\t    }\n\t    if (options.auto !== false) {\n\t      setTextureFilteringForSize(gl, tex, options, width, height);\n\t    }\n\t    setTextureParameters(gl, tex, options);\n\t    return tex;\n\t  }\n\t\n\t  /**\n\t   * Resizes a texture based on the options passed in.\n\t   *\n\t   * Note: This is not a generic resize anything function.\n\t   * It's mostly used by {@link module:twgl.resizeFramebufferInfo}\n\t   * It will use `options.src` if it exists to try to determine a `type`\n\t   * otherwise it will assume `gl.UNSIGNED_BYTE`. No data is provided\n\t   * for the texture. Texture parameters will be set accordingly\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {WebGLTexture} tex the texture to resize\n\t   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n\t   * @param {number} [width] the new width. If not passed in will use `options.width`\n\t   * @param {number} [height] the new height. If not passed in will use `options.height`\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function resizeTexture(gl, tex, options, width, height) {\n\t    width = width || options.width;\n\t    height = height || options.height;\n\t    var target = options.target || gl.TEXTURE_2D;\n\t    gl.bindTexture(target, tex);\n\t    var format = options.format || gl.RGBA;\n\t    var type;\n\t    var src = options.src;\n\t    if (!src) {\n\t      type = options.type || gl.UNSIGNED_BYTE;\n\t    } else if (isArrayBuffer(src) || (Array.isArray(src) && typeof (src[0]) === 'number')) {\n\t      type = options.type || getTextureTypeForArrayType(gl, src);\n\t    } else {\n\t      type = options.type || gl.UNSIGNED_BYTE;\n\t    }\n\t    if (target === gl.TEXTURE_CUBE_MAP) {\n\t      for (var ii = 0; ii < 6; ++ii) {\n\t        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, format, width, height, 0, format, type, null);\n\t      }\n\t    } else {\n\t      gl.texImage2D(target, 0, format, width, height, 0, format, type, null);\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Check if a src is an async request.\n\t   * if src is a string we're going to download an image\n\t   * if src is an array of strings we're going to download cubemap images\n\t   * @param {*} src The src from a TextureOptions\n\t   * @returns {bool} true if src is async.\n\t   */\n\t  function isAsyncSrc(src) {\n\t    return typeof src === 'string' ||\n\t           (Array.isArray(src) && typeof src[0] === 'string');\n\t  }\n\t\n\t  /**\n\t   * Creates a bunch of textures based on the passed in options.\n\t   *\n\t   * Example:\n\t   *\n\t   *     var textures = twgl.createTextures(gl, {\n\t   *       // a power of 2 image\n\t   *       hftIcon: { src: \"images/hft-icon-16.png\", mag: gl.NEAREST },\n\t   *       // a non-power of 2 image\n\t   *       clover: { src: \"images/clover.jpg\" },\n\t   *       // From a canvas\n\t   *       fromCanvas: { src: ctx.canvas },\n\t   *       // A cubemap from 6 images\n\t   *       yokohama: {\n\t   *         target: gl.TEXTURE_CUBE_MAP,\n\t   *         src: [\n\t   *           'images/yokohama/posx.jpg',\n\t   *           'images/yokohama/negx.jpg',\n\t   *           'images/yokohama/posy.jpg',\n\t   *           'images/yokohama/negy.jpg',\n\t   *           'images/yokohama/posz.jpg',\n\t   *           'images/yokohama/negz.jpg',\n\t   *         ],\n\t   *       },\n\t   *       // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)\n\t   *       goldengate: {\n\t   *         target: gl.TEXTURE_CUBE_MAP,\n\t   *         src: 'images/goldengate.jpg',\n\t   *       },\n\t   *       // A 2x2 pixel texture from a JavaScript array\n\t   *       checker: {\n\t   *         mag: gl.NEAREST,\n\t   *         min: gl.LINEAR,\n\t   *         src: [\n\t   *           255,255,255,255,\n\t   *           192,192,192,255,\n\t   *           192,192,192,255,\n\t   *           255,255,255,255,\n\t   *         ],\n\t   *       },\n\t   *       // a 1x2 pixel texture from a typed array.\n\t   *       stripe: {\n\t   *         mag: gl.NEAREST,\n\t   *         min: gl.LINEAR,\n\t   *         format: gl.LUMINANCE,\n\t   *         src: new Uint8Array([\n\t   *           255,\n\t   *           128,\n\t   *           255,\n\t   *           128,\n\t   *           255,\n\t   *           128,\n\t   *           255,\n\t   *           128,\n\t   *         ]),\n\t   *         width: 1,\n\t   *       },\n\t   *     });\n\t   *\n\t   * Now\n\t   *\n\t   * *   `textures.hftIcon` will be a 2d texture\n\t   * *   `textures.clover` will be a 2d texture\n\t   * *   `textures.fromCanvas` will be a 2d texture\n\t   * *   `textures.yohohama` will be a cubemap texture\n\t   * *   `textures.goldengate` will be a cubemap texture\n\t   * *   `textures.checker` will be a 2d texture\n\t   * *   `textures.stripe` will be a 2d texture\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per texture.\n\t   * @param {module:twgl.TexturesReadyCallback} [callback] A callback called when all textures have been downloaded.\n\t   * @return {Object.<string,WebGLTexture>} the created textures by name\n\t   * @memberOf module:twgl/textures\n\t   */\n\t  function createTextures(gl, textureOptions, callback) {\n\t    callback = callback || noop;\n\t    var numDownloading = 0;\n\t    var errors = [];\n\t    var textures = {};\n\t    var images = {};\n\t\n\t    function callCallbackIfReady() {\n\t      if (numDownloading === 0) {\n\t        setTimeout(function() {\n\t          callback(errors.length ? errors : undefined, textures, images);\n\t        }, 0);\n\t      }\n\t    }\n\t\n\t    Object.keys(textureOptions).forEach(function(name) {\n\t      var options = textureOptions[name];\n\t      var onLoadFn;\n\t      if (isAsyncSrc(options.src)) {\n\t        onLoadFn = function(err, tex, img) {\n\t          images[name] = img;\n\t          --numDownloading;\n\t          if (err) {\n\t            errors.push(err);\n\t          }\n\t          callCallbackIfReady();\n\t        };\n\t        ++numDownloading;\n\t      }\n\t      textures[name] = createTexture(gl, options, onLoadFn);\n\t    });\n\t\n\t    // queue the callback if there are no images to download.\n\t    // We do this because if your code is structured to wait for\n\t    // images to download but then you comment out all the async\n\t    // images your code would break.\n\t    callCallbackIfReady();\n\t\n\t    return textures;\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"setDefaults_\": setDefaults,\n\t\n\t    \"createTexture\": createTexture,\n\t    \"setEmptyTexture\": setEmptyTexture,\n\t    \"setTextureFromArray\": setTextureFromArray,\n\t    \"loadTextureFromUrl\": loadTextureFromUrl,\n\t    \"setTextureFromElement\": setTextureFromElement,\n\t    \"setTextureFilteringForSize\": setTextureFilteringForSize,\n\t    \"setTextureParameters\": setTextureParameters,\n\t    \"setDefaultTextureColor\": setDefaultTextureColor,\n\t    \"createTextures\": createTextures,\n\t    \"resizeTexture\": resizeTexture,\n\t    \"getNumComponentsForFormat\": getNumComponentsForFormat,\n\t  };\n\t});\n\t\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/framebuffers',[\n\t    './textures',\n\t    './utils',\n\t  ], function(\n\t    textures,\n\t    utils) {\n\t\n\t\n\t  /**\n\t   * Framebuffer related functions\n\t   *\n\t   * For backward compatibily they are available at both `twgl.framebuffer` and `twgl`\n\t   * itself\n\t   *\n\t   * See {@link module:twgl} for core functions\n\t   *\n\t   * @module twgl/framebuffers\n\t   */\n\t\n\t  // make sure we don't see a global gl\n\t  var gl = undefined;  // eslint-disable-line\n\t\n\t  var UNSIGNED_BYTE                  = 0x1401;\n\t\n\t  /* PixelFormat */\n\t  var DEPTH_COMPONENT                = 0x1902;\n\t  var RGBA                           = 0x1908;\n\t\n\t  /* Framebuffer Object. */\n\t  var RGBA4                          = 0x8056;\n\t  var RGB5_A1                        = 0x8057;\n\t  var RGB565                         = 0x8D62;\n\t  var DEPTH_COMPONENT16              = 0x81A5;\n\t  var STENCIL_INDEX                  = 0x1901;\n\t  var STENCIL_INDEX8                 = 0x8D48;\n\t  var DEPTH_STENCIL                  = 0x84F9;\n\t  var COLOR_ATTACHMENT0              = 0x8CE0;\n\t  var DEPTH_ATTACHMENT               = 0x8D00;\n\t  var STENCIL_ATTACHMENT             = 0x8D20;\n\t  var DEPTH_STENCIL_ATTACHMENT       = 0x821A;\n\t\n\t  /* TextureWrapMode */\n\t  var REPEAT                         = 0x2901;  // eslint-disable-line\n\t  var CLAMP_TO_EDGE                  = 0x812F;\n\t  var MIRRORED_REPEAT                = 0x8370;  // eslint-disable-line\n\t\n\t  /* TextureMagFilter */\n\t  var NEAREST                        = 0x2600;  // eslint-disable-line\n\t  var LINEAR                         = 0x2601;\n\t\n\t  /* TextureMinFilter */\n\t  var NEAREST_MIPMAP_NEAREST         = 0x2700;  // eslint-disable-line\n\t  var LINEAR_MIPMAP_NEAREST          = 0x2701;  // eslint-disable-line\n\t  var NEAREST_MIPMAP_LINEAR          = 0x2702;  // eslint-disable-line\n\t  var LINEAR_MIPMAP_LINEAR           = 0x2703;  // eslint-disable-line\n\t\n\t  /**\n\t   * The options for a framebuffer attachment.\n\t   *\n\t   * Note: For a `format` that is a texture include all the texture\n\t   * options from {@link module:twgl.TextureOptions} for example\n\t   * `min`, `mag`, `clamp`, etc... Note that unlike {@link module:twgl.TextureOptions}\n\t   * `auto` defaults to `false` for attachment textures but `min` and `mag` default\n\t   * to `gl.LINEAR` and `wrap` defaults to `CLAMP_TO_EDGE`\n\t   *\n\t   * @typedef {Object} AttachmentOptions\n\t   * @property {number} [attach] The attachment point. Defaults\n\t   *   to `gl.COLOR_ATTACTMENT0 + ndx` unless type is a depth or stencil type\n\t   *   then it's gl.DEPTH_ATTACHMENT or `gl.DEPTH_STENCIL_ATTACHMENT` depending\n\t   *   on the format or attachment type.\n\t   * @property {number} [format] The format. If one of `gl.RGBA4`,\n\t   *   `gl.RGB565`, `gl.RGB5_A1`, `gl.DEPTH_COMPONENT16`,\n\t   *   `gl.STENCIL_INDEX8` or `gl.DEPTH_STENCIL` then will create a\n\t   *   renderbuffer. Otherwise will create a texture. Default = `gl.RGBA`\n\t   * @property {number} [type] The type. Used for texture. Default = `gl.UNSIGNED_BYTE`.\n\t   * @property {number} [target] The texture target for `gl.framebufferTexture2D`.\n\t   *   Defaults to `gl.TEXTURE_2D`. Set to appropriate face for cube maps.\n\t   * @property {number} [level] level for `gl.framebufferTexture2D`. Defaults to 0.\n\t   * @property {WebGLObject} [attachment] An existing renderbuffer or texture.\n\t   *    If provided will attach this Object. This allows you to share\n\t   *    attachemnts across framebuffers.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  var defaultAttachments = [\n\t    { format: RGBA, type: UNSIGNED_BYTE, min: LINEAR, wrap: CLAMP_TO_EDGE, },\n\t    { format: DEPTH_STENCIL, },\n\t  ];\n\t\n\t  var attachmentsByFormat = {};\n\t  attachmentsByFormat[DEPTH_STENCIL] = DEPTH_STENCIL_ATTACHMENT;\n\t  attachmentsByFormat[STENCIL_INDEX] = STENCIL_ATTACHMENT;\n\t  attachmentsByFormat[STENCIL_INDEX8] = STENCIL_ATTACHMENT;\n\t  attachmentsByFormat[DEPTH_COMPONENT] = DEPTH_ATTACHMENT;\n\t  attachmentsByFormat[DEPTH_COMPONENT16] = DEPTH_ATTACHMENT;\n\t\n\t  function getAttachmentPointForFormat(format) {\n\t    return attachmentsByFormat[format];\n\t  }\n\t\n\t  var renderbufferFormats = {};\n\t  renderbufferFormats[RGBA4] = true;\n\t  renderbufferFormats[RGB5_A1] = true;\n\t  renderbufferFormats[RGB565] = true;\n\t  renderbufferFormats[DEPTH_STENCIL] = true;\n\t  renderbufferFormats[DEPTH_COMPONENT16] = true;\n\t  renderbufferFormats[STENCIL_INDEX] = true;\n\t  renderbufferFormats[STENCIL_INDEX8] = true;\n\t\n\t  function isRenderbufferFormat(format) {\n\t    return renderbufferFormats[format];\n\t  }\n\t\n\t  /**\n\t   * @typedef {Object} FramebufferInfo\n\t   * @property {WebGLFramebuffer} framebuffer The WebGLFramebuffer for this framebufferInfo\n\t   * @property {WebGLObject[]} attachments The created attachments in the same order as passed in to {@link module:twgl.createFramebufferInfo}.\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Creates a framebuffer and attachments.\n\t   *\n\t   * This returns a {@link module:twgl.FramebufferInfo} because it needs to return the attachments as well as the framebuffer.\n\t   *\n\t   * The simplest usage\n\t   *\n\t   *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer\n\t   *     var fbi = twgl.createFramebuffer(gl);\n\t   *\n\t   * More complex usage\n\t   *\n\t   *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer\n\t   *     var attachments = [\n\t   *       { format: RGB565, mag: NEAREST },\n\t   *       { format: STENCIL_INDEX8 },\n\t   *     ]\n\t   *     var fbi = twgl.createFramebuffer(gl, attachments);\n\t   *\n\t   * Passing in a specific size\n\t   *\n\t   *     var width = 256;\n\t   *     var height = 256;\n\t   *     var fbi = twgl.createFramebuffer(gl, attachments, width, height);\n\t   *\n\t   * **Note!!** It is up to you to check if the framebuffer is renderable by calling `gl.checkFramebufferStatus`.\n\t   * [WebGL only guarantees 3 combinations of attachments work](https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.6).\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.AttachmentOptions[]} [attachments] which attachments to create. If not provided the default is a framebuffer with an\n\t   *    `RGBA`, `UNSIGNED_BYTE` texture `COLOR_ATTACHMENT0` and a `DEPTH_STENCIL` renderbuffer `DEPTH_STENCIL_ATTACHMENT`.\n\t   * @param {number} [width] the width for the attachments. Default = size of drawingBuffer\n\t   * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer\n\t   * @return {module:twgl.FramebufferInfo} the framebuffer and attachments.\n\t   * @memberOf module:twgl/framebuffers\n\t   */\n\t  function createFramebufferInfo(gl, attachments, width, height) {\n\t    var target = gl.FRAMEBUFFER;\n\t    var fb = gl.createFramebuffer();\n\t    gl.bindFramebuffer(target, fb);\n\t    width  = width  || gl.drawingBufferWidth;\n\t    height = height || gl.drawingBufferHeight;\n\t    attachments = attachments || defaultAttachments;\n\t    var colorAttachmentCount = 0;\n\t    var framebufferInfo = {\n\t      framebuffer: fb,\n\t      attachments: [],\n\t      width: width,\n\t      height: height,\n\t    };\n\t    attachments.forEach(function(attachmentOptions) {\n\t      var attachment = attachmentOptions.attachment;\n\t      var format = attachmentOptions.format;\n\t      var attachmentPoint = getAttachmentPointForFormat(format);\n\t      if (!attachmentPoint) {\n\t        attachmentPoint = COLOR_ATTACHMENT0 + colorAttachmentCount++;\n\t      }\n\t      if (!attachment) {\n\t        if (isRenderbufferFormat(format)) {\n\t          attachment = gl.createRenderbuffer();\n\t          gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);\n\t          gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);\n\t        } else {\n\t          var textureOptions = utils.shallowCopy(attachmentOptions);\n\t          textureOptions.width = width;\n\t          textureOptions.height = height;\n\t          if (textureOptions.auto === undefined) {\n\t            textureOptions.auto = false;\n\t            textureOptions.min = textureOptions.min || gl.LINEAR;\n\t            textureOptions.mag = textureOptions.mag || gl.LINEAR;\n\t            textureOptions.wrapS = textureOptions.wrapS || textureOptions.wrap || gl.CLAMP_TO_EDGE;\n\t            textureOptions.wrapT = textureOptions.wrapT || textureOptions.wrap || gl.CLAMP_TO_EDGE;\n\t          }\n\t          attachment = textures.createTexture(gl, textureOptions);\n\t        }\n\t      }\n\t      if (attachment instanceof WebGLRenderbuffer) {\n\t        gl.framebufferRenderbuffer(target, attachmentPoint, gl.RENDERBUFFER, attachment);\n\t      } else if (attachment instanceof WebGLTexture) {\n\t        gl.framebufferTexture2D(\n\t            target,\n\t            attachmentPoint,\n\t            attachmentOptions.texTarget || gl.TEXTURE_2D,\n\t            attachment,\n\t            attachmentOptions.level || 0);\n\t      } else {\n\t        throw \"unknown attachment type\";\n\t      }\n\t      framebufferInfo.attachments.push(attachment);\n\t    });\n\t    return framebufferInfo;\n\t  }\n\t\n\t  /**\n\t   * Resizes the attachments of a framebuffer.\n\t   *\n\t   * You need to pass in the same `attachments` as you passed in {@link module:twgl.createFramebuffer}\n\t   * because TWGL has no idea the format/type of each attachment.\n\t   *\n\t   * The simplest usage\n\t   *\n\t   *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer\n\t   *     var fbi = twgl.createFramebuffer(gl);\n\t   *\n\t   *     ...\n\t   *\n\t   *     function render() {\n\t   *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {\n\t   *         // resize the attachments\n\t   *         twgl.resizeFramebufferInfo(gl, fbi);\n\t   *       }\n\t   *\n\t   * More complex usage\n\t   *\n\t   *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer\n\t   *     var attachments = [\n\t   *       { format: RGB565, mag: NEAREST },\n\t   *       { format: STENCIL_INDEX8 },\n\t   *     ]\n\t   *     var fbi = twgl.createFramebuffer(gl, attachments);\n\t   *\n\t   *     ...\n\t   *\n\t   *     function render() {\n\t   *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {\n\t   *         // resize the attachments to match\n\t   *         twgl.resizeFramebufferInfo(gl, fbi, attachments);\n\t   *       }\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.FramebufferInfo} framebufferInfo a framebufferInfo as returned from {@link module:twgl.createFramebuffer}.\n\t   * @param {module:twgl.AttachmentOptions[]} [attachments] the same attachments options as passed to {@link module:twgl.createFramebuffer}.\n\t   * @param {number} [width] the width for the attachments. Default = size of drawingBuffer\n\t   * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer\n\t   * @memberOf module:twgl/framebuffers\n\t   */\n\t  function resizeFramebufferInfo(gl, framebufferInfo, attachments, width, height) {\n\t    width  = width  || gl.drawingBufferWidth;\n\t    height = height || gl.drawingBufferHeight;\n\t    framebufferInfo.width = width;\n\t    framebufferInfo.height = height;\n\t    attachments = attachments || defaultAttachments;\n\t    attachments.forEach(function(attachmentOptions, ndx) {\n\t      var attachment = framebufferInfo.attachments[ndx];\n\t      var format = attachmentOptions.format;\n\t      if (attachment instanceof WebGLRenderbuffer) {\n\t        gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);\n\t        gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);\n\t      } else if (attachment instanceof WebGLTexture) {\n\t        textures.resizeTexture(gl, attachment, attachmentOptions, width, height);\n\t      } else {\n\t        throw \"unknown attachment type\";\n\t      }\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Binds a framebuffer\n\t   *\n\t   * This function pretty much soley exists because I spent hours\n\t   * trying to figure out why something I wrote wasn't working only\n\t   * to realize I forget to set the viewport dimensions.\n\t   * My hope is this function will fix that.\n\t   *\n\t   * It is effectively the same as\n\t   *\n\t   *     gl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);\n\t   *     gl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);\n\t   *\n\t   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n\t   * @param {module:twgl.FramebufferInfo} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebuffer}.\n\t   *   If not passed will bind the canvas.\n\t   * @param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.\n\t   * @memberOf module:twgl/framebuffers\n\t   */\n\t\n\t  function bindFramebufferInfo(gl, framebufferInfo, target) {\n\t    target = target || gl.FRAMEBUFFER;\n\t    if (framebufferInfo) {\n\t      gl.bindFramebuffer(target, framebufferInfo.framebuffer);\n\t      gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);\n\t    } else {\n\t      gl.bindFramebuffer(target, null);\n\t      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n\t    }\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  return {\n\t    \"bindFramebufferInfo\": bindFramebufferInfo,\n\t    \"createFramebufferInfo\": createFramebufferInfo,\n\t    \"resizeFramebufferInfo\": resizeFramebufferInfo,\n\t  };\n\t});\n\t\n\t\n\t/*\n\t * Copyright 2015, Gregg Tavares.\n\t * All rights reserved.\n\t *\n\t * Redistribution and use in source and binary forms, with or without\n\t * modification, are permitted provided that the following conditions are\n\t * met:\n\t *\n\t *     * Redistributions of source code must retain the above copyright\n\t * notice, this list of conditions and the following disclaimer.\n\t *     * Redistributions in binary form must reproduce the above\n\t * copyright notice, this list of conditions and the following disclaimer\n\t * in the documentation and/or other materials provided with the\n\t * distribution.\n\t *     * Neither the name of Gregg Tavares. nor the names of his\n\t * contributors may be used to endorse or promote products derived from\n\t * this software without specific prior written permission.\n\t *\n\t * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\t * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n\t * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\t * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n\t * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n\t * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n\t * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n\t * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n\t * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t */\n\t\n\tdefine('twgl/twgl',[\n\t    './attributes',\n\t    './draw',\n\t    './framebuffers',\n\t    './programs',\n\t    './textures',\n\t    './typedarrays',\n\t    './utils',\n\t  ], function(\n\t    attributes,\n\t    draw,\n\t    framebuffers,\n\t    programs,\n\t    textures,\n\t    typedArrays,\n\t    utils) {\n\t\n\t\n\t  /**\n\t   * The main TWGL module.\n\t   *\n\t   * For most use cases you shouldn't need anything outside this module.\n\t   * Exceptions between the stuff added to twgl-full (v3, m4, primitives)\n\t   *\n\t   * @module twgl\n\t   * @borrows module:twgl/attributes.setAttribInfoBufferFromArray as setAttribInfoBufferFromArray\n\t   * @borrows module:twgl/attributes.createBufferInfoFromArrays as createBufferInfoFromArrays\n\t   * @borrows module:twgl/attributes.createVertexArrayInfo as createVertexArrayInfo\n\t   * @borrows module:twgl/draw.drawBufferInfo as drawBufferInfo\n\t   * @borrows module:twgl/draw.drawObjectList as drawObjectList\n\t   * @borrows module:twgl/framebuffers.createFramebufferInfo as createFramebufferInfo\n\t   * @borrows module:twgl/framebuffers.resizeFramebufferInfo as resizeFramebufferInfo\n\t   * @borrows module:twgl/framebuffers.bindFramebufferInfo as bindFramebufferInfo\n\t   * @borrows module:twgl/programs.createProgramInfo as createProgramInfo\n\t   * @borrows module:twgl/programs.createUniformBlockInfo as createUniformBlockInfo\n\t   * @borrows module:twgl/programs.bindUniformBlock as bindUniformBlock\n\t   * @borrows module:twgl/programs.setUniformBlock as setUniformBlock\n\t   * @borrows module:twgl/programs.setBlockUniforms as setBlockUniforms\n\t   * @borrows module:twgl/programs.setUniforms as setUniforms\n\t   * @borrows module:twgl/programs.setBuffersAndAttributes as setBuffersAndAttributes\n\t   * @borrows module:twgl/textures.setTextureFromArray as setTextureFromArray\n\t   * @borrows module:twgl/textures.createTexture as createTexture\n\t   * @borrows module:twgl/textures.resizeTexture as resizeTexture\n\t   * @borrows module:twgl/textures.createTextures as createTextures\n\t   */\n\t\n\t  // make sure we don't see a global gl\n\t  var gl = undefined;  // eslint-disable-line\n\t  var defaults = {\n\t    enableVertexArrayObjects: true,\n\t  };\n\t\n\t  /**\n\t   * Various default settings for twgl.\n\t   *\n\t   * Note: You can call this any number of times. Example:\n\t   *\n\t   *     twgl.setDefaults({ textureColor: [1, 0, 0, 1] });\n\t   *     twgl.setDefaults({ attribPrefix: 'a_' });\n\t   *\n\t   * is equivalent to\n\t   *\n\t   *     twgl.setDefaults({\n\t   *       textureColor: [1, 0, 0, 1],\n\t   *       attribPrefix: 'a_',\n\t   *     });\n\t   *\n\t   * @typedef {Object} Defaults\n\t   * @property {string} attribPrefix The prefix to stick on attributes\n\t   *\n\t   *   When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`\n\t   *   as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.\n\t   *\n\t   *   In otherwords I'll create arrays of geometry like this\n\t   *\n\t   *       var arrays = {\n\t   *         position: ...\n\t   *         normal: ...\n\t   *         texcoord: ...\n\t   *       };\n\t   *\n\t   *   But need those mapped to attributes and my attributes start with `a_`.\n\t   *\n\t   *   Default: `\"\"`\n\t   *\n\t   * @property {number[]} textureColor Array of 4 values in the range 0 to 1\n\t   *\n\t   *   The default texture color is used when loading textures from\n\t   *   urls. Because the URL will be loaded async we'd like to be\n\t   *   able to use the texture immediately. By putting a 1x1 pixel\n\t   *   color in the texture we can start using the texture before\n\t   *   the URL has loaded.\n\t   *\n\t   *   Default: `[0.5, 0.75, 1, 1]`\n\t   *\n\t   * @property {string} crossOrigin\n\t   *\n\t   *   If not undefined sets the crossOrigin attribute on images\n\t   *   that twgl creates when downloading images for textures.\n\t   *\n\t   *   Also see {@link module:twgl.TextureOptions}.\n\t   *\n\t   * @property {bool} enableVertexArrayObjects\n\t   *\n\t   *   If true then in WebGL 1.0 will attempt to get the `OES_vertex_array_object` extension.\n\t   *   If successful it will copy create/bind/delete/isVertexArrayOES from the extension to\n\t   *   the WebGLRenderingContext removing the OES at the end which is the standard entry point\n\t   *   for WebGL 2.\n\t   *\n\t   *   Note: According to webglstats.com 90% of devices support `OES_vertex_array_object`.\n\t   *   If you just want to count on support I suggest using [this polyfill](https://github.com/KhronosGroup/WebGL/blob/master/sdk/demos/google/resources/OESVertexArrayObject.js)\n\t   *   or ignoring devices that don't support them.\n\t   *\n\t   *   Default: `true`\n\t   *\n\t   * @memberOf module:twgl\n\t   */\n\t\n\t  /**\n\t   * Sets various defaults for twgl.\n\t   *\n\t   * In the interest of terseness which is kind of the point\n\t   * of twgl I've integrated a few of the older functions here\n\t   *\n\t   * @param {module:twgl.Defaults} newDefaults The default settings.\n\t   * @memberOf module:twgl\n\t   */\n\t  function setDefaults(newDefaults) {\n\t    utils.copyExistingProperties(newDefaults, defaults);\n\t    attributes.setDefaults_(newDefaults);  // eslint-disable-line\n\t    textures.setDefaults_(newDefaults);  // eslint-disable-line\n\t  }\n\t\n\t  /**\n\t   * Adds Vertex Array Objects to WebGL 1 GL contexts if available\n\t   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n\t   */\n\t  function addVertexArrayObjectSupport(gl) {\n\t    if (!gl || !defaults.enableVertexArrayObjects) {\n\t      return;\n\t    }\n\t    if (utils.isWebGL1(gl)) {\n\t      var ext = gl.getExtension(\"OES_vertex_array_object\");\n\t      if (ext) {\n\t        gl.createVertexArray = function() {\n\t          return ext.createVertexArrayOES();\n\t        };\n\t        gl.deleteVertexArray = function(v) {\n\t          ext.deleteVertexArrayOES(v);\n\t        };\n\t        gl.isVertexArray = function(v) {\n\t          return ext.isVertexArrayOES(v);\n\t        };\n\t        gl.bindVertexArray = function(v) {\n\t          ext.bindVertexArrayOES(v);\n\t        };\n\t        gl.VERTEX_ARRAY_BINDING = ext.VERTEX_ARRAY_BINDING_OES;\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Creates a webgl context.\n\t   * @param {HTMLCanvasElement} canvas The canvas tag to get\n\t   *     context from. If one is not passed in one will be\n\t   *     created.\n\t   * @return {WebGLRenderingContext} The created context.\n\t   */\n\t  function create3DContext(canvas, opt_attribs) {\n\t    var names = [\"webgl\", \"experimental-webgl\"];\n\t    var context = null;\n\t    for (var ii = 0; ii < names.length; ++ii) {\n\t      try {\n\t        context = canvas.getContext(names[ii], opt_attribs);\n\t      } catch(e) {}  // eslint-disable-line\n\t      if (context) {\n\t        break;\n\t      }\n\t    }\n\t    return context;\n\t  }\n\t\n\t  /**\n\t   * Gets a WebGL context.\n\t   * @param {HTMLCanvasElement} canvas a canvas element.\n\t   * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes\n\t   * @memberOf module:twgl\n\t   */\n\t  function getWebGLContext(canvas, opt_attribs) {\n\t    var gl = create3DContext(canvas, opt_attribs);\n\t    addVertexArrayObjectSupport(gl);\n\t    return gl;\n\t  }\n\t\n\t  /**\n\t   * Creates a webgl context.\n\t   *\n\t   * Will return a WebGL2 context if possible.\n\t   *\n\t   * You can check if it's WebGL2 with\n\t   *\n\t   *     twgl.isWebGL2(gl);\n\t   *\n\t   * @param {HTMLCanvasElement} canvas The canvas tag to get\n\t   *     context from. If one is not passed in one will be\n\t   *     created.\n\t   * @return {WebGLRenderingContext} The created context.\n\t   */\n\t  function createContext(canvas, opt_attribs) {\n\t    var names = [\"webgl2\", \"experimental-webgl2\", \"webgl\", \"experimental-webgl\"];\n\t    var context = null;\n\t    for (var ii = 0; ii < names.length; ++ii) {\n\t      try {\n\t        context = canvas.getContext(names[ii], opt_attribs);\n\t      } catch(e) {}  // eslint-disable-line\n\t      if (context) {\n\t        break;\n\t      }\n\t    }\n\t    return context;\n\t  }\n\t\n\t  /**\n\t   * Gets a WebGL context.  Will create a WebGL2 context if possible.\n\t   *\n\t   * You can check if it's WebGL2 with\n\t   *\n\t   *    function isWebGL2(gl) {\n\t   *      return gl.getParameter(gl.VERSION).indexOf(\"WebGL 2.0 \") == 0;\n\t   *    }\n\t   *\n\t   * @param {HTMLCanvasElement} canvas a canvas element.\n\t   * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes\n\t   * @return {WebGLRenderingContext} The created context.\n\t   * @memberOf module:twgl\n\t   */\n\t  function getContext(canvas, opt_attribs) {\n\t    var gl = createContext(canvas, opt_attribs);\n\t    addVertexArrayObjectSupport(gl);\n\t    return gl;\n\t  }\n\t\n\t  /**\n\t   * Resize a canvas to match the size it's displayed.\n\t   * @param {HTMLCanvasElement} canvas The canvas to resize.\n\t   * @param {number} [multiplier] So you can pass in `window.devicePixelRatio` if you want to.\n\t   * @return {boolean} true if the canvas was resized.\n\t   * @memberOf module:twgl\n\t   */\n\t  function resizeCanvasToDisplaySize(canvas, multiplier) {\n\t    multiplier = multiplier || 1;\n\t    multiplier = Math.max(1, multiplier);\n\t    var width  = canvas.clientWidth  * multiplier | 0;\n\t    var height = canvas.clientHeight * multiplier | 0;\n\t    if (canvas.width !== width ||\n\t        canvas.height !== height) {\n\t      canvas.width = width;\n\t      canvas.height = height;\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  // Using quotes prevents Uglify from changing the names.\n\t  // No speed diff AFAICT.\n\t  var api = {\n\t    \"getContext\": getContext,\n\t    \"getWebGLContext\": getWebGLContext,\n\t    \"isWebGL1\": utils.isWebGL1,\n\t    \"isWebGL2\": utils.isWebGL2,\n\t    \"resizeCanvasToDisplaySize\": resizeCanvasToDisplaySize,\n\t    \"setDefaults\": setDefaults,\n\t  };\n\t\n\t  function notPrivate(name) {\n\t    return name[name.length - 1] !== '_';\n\t  }\n\t\n\t  function copyPublicProperties(src, dst) {\n\t    Object.keys(src).filter(notPrivate).forEach(function(key) {\n\t      dst[key] = src[key];\n\t    });\n\t    return dst;\n\t  }\n\t\n\t  var apis = {\n\t    attributes: attributes,\n\t    draw: draw,\n\t    framebuffers: framebuffers,\n\t    programs: programs,\n\t    textures: textures,\n\t    typedArrays: typedArrays,\n\t  };\n\t  Object.keys(apis).forEach(function(name) {\n\t    var srcApi = apis[name];\n\t    copyPublicProperties(srcApi, api);\n\t    api[name] = copyPublicProperties(srcApi, {});\n\t  });\n\t\n\t  return api;\n\t\n\t});\n\t\n\t\n\tdefine('main', [\n\t    'twgl/twgl',\n\t  ], function(\n\t    twgl\n\t  ) {\n\t    return twgl;\n\t})\n\t\n\tnotrequirebecasebrowserifymessesup(['main'], function(main) {\n\t  return main;\n\t}, undefined, true);   // forceSync = true\n\t\n\t\n\t\n\t\n\t;\n\tdefine(\"build/js/twgl-includer\", function(){});\n\t\n\t    return notrequirebecasebrowserifymessesup('main');\n\t}));\n\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// webglImageDisplacement.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0bca145b94796779a478","import noise from './shaders/noise.frag'\nimport frag from './shaders/main.frag'\nimport vert from './shaders/main.vert'\n\nimport {\n  bindFramebufferInfo,\n  getWebGLContext,\n  createProgramInfo,\n  createBufferInfoFromArrays,\n  createTexture,\n  resizeCanvasToDisplaySize,\n  setBuffersAndAttributes,\n  createFramebufferInfo,\n  setUniforms,\n  drawBufferInfo } from 'twgl-base.js'\n\nconst baseStyle = {display: 'block', backgroundColor: 'black', height: '100%', width: '100%'}\n\nconst applyStyles = (element, styles) => {\n  Object.keys(styles).forEach(style => {\n    element.style[style] = styles[style]\n  })\n}\n\nconst arrays = {\n  position: {numComponents: 2, data: [1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1]}\n}\n\nconst calculateRelativeCoords = (position, element) => {\n  const {top, left, width, height} = element.getBoundingClientRect()\n  const {clientX, clientY} = position\n  const elementX = Math.min(Math.max((clientX - left) / width, 0), 1)\n  const elementY = Math.min(Math.max((clientY - top) / height, 0), 1)\n  return {elementX, elementY}\n}\n\nclass ImageDisplacement {\n  constructor (options) {\n    this.pos = [0, 0]\n    this.parralax = [0, 0]\n    this.intensity = this.intensityD = 0\n    this.subsideScale = 500\n    this.imageSrc = options.imageSrc\n    this.element = options.element || document.body\n    let canvas = document.createElement('canvas')\n    applyStyles(canvas, baseStyle)\n    try {\n      this.gl = getWebGLContext(canvas)\n    } catch (error) { this.gl = null }\n    if (this.gl !== null) {\n      this.element.appendChild(canvas)\n      window.addEventListener('mousemove', this.updateMouse)\n      window.addEventListener('touchmove', this.updateMouse)\n      this.programInfo = createProgramInfo(this.gl, [vert, frag])\n      this.noiseProgramInfo = createProgramInfo(this.gl, [vert, noise])\n      this.bufferInfo = createBufferInfoFromArrays(this.gl, arrays)\n      this.framebufferInfo = createFramebufferInfo(this.gl)\n      this.texture = createTexture(this.gl, {src: this.imageSrc, wrap: this.gl.CLAMP_TO_EDGE}, () => {\n        this.render()\n      })\n    } else {\n      let fallBackImage = document.createElement('img')\n      applyStyles(fallBackImage, baseStyle)\n      fallBackImage.src = this.imageSrc\n      this.element.appendChild(fallBackImage)\n    }\n  }\n  updateMouse = event => {\n    if (event.touches && event.touches.length > 1) {\n      return\n    }\n    let touches = event.touches\n    if (!touches) {\n      touches = [{ clientX: event.clientX, clientY: event.clientY }]\n    }\n    let elementMousePos = calculateRelativeCoords(touches[0], this.element)\n    let pos = [elementMousePos.elementY, elementMousePos.elementX]\n    let intensity = Math.abs(pos[0] - 0.5) * 2\n    if (intensity < 0.1) intensity = 0\n    this.intensity = intensity\n    this.pos = pos\n  }\n  render = time => {\n    if (true || document.hasFocus()) {\n      this.intensityD -= (this.intensityD - this.intensity) / 20\n      this.parralax[1] -= (this.parralax[1] - ((this.pos[1] - 0.5) / 5)) / 20\n      this.parralax[0] -= (this.parralax[0] - ((this.pos[0] - 0.5) / 5)) / 20\n      if (this.delta > 0) this.delta -= 1\n      let noiseUniforms = {\n        time,\n        Period: 0.0002,\n        Parralax: [this.parralax[1], this.parralax[0]],\n        resolution: [this.gl.canvas.width, this.gl.canvas.height]\n      }\n      let uniforms = {\n        Frequency: 0.7,\n        Amplitude: 0.5,\n        Intensity: this.intensityD,\n        u_texSampler: this.texture,\n        u_noiseSampler: this.framebufferInfo.attachments[0],\n        resolution: [this.gl.canvas.width, this.gl.canvas.height]\n      }\n      resizeCanvasToDisplaySize(this.gl.canvas)\n      bindFramebufferInfo(this.gl, this.framebufferInfo)\n\n      this.gl.useProgram(this.noiseProgramInfo.program)\n      setBuffersAndAttributes(this.gl, this.noiseProgramInfo, this.bufferInfo)\n      setUniforms(this.noiseProgramInfo, noiseUniforms)\n      drawBufferInfo(this.gl, this.bufferInfo)\n\n      bindFramebufferInfo(this.gl, null)\n      this.gl.useProgram(this.programInfo.program)\n      setBuffersAndAttributes(this.gl, this.programInfo, this.bufferInfo)\n      setUniforms(this.programInfo, uniforms)\n      drawBufferInfo(this.gl, this.bufferInfo)\n    }\n    requestAnimationFrame(this.render)\n  }\n}\n\nmodule.exports = options => new ImageDisplacement(options)\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/classCallCheck.js\n// module id = 2\n// module chunks = 0","module.exports = { \"default\": require(\"core-js/library/fn/object/keys\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/keys.js\n// module id = 3\n// module chunks = 0","require('../../modules/es6.object.keys');\nmodule.exports = require('../../modules/_core').Object.keys;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/keys.js\n// module id = 4\n// module chunks = 0","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object')\n  , $keys    = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function(){\n  return function keys(it){\n    return $keys(toObject(it));\n  };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.keys.js\n// module id = 5\n// module chunks = 0","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-object.js\n// module id = 6\n// module chunks = 0","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_defined.js\n// module id = 7\n// module chunks = 0","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = require('./_object-keys-internal')\n  , enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys.js\n// module id = 8\n// module chunks = 0","var has          = require('./_has')\n  , toIObject    = require('./_to-iobject')\n  , arrayIndexOf = require('./_array-includes')(false)\n  , IE_PROTO     = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys-internal.js\n// module id = 9\n// module chunks = 0","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_has.js\n// module id = 10\n// module chunks = 0","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject')\n  , defined = require('./_defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-iobject.js\n// module id = 11\n// module chunks = 0","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iobject.js\n// module id = 12\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_cof.js\n// module id = 13\n// module chunks = 0","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length')\n  , toIndex   = require('./_to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_array-includes.js\n// module id = 14\n// module chunks = 0","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-length.js\n// module id = 15\n// module chunks = 0","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-integer.js\n// module id = 16\n// module chunks = 0","var toInteger = require('./_to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-index.js\n// module id = 17\n// module chunks = 0","var shared = require('./_shared')('keys')\n  , uid    = require('./_uid');\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared-key.js\n// module id = 18\n// module chunks = 0","var global = require('./_global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared.js\n// module id = 19\n// module chunks = 0","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_global.js\n// module id = 20\n// module chunks = 0","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_uid.js\n// module id = 21\n// module chunks = 0","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_enum-bug-keys.js\n// module id = 22\n// module chunks = 0","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export')\n  , core    = require('./_core')\n  , fails   = require('./_fails');\nmodule.exports = function(KEY, exec){\n  var fn  = (core.Object || {})[KEY] || Object[KEY]\n    , exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-sap.js\n// module id = 23\n// module chunks = 0","var global    = require('./_global')\n  , core      = require('./_core')\n  , ctx       = require('./_ctx')\n  , hide      = require('./_hide')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_export.js\n// module id = 24\n// module chunks = 0","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_core.js\n// module id = 25\n// module chunks = 0","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ctx.js\n// module id = 26\n// module chunks = 0","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_a-function.js\n// module id = 27\n// module chunks = 0","var dP         = require('./_object-dp')\n  , createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_hide.js\n// module id = 28\n// module chunks = 0","var anObject       = require('./_an-object')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , toPrimitive    = require('./_to-primitive')\n  , dP             = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-dp.js\n// module id = 29\n// module chunks = 0","var isObject = require('./_is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_an-object.js\n// module id = 30\n// module chunks = 0","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_is-object.js\n// module id = 31\n// module chunks = 0","module.exports = !require('./_descriptors') && !require('./_fails')(function(){\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ie8-dom-define.js\n// module id = 32\n// module chunks = 0","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_descriptors.js\n// module id = 33\n// module chunks = 0","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_fails.js\n// module id = 34\n// module chunks = 0","var isObject = require('./_is-object')\n  , document = require('./_global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_dom-create.js\n// module id = 35\n// module chunks = 0","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-primitive.js\n// module id = 36\n// module chunks = 0","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_property-desc.js\n// module id = 37\n// module chunks = 0","module.exports = \"precision highp float;\\n#define GLSLIFY 1\\nuniform vec2 resolution;\\nuniform sampler2D u_mySampler;\\nuniform float time;\\nuniform float Period;\\nuniform vec2 Parralax;\\nvarying vec2 v_position;\\n\\n// http://www.nutty.ca/?page_id=352&link=refraction\\n// Description : Array and textureless GLSL 3D simplex noise function.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\\nfloat snoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n  // First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n  // Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n  // Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n  //Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n  // Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\\n\\nvoid main() {\\n  float z = time * Period;\\n  vec2 uv = (v_position + Parralax) * 1.5;\\n  float value = (snoise(vec3(uv, z)) + 1.0) * 0.5;\\n  vec4 greyscale = vec4(value, value, value, 1.0);\\n  gl_FragColor = greyscale;\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./shaders/noise.frag\n// module id = 38\n// module chunks = 0","module.exports = \"precision highp float;\\n#define GLSLIFY 1\\nuniform vec2 resolution;\\nuniform sampler2D u_noiseSampler;\\nuniform sampler2D u_texSampler;\\nuniform float Amplitude;\\nuniform float Frequency;\\nuniform float Intensity;\\n\\nvarying vec2 v_position;\\nvarying vec2 v_texcoord;\\n\\nvec3 GetNormal () {\\n  float sobelX[9];\\n  sobelX[0] = 1.0; sobelX[1] = 0.0; sobelX[2] = -1.0;\\n  sobelX[3] = 2.0; sobelX[4] = 0.0; sobelX[5] = -2.0;\\n  sobelX[6] = 1.0; sobelX[7] = 0.0; sobelX[8] = -1.0;\\n\\n  float sobelY[9];\\n  sobelY[0] = 1.0; sobelY[1] = 2.0; sobelY[2] =  1.0;\\n  sobelY[3] = 0.0; sobelY[4] = 0.0; sobelY[5] =  0.0;\\n  sobelY[6] = -1.0; sobelY[7] = -2.0; sobelY[8] = -1.0;\\n\\n  float texelX[9];\\n  float texelY[9];\\n  vec2 uv = (v_texcoord) * Frequency;\\n  for (int i = 0; i < 9; i++)\\n  {\\n      vec4 otherTexel = texture2D(u_noiseSampler, uv);\\n      float average = (otherTexel.x + otherTexel.y + otherTexel.z) / 3.0;\\n      texelX[i] = average  * sobelX[i];\\n      texelY[i] = average  * sobelY[i];\\n  }\\n  vec3 normal = vec3(\\n    (texelX[0] + texelX[3] + texelX[6]) +\\n    (texelX[2] + texelX[5] + texelX[8]),\\n    (texelY[1] + texelY[2] + texelY[3]) +\\n    (texelY[6] + texelY[7] + texelY[8]),\\n    1.0 / Amplitude);\\n\\n  return normalize(normal);\\n}\\n\\nvoid main() {\\n  vec3 normal = GetNormal();\\n  vec2 offset = (normal.xy + vec2(0, 0.25)) * Intensity;\\n  vec2 uv = v_position * vec2(1.0, -0.5) + vec2(0, 0.5);\\n  gl_FragColor.xyz = texture2D(u_texSampler, uv + offset).xyz;\\n  gl_FragColor.w = 1.0;\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./shaders/main.frag\n// module id = 39\n// module chunks = 0","module.exports = \"#define GLSLIFY 1\\nattribute vec2 position;\\nvarying vec2 v_position;\\nvarying vec2 v_texcoord;\\n\\nvoid main() {\\n  gl_Position = vec4(position, 0, 1);\\n  v_position = position;\\n  v_texcoord = position.xy * 0.5 + 0.5;\\n}\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./shaders/main.vert\n// module id = 40\n// module chunks = 0","/**\n * @license twgl.js 2.1.0 Copyright (c) 2015, Gregg Tavares All Rights Reserved.\n * Available via the MIT license.\n * see: http://github.com/greggman/twgl.js for details\n */\n/**\n * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } if (typeof module !== 'undefined' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.twgl = factory();\n    }\n}(this, function () {\n\n/**\n * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar notrequirebecasebrowserifymessesupjs, notrequirebecasebrowserifymessesup, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level notrequirebecasebrowserifymessesup that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                name = name.split('/');\n                lastIndex = name.length - 1;\n\n                // Node .js allowance:\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n                }\n\n                //Lop off the last part of baseParts, so that . matches the\n                //\"directory\" and not name of the baseName's module. For instance,\n                //baseName of \"one/two/three\", maps to \"one/two/three.js\", but we\n                //want the directory, \"one/two\" for this normalization.\n                name = baseParts.slice(0, baseParts.length - 1).concat(name);\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a notrequirebecasebrowserifymessesup function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            var args = aps.call(arguments, 0);\n\n            //If first arg is not notrequirebecasebrowserifymessesup('string'), and there is only\n            //one arg, it is the array form without a callback. Insert\n            //a null so that the following concat is correct.\n            if (typeof args[0] !== 'string' && args.length === 1) {\n                args.push(null);\n            }\n            return req.apply(undef, args.concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        notrequirebecasebrowserifymessesup: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [notrequirebecasebrowserifymessesup, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['notrequirebecasebrowserifymessesup', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"notrequirebecasebrowserifymessesup\") {\n                    args[i] = handlers.notrequirebecasebrowserifymessesup(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    notrequirebecasebrowserifymessesupjs = notrequirebecasebrowserifymessesup = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support notrequirebecasebrowserifymessesup(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use notrequirebecasebrowserifymessesup('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    notrequirebecasebrowserifymessesupjs._defined = defined;\n\n    define = function (name, deps, callback) {\n        if (typeof name !== 'string') {\n            throw new Error('See almond README: incorrect module build, no module name');\n        }\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"node_modules/almond/almond.js\", function(){});\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\ndefine('twgl/typedarrays',[], function() {\n\n\n  /**\n   * Low level shader typed array related functions\n   *\n   * You should generally not need to use these functions. They are provided\n   * for those cases where you're doing something out of the ordinary\n   * and you need lower level access.\n   *\n   * For backward compatibily they are available at both `twgl.typedArray` and `twgl`\n   * itself\n   *\n   * See {@link module:twgl} for core functions\n   *\n   * @module twgl/typedArray\n   */\n\n\n  // make sure we don't see a global gl\n  var gl = undefined;  // eslint-disable-line\n\n  /* DataType */\n  var BYTE                           = 0x1400;\n  var UNSIGNED_BYTE                  = 0x1401;\n  var SHORT                          = 0x1402;\n  var UNSIGNED_SHORT                 = 0x1403;\n  var INT                            = 0x1404;\n  var UNSIGNED_INT                   = 0x1405;\n  var FLOAT                          = 0x1406;\n\n  /**\n   * Get the GL type for a typedArray\n   * @param {ArrayBuffer|ArrayBufferView} typedArray a typedArray\n   * @return {number} the GL type for array. For example pass in an `Int8Array` and `gl.BYTE` will\n   *   be returned. Pass in a `Uint32Array` and `gl.UNSIGNED_INT` will be returned\n   * @memberOf module:twgl/typedArray\n   */\n  function getGLTypeForTypedArray(typedArray) {\n    if (typedArray instanceof Int8Array)         { return BYTE; }           // eslint-disable-line\n    if (typedArray instanceof Uint8Array)        { return UNSIGNED_BYTE; }  // eslint-disable-line\n    if (typedArray instanceof Uint8ClampedArray) { return UNSIGNED_BYTE; }  // eslint-disable-line\n    if (typedArray instanceof Int16Array)        { return SHORT; }          // eslint-disable-line\n    if (typedArray instanceof Uint16Array)       { return UNSIGNED_SHORT; } // eslint-disable-line\n    if (typedArray instanceof Int32Array)        { return INT; }            // eslint-disable-line\n    if (typedArray instanceof Uint32Array)       { return UNSIGNED_INT; }   // eslint-disable-line\n    if (typedArray instanceof Float32Array)      { return FLOAT; }          // eslint-disable-line\n    throw \"unsupported typed array type\";\n  }\n\n  /**\n   * Get the typed array constructor for a given GL type\n   * @param {number} type the GL type. (eg: `gl.UNSIGNED_INT`)\n   * @return {function} the constructor for a the corresponding typed array. (eg. `Uint32Array`).\n   * @memberOf module:twgl/typedArray\n   */\n  function getTypedArrayTypeForGLType(type) {\n    switch (type) {\n      case BYTE:           return Int8Array;     // eslint-disable-line\n      case UNSIGNED_BYTE:  return Uint8Array;    // eslint-disable-line\n      case SHORT:          return Int16Array;    // eslint-disable-line\n      case UNSIGNED_SHORT: return Uint16Array;   // eslint-disable-line\n      case INT:            return Int32Array;    // eslint-disable-line\n      case UNSIGNED_INT:   return Uint32Array;   // eslint-disable-line\n      case FLOAT:          return Float32Array;  // eslint-disable-line\n      default:\n        throw \"unknown gl type\";\n    }\n  }\n\n  function isArrayBuffer(a) {\n    return a && a.buffer && a.buffer instanceof ArrayBuffer;\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  return {\n    \"getGLTypeForTypedArray\": getGLTypeForTypedArray,\n    \"getTypedArrayTypeForGLType\": getTypedArrayTypeForGLType,\n    \"isArrayBuffer\": isArrayBuffer,\n  };\n});\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/utils',[], function() {\n\n\n  /**\n   * Copy an object 1 level deep\n   * @param {object} src object to copy\n   * @return {object} the copy\n   */\n  function shallowCopy(src) {\n    var dst = {};\n    Object.keys(src).forEach(function(key) {\n      dst[key] = src[key];\n    });\n    return dst;\n  }\n\n  /**\n   * Copy named properties\n   *\n   * @param {string[]} names names of properties to copy\n   * @param {object} src object to copy properties from\n   * @param {object} dst object to copy properties to\n   */\n  function copyNamedProperties(names, src, dst) {\n    names.forEach(function(name) {\n      var value = src[name];\n      if (value !== undefined) {\n        dst[name] = value;\n      }\n    });\n  }\n\n  /**\n   * Copies properties from source to dest only if a matching key is in dest\n   *\n   * @param {Object.<string, ?>} src the source\n   * @param {Object.<string, ?>} dst the dest\n   */\n  function copyExistingProperties(src, dst) {\n    Object.keys(dst).forEach(function(key) {\n      if (dst.hasOwnProperty(key) && src.hasOwnProperty(key)) {\n        dst[key] = src[key];\n      }\n    });\n  }\n\n  /**\n   * Gets the gl version as a number\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @return {number} version of gl\n   */\n  function getVersionAsNumber(gl) {\n    return parseFloat(gl.getParameter(gl.VERSION).substr(6));\n  }\n\n  /**\n   * Check if context is WebGL 2.0\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @return {bool} true if it's WebGL 2.0\n   * @memberOf module:twgl\n   */\n  function isWebGL2(gl) {\n    return gl.getParameter(gl.VERSION).indexOf(\"WebGL 2.0\") === 0;\n  }\n\n  /**\n   * Check if context is WebGL 1.0\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @return {bool} true if it's WebGL 1.0\n   * @memberOf module:twgl\n   */\n  function isWebGL1(gl) {\n    var version = getVersionAsNumber(gl);\n    return version <= 1.0 && version > 0.0;  // because as of 2016/5 Edge returns 0.96\n  }\n\n  var error =\n      (    window.console\n        && window.console.error\n        && typeof window.console.error === \"function\"\n      )\n      ? window.console.error.bind(window.console)\n      : function() { };\n\n  var warn =\n      (    window.console\n        && window.console.warn\n        && typeof window.console.warn === \"function\"\n      )\n      ? window.console.warn.bind(window.console)\n      : function() { };\n\n  return {\n    copyExistingProperties: copyExistingProperties,\n    copyNamedProperties: copyNamedProperties,\n    shallowCopy: shallowCopy,\n    isWebGL1: isWebGL1,\n    isWebGL2: isWebGL2,\n    error: error,\n    warn: warn,\n  };\n});\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/attributes',[\n    './typedarrays',\n    './utils',\n  ], function(\n    typedArrays,\n    utils) {\n\n\n  /**\n   * Low level attribute and buffer related functions\n   *\n   * You should generally not need to use these functions. They are provided\n   * for those cases where you're doing something out of the ordinary\n   * and you need lower level access.\n   *\n   * For backward compatibily they are available at both `twgl.attributes` and `twgl`\n   * itself\n   *\n   * See {@link module:twgl} for core functions\n   *\n   * @module twgl/attributes\n   */\n\n  // make sure we don't see a global gl\n  var gl = undefined;  // eslint-disable-line\n  var defaults = {\n    attribPrefix: \"\",\n  };\n\n  /**\n   * Sets the default attrib prefix\n   *\n   * When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`\n   * as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.\n   *\n   * In otherwords I'll create arrays of geometry like this\n   *\n   *     var arrays = {\n   *       position: ...\n   *       normal: ...\n   *       texcoord: ...\n   *     };\n   *\n   * But need those mapped to attributes and my attributes start with `a_`.\n   *\n   * @deprecated see {@link module:twgl.setDefaults}\n   * @param {string} prefix prefix for attribs\n   * @memberOf module:twgl/attributes\n   */\n  function setAttributePrefix(prefix) {\n    defaults.attribPrefix = prefix;\n  }\n\n  function setDefaults(newDefaults) {\n    utils.copyExistingProperties(newDefaults, defaults);\n  }\n\n  function setBufferFromTypedArray(gl, type, buffer, array, drawType) {\n    gl.bindBuffer(type, buffer);\n    gl.bufferData(type, array, drawType || gl.STATIC_DRAW);\n  }\n\n  /**\n   * Given typed array creates a WebGLBuffer and copies the typed array\n   * into it.\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @param {ArrayBuffer|ArrayBufferView|WebGLBuffer} typedArray the typed array. Note: If a WebGLBuffer is passed in it will just be returned. No action will be taken\n   * @param {number} [type] the GL bind type for the buffer. Default = `gl.ARRAY_BUFFER`.\n   * @param {number} [drawType] the GL draw type for the buffer. Default = 'gl.STATIC_DRAW`.\n   * @return {WebGLBuffer} the created WebGLBuffer\n   * @memberOf module:twgl/attributes\n   */\n  function createBufferFromTypedArray(gl, typedArray, type, drawType) {\n    if (typedArray instanceof WebGLBuffer) {\n      return typedArray;\n    }\n    type = type || gl.ARRAY_BUFFER;\n    var buffer = gl.createBuffer();\n    setBufferFromTypedArray(gl, type, buffer, typedArray, drawType);\n    return buffer;\n  }\n\n  function isIndices(name) {\n    return name === \"indices\";\n  }\n\n  // This is really just a guess. Though I can't really imagine using\n  // anything else? Maybe for some compression?\n  function getNormalizationForTypedArray(typedArray) {\n    if (typedArray instanceof Int8Array)    { return true; }  // eslint-disable-line\n    if (typedArray instanceof Uint8Array)   { return true; }  // eslint-disable-line\n    return false;\n  }\n\n  function getArray(array) {\n    return array.length ? array : array.data;\n  }\n\n  var texcoordRE = /coord|texture/i;\n  var colorRE = /color|colour/i;\n\n  function guessNumComponentsFromName(name, length) {\n    var numComponents;\n    if (texcoordRE.test(name)) {\n      numComponents = 2;\n    } else if (colorRE.test(name)) {\n      numComponents = 4;\n    } else {\n      numComponents = 3;  // position, normals, indices ...\n    }\n\n    if (length % numComponents > 0) {\n      throw \"Can not guess numComponents for attribute '\" + name + \"'. Tried \" +\n            numComponents + \" but \" + length +\n            \" values is not evenly divisible by \" + numComponents +\n            \". You should specify it.\";\n    }\n\n    return numComponents;\n  }\n\n  function getNumComponents(array, arrayName) {\n    return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);\n  }\n\n  function makeTypedArray(array, name) {\n    if (typedArrays.isArrayBuffer(array)) {\n      return array;\n    }\n\n    if (typedArrays.isArrayBuffer(array.data)) {\n      return array.data;\n    }\n\n    if (Array.isArray(array)) {\n      array = {\n        data: array,\n      };\n    }\n\n    var Type = array.type;\n    if (!Type) {\n      if (isIndices(name)) {\n        Type = Uint16Array;\n      } else {\n        Type = Float32Array;\n      }\n    }\n    return new Type(array.data);\n  }\n\n  /**\n   * The info for an attribute. This is effectively just the arguments to `gl.vertexAttribPointer` plus the WebGLBuffer\n   * for the attribute.\n   *\n   * @typedef {Object} AttribInfo\n   * @property {number} [numComponents] the number of components for this attribute.\n   * @property {number} [size] synonym for `numComponents`.\n   * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`\n   * @property {boolean} [normalized] whether or not to normalize the data. Default = false\n   * @property {number} [offset] offset into buffer in bytes. Default = 0\n   * @property {number} [stride] the stride in bytes per element. Default = 0\n   * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute\n   * @property {number} [drawType] the draw type passed to gl.bufferData. Default = gl.STATIC_DRAW\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Use this type of array spec when TWGL can't guess the type or number of compoments of an array\n   * @typedef {Object} FullArraySpec\n   * @property {(number[]|ArrayBuffer)} data The data of the array.\n   * @property {number} [numComponents] number of components for `vertexAttribPointer`. Default is based on the name of the array.\n   *    If `coord` is in the name assumes `numComponents = 2`.\n   *    If `color` is in the name assumes `numComponents = 4`.\n   *    otherwise assumes `numComponents = 3`\n   * @property {constructor} type The type. This is only used if `data` is a JavaScript array. It is the constructor for the typedarray. (eg. `Uint8Array`).\n   * For example if you want colors in a `Uint8Array` you might have a `FullArraySpec` like `{ type: Uint8Array, data: [255,0,255,255, ...], }`.\n   * @property {number} [size] synonym for `numComponents`.\n   * @property {boolean} [normalize] normalize for `vertexAttribPointer`. Default is true if type is `Int8Array` or `Uint8Array` otherwise false.\n   * @property {number} [stride] stride for `vertexAttribPointer`. Default = 0\n   * @property {number} [offset] offset for `vertexAttribPointer`. Default = 0\n   * @property {string} [attrib] name of attribute this array maps to. Defaults to same name as array prefixed by the default attribPrefix.\n   * @property {string} [name] synonym for `attrib`.\n   * @property {string} [attribName] synonym for `attrib`.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * An individual array in {@link module:twgl.Arrays}\n   *\n   * When passed to {@link module:twgl.createBufferInfoFromArrays} if an ArraySpec is `number[]` or `ArrayBuffer`\n   * the types will be guessed based on the name. `indices` will be `Uint16Array`, everything else will\n   * be `Float32Array`\n   *\n   * @typedef {(number[]|ArrayBuffer|module:twgl.FullArraySpec)} ArraySpec\n   * @memberOf module:twgl\n   */\n\n  /**\n   * This is a JavaScript object of arrays by name. The names should match your shader's attributes. If your\n   * attributes have a common prefix you can specify it by calling {@link module:twgl.setAttributePrefix}.\n   *\n   *     Bare JavaScript Arrays\n   *\n   *         var arrays = {\n   *            position: [-1, 1, 0],\n   *            normal: [0, 1, 0],\n   *            ...\n   *         }\n   *\n   *     Bare TypedArrays\n   *\n   *         var arrays = {\n   *            position: new Float32Array([-1, 1, 0]),\n   *            color: new Uint8Array([255, 128, 64, 255]),\n   *            ...\n   *         }\n   *\n   * *   Will guess at `numComponents` if not specified based on name.\n   *\n   *     If `coord` is in the name assumes `numComponents = 2`\n   *\n   *     If `color` is in the name assumes `numComponents = 4`\n   *\n   *     otherwise assumes `numComponents = 3`\n   *\n   * Objects with various fields. See {@link module:twgl.FullArraySpec}.\n   *\n   *     var arrays = {\n   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n   *     };\n   *\n   * @typedef {Object.<string, module:twgl.ArraySpec>} Arrays\n   * @memberOf module:twgl\n   */\n\n\n  /**\n   * Creates a set of attribute data and WebGLBuffers from set of arrays\n   *\n   * Given\n   *\n   *      var arrays = {\n   *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n   *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n   *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n   *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },\n   *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n   *      };\n   *\n   * returns something like\n   *\n   *      var attribs = {\n   *        position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n   *        texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n   *        normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n   *        color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },\n   *      };\n   *\n   * notes:\n   *\n   * *   Arrays can take various forms\n   *\n   *     Bare JavaScript Arrays\n   *\n   *         var arrays = {\n   *            position: [-1, 1, 0],\n   *            normal: [0, 1, 0],\n   *            ...\n   *         }\n   *\n   *     Bare TypedArrays\n   *\n   *         var arrays = {\n   *            position: new Float32Array([-1, 1, 0]),\n   *            color: new Uint8Array([255, 128, 64, 255]),\n   *            ...\n   *         }\n   *\n   * *   Will guess at `numComponents` if not specified based on name.\n   *\n   *     If `coord` is in the name assumes `numComponents = 2`\n   *\n   *     If `color` is in the name assumes `numComponents = 4`\n   *\n   *     otherwise assumes `numComponents = 3`\n   *\n   * @param {WebGLRenderingContext} gl The webgl rendering context.\n   * @param {module:twgl.Arrays} arrays The arrays\n   * @return {Object.<string, module:twgl.AttribInfo>} the attribs\n   * @memberOf module:twgl/attributes\n   */\n  function createAttribsFromArrays(gl, arrays) {\n    var attribs = {};\n    Object.keys(arrays).forEach(function(arrayName) {\n      if (!isIndices(arrayName)) {\n        var array = arrays[arrayName];\n        var attribName = array.attrib || array.name || array.attribName || (defaults.attribPrefix + arrayName);\n        var typedArray = makeTypedArray(array, arrayName);\n        attribs[attribName] = {\n          buffer:        createBufferFromTypedArray(gl, typedArray, undefined, array.drawType),\n          numComponents: getNumComponents(array, arrayName),\n          type:          typedArrays.getGLTypeForTypedArray(typedArray),\n          normalize:     array.normalize !== undefined ? array.normalize : getNormalizationForTypedArray(typedArray),\n          stride:        array.stride || 0,\n          offset:        array.offset || 0,\n          drawType:      array.drawType,\n        };\n      }\n    });\n    return attribs;\n  }\n\n  /**\n   * Sets the contents of a buffer attached to an attribInfo\n   *\n   * This is helper function to dynamically update a buffer.\n   *\n   * Let's say you make a bufferInfo\n   *\n   *     var arrays = {\n   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n   *     };\n   *     var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\n   *\n   *  And you want to dynamically upate the positions. You could do this\n   *\n   *     // assuming arrays.position has already been updated with new data.\n   *     twgl.setAttribInfoBufferFromArray(gl, bufferInfo.attribs.position, arrays.position);\n   *\n   * @param {WebGLRenderingContext} gl\n   * @param {AttribInfo} attribInfo The attribInfo who's buffer contents to set. NOTE: If you have an attribute prefix\n   *   the name of the attribute will include the prefix.\n   * @param {ArraySpec} array Note: it is arguably ineffient to pass in anything but a typed array because anything\n   *    else will have to be converted to a typed array before it can be used by WebGL. During init time that\n   *    inefficiency is usually not important but if you're updating data dynamically best to be efficient.\n   * @param {number} [offset] an optional offset into the buffer. This is only an offset into the WebGL buffer\n   *    not the array. To pass in an offset into the array itself use a typed array and create an `ArrayBufferView`\n   *    for the portion of the array you want to use.\n   *\n   *        var someArray = new Float32Array(1000); // an array with 1000 floats\n   *        var someSubArray = new Float32Array(someArray.buffer, offsetInBytes, sizeInUnits); // a view into someArray\n   *\n   *    Now you can pass `someSubArray` into setAttribInfoBufferFromArray`\n   * @memberOf module:twgl/attributes\n   */\n  function setAttribInfoBufferFromArray(gl, attribInfo, array, offset) {\n    array = makeTypedArray(array);\n    if (offset) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, attribInfo.buffer);\n      gl.bufferSubData(gl.ARRAY_BUFFER, offset, array);\n    } else {\n      setBufferFromTypedArray(gl, gl.ARRAY_BUFFER, attribInfo.buffer, array, attribInfo.drawType);\n    }\n  }\n\n  /**\n   * tries to get the number of elements from a set of arrays.\n   */\n\n  var getNumElementsFromNonIndexedArrays = (function() {\n    var positionKeys = ['position', 'positions', 'a_position'];\n\n    return function getNumElementsFromNonIndexedArrays(arrays) {\n      var key;\n      for (var ii = 0; ii < positionKeys.length; ++ii) {\n        key = positionKeys[ii];\n        if (key in arrays) {\n          break;\n        }\n      }\n      if (ii === positionKeys.length) {\n        key = Object.keys(arrays)[0];\n      }\n      var array = arrays[key];\n      var length = getArray(array).length;\n      var numComponents = getNumComponents(array, key);\n      var numElements = length / numComponents;\n      if (length % numComponents > 0) {\n        throw \"numComponents \" + numComponents + \" not correct for length \" + length;\n      }\n      return numElements;\n    };\n  }());\n\n  /**\n   * @typedef {Object} BufferInfo\n   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n   * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..\n   * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.\n   * @property {Object.<string, module:twgl.AttribInfo>} [attribs] The attribs approriate to call `setAttributes`\n   * @memberOf module:twgl\n   */\n\n  /**\n   * @typedef {Object} VertexArrayInfo\n   * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n   * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..\n   * @property {WebGLVertexArrayObject> [vertexArrayObject] a vertex array object\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Creates a BufferInfo from an object of arrays.\n   *\n   * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to\n   * {@link module:twgl:drawBufferInfo}.\n   *\n   * Given an object like\n   *\n   *     var arrays = {\n   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n   *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n   *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n   *     };\n   *\n   *  Creates an BufferInfo like this\n   *\n   *     bufferInfo = {\n   *       numElements: 4,        // or whatever the number of elements is\n   *       indices: WebGLBuffer,  // this property will not exist if there are no indices\n   *       attribs: {\n   *         a_position: { buffer: WebGLBuffer, numComponents: 3, },\n   *         a_normal:   { buffer: WebGLBuffer, numComponents: 3, },\n   *         a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },\n   *       },\n   *     };\n   *\n   *  The properties of arrays can be JavaScript arrays in which case the number of components\n   *  will be guessed.\n   *\n   *     var arrays = {\n   *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],\n   *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],\n   *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],\n   *        indices:  [0, 1, 2, 1, 2, 3],\n   *     };\n   *\n   *  They can also by TypedArrays\n   *\n   *     var arrays = {\n   *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n   *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n   *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n   *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n   *     };\n   *\n   *  Or augmentedTypedArrays\n   *\n   *     var positions = createAugmentedTypedArray(3, 4);\n   *     var texcoords = createAugmentedTypedArray(2, 4);\n   *     var normals   = createAugmentedTypedArray(3, 4);\n   *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);\n   *\n   *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);\n   *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);\n   *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);\n   *     indices.push([0, 1, 2, 1, 2, 3]);\n   *\n   *     var arrays = {\n   *        position: positions,\n   *        texcoord: texcoords,\n   *        normal:   normals,\n   *        indices:  indices,\n   *     };\n   *\n   * For the last example it is equivalent to\n   *\n   *     var bufferInfo = {\n   *       attribs: {\n   *         a_position: { numComponents: 3, buffer: gl.createBuffer(), },\n   *         a_texcoods: { numComponents: 2, buffer: gl.createBuffer(), },\n   *         a_normals: { numComponents: 3, buffer: gl.createBuffer(), },\n   *       },\n   *       indices: gl.createBuffer(),\n   *       numElements: 6,\n   *     };\n   *\n   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_position.buffer);\n   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);\n   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_texcoord.buffer);\n   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);\n   *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_normal.buffer);\n   *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);\n   *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);\n   *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @param {module:twgl.Arrays} arrays Your data\n   * @return {module:twgl.BufferInfo} A BufferInfo\n   * @memberOf module:twgl/attributes\n   */\n  function createBufferInfoFromArrays(gl, arrays) {\n    var bufferInfo = {\n      attribs: createAttribsFromArrays(gl, arrays),\n    };\n    var indices = arrays.indices;\n    if (indices) {\n      indices = makeTypedArray(indices, \"indices\");\n      bufferInfo.indices = createBufferFromTypedArray(gl, indices, gl.ELEMENT_ARRAY_BUFFER);\n      bufferInfo.numElements = indices.length;\n      bufferInfo.elementType = typedArrays.getGLTypeForTypedArray(indices);\n    } else {\n      bufferInfo.numElements = getNumElementsFromNonIndexedArrays(arrays);\n    }\n\n    return bufferInfo;\n  }\n\n  /**\n   * Creates a buffer from an array, typed array, or array spec\n   *\n   * Given something like this\n   *\n   *     [1, 2, 3],\n   *\n   * or\n   *\n   *     new Uint16Array([1,2,3]);\n   *\n   * or\n   *\n   *     {\n   *        data: [1, 2, 3],\n   *        type: Uint8Array,\n   *     }\n   *\n   * returns a WebGLBuffer that constains the given data.\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n   * @param {module:twgl.ArraySpec} array an array, typed array, or array spec.\n   * @param {string} arrayName name of array. Used to guess the type if type can not be dervied other wise.\n   * @return {WebGLBuffer} a WebGLBuffer containing the data in array.\n   * @memberOf module:twgl/attributes\n   */\n  function createBufferFromArray(gl, array, arrayName) {\n    var type = arrayName === \"indices\" ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n    var typedArray = makeTypedArray(array, arrayName);\n    return createBufferFromTypedArray(gl, typedArray, type);\n  }\n\n  /**\n   * Creates buffers from arrays or typed arrays\n   *\n   * Given something like this\n   *\n   *     var arrays = {\n   *        positions: [1, 2, 3],\n   *        normals: [0, 0, 1],\n   *     }\n   *\n   * returns something like\n   *\n   *     buffers = {\n   *       positions: WebGLBuffer,\n   *       normals: WebGLBuffer,\n   *     }\n   *\n   * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n   * @param {module:twgl.Arrays} arrays\n   * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array\n   * @memberOf module:twgl/attributes\n   */\n  function createBuffersFromArrays(gl, arrays) {\n    var buffers = { };\n    Object.keys(arrays).forEach(function(key) {\n      buffers[key] = createBufferFromArray(gl, arrays[key], key);\n    });\n\n    return buffers;\n  }\n\n  /**\n   * Creates a BufferInfo from an object of arrays.\n   *\n   * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to\n   * {@link module:twgl:drawBufferInfo}.\n   *\n   * > **IMPORTANT:** Vertex Array Objects are **not** a direct analog for a BufferInfo. Vertex Array Objects\n   *   assign buffers to specific attributes at creation time. That means they can only be used with programs\n   *   who's attributes use the same attribute locations for the same purposes.\n   *\n   * > Bind your attribute locations by passing an array of attribute names to {@link module:twgl.createProgramInfo}\n   *   or use WebGL 2's GLSL ES 3's `layout(location = <num>)` to make sure locations match.\n   *\n   * also\n   *\n   * > **IMPORTANT:** After calling twgl.setBuffersAndAttribute with a BufferInfo that uses a Vertex Array Object\n   *   that Vertex Array Object will be bound. That means **ANY MANIPULATION OF ELEMENT_ARRAY_BUFFER or ATTRIBUTES**\n   *   will affect the Vertex Array Object state.\n   *\n   * > Call `gl.bindVertexArray(null)` to get back manipulating the global attributes and ELEMENT_ARRAY_BUFFER.\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @param {module:twgl.ProgramInfo|module:twgl.ProgramInfo[]} programInfo a programInfo or array of programInfos\n   *\n   *    You need to make sure every attribute that will be used is bound. So for example assume shader 1\n   *    uses attributes A, B, C and shader 2 uses attributes A, B, D. If you only pass in the programInfo\n   *    for shader 1 then only attributes A, B, and C will have their attributes set because TWGL doesn't\n   *    now attribute D's location.\n   *\n   *    So, you can pass in both shader 1 and shader 2's programInfo\n   *\n   * @return {module:twgl.VertexArrayInfo} The created VertexArrayInfo\n   *\n   * @memberOf module:twgl/attributes\n   */\n  function createVertexArrayInfo(gl, programInfos, bufferInfo) {\n    var vao = gl.createVertexArray();\n    gl.bindVertexArray(vao);\n    if (!programInfos.length) {\n      programInfos = [programInfos];\n    }\n    programInfos.forEach(function(programInfo) {\n      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n    });\n    gl.bindVertexArray(null);\n    return {\n      numElements: bufferInfo.numElements,\n      elementType: bufferInfo.elementType,\n      vertexArrayObject: vao,\n    };\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  // No speed diff AFAICT.\n  return {\n    \"createAttribsFromArrays\": createAttribsFromArrays,\n    \"createBuffersFromArrays\": createBuffersFromArrays,\n    \"createBufferFromArray\": createBufferFromArray,\n    \"createBufferFromTypedArray\": createBufferFromTypedArray,\n    \"createBufferInfoFromArrays\": createBufferInfoFromArrays,\n    \"setAttribInfoBufferFromArray\": setAttribInfoBufferFromArray,\n\n    \"createVertexArrayInfo\": createVertexArrayInfo,\n\n    \"setAttributePrefix\": setAttributePrefix,\n\n    \"setDefaults_\": setDefaults,\n    \"getNumComponents_\": getNumComponents,\n    \"getArray_\": getArray,\n  };\n\n});\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/programs',[\n    './utils',\n  ], function(\n    utils) {\n\n\n  /**\n   * Low level shader program related functions\n   *\n   * You should generally not need to use these functions. They are provided\n   * for those cases where you're doing something out of the ordinary\n   * and you need lower level access.\n   *\n   * For backward compatibily they are available at both `twgl.programs` and `twgl`\n   * itself\n   *\n   * See {@link module:twgl} for core functions\n   *\n   * @module twgl/programs\n   */\n\n  var error = utils.error;\n  var warn = utils.warn;\n\n  var FLOAT                         = 0x1406;\n  var FLOAT_VEC2                    = 0x8B50;\n  var FLOAT_VEC3                    = 0x8B51;\n  var FLOAT_VEC4                    = 0x8B52;\n  var INT                           = 0x1404;\n  var INT_VEC2                      = 0x8B53;\n  var INT_VEC3                      = 0x8B54;\n  var INT_VEC4                      = 0x8B55;\n  var BOOL                          = 0x8B56;\n  var BOOL_VEC2                     = 0x8B57;\n  var BOOL_VEC3                     = 0x8B58;\n  var BOOL_VEC4                     = 0x8B59;\n  var FLOAT_MAT2                    = 0x8B5A;\n  var FLOAT_MAT3                    = 0x8B5B;\n  var FLOAT_MAT4                    = 0x8B5C;\n  var SAMPLER_2D                    = 0x8B5E;\n  var SAMPLER_CUBE                  = 0x8B60;\n  var SAMPLER_3D                    = 0x8B5F;\n  var SAMPLER_2D_SHADOW             = 0x8B62;\n  var FLOAT_MAT2x3                  = 0x8B65;\n  var FLOAT_MAT2x4                  = 0x8B66;\n  var FLOAT_MAT3x2                  = 0x8B67;\n  var FLOAT_MAT3x4                  = 0x8B68;\n  var FLOAT_MAT4x2                  = 0x8B69;\n  var FLOAT_MAT4x3                  = 0x8B6A;\n  var SAMPLER_2D_ARRAY              = 0x8DC1;\n  var SAMPLER_2D_ARRAY_SHADOW       = 0x8DC4;\n  var SAMPLER_CUBE_SHADOW           = 0x8DC5;\n  var UNSIGNED_INT                  = 0x1405;\n  var UNSIGNED_INT_VEC2             = 0x8DC6;\n  var UNSIGNED_INT_VEC3             = 0x8DC7;\n  var UNSIGNED_INT_VEC4             = 0x8DC8;\n  var INT_SAMPLER_2D                = 0x8DCA;\n  var INT_SAMPLER_3D                = 0x8DCB;\n  var INT_SAMPLER_CUBE              = 0x8DCC;\n  var INT_SAMPLER_2D_ARRAY          = 0x8DCF;\n  var UNSIGNED_INT_SAMPLER_2D       = 0x8DD2;\n  var UNSIGNED_INT_SAMPLER_3D       = 0x8DD3;\n  var UNSIGNED_INT_SAMPLER_CUBE     = 0x8DD4;\n  var UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;\n\n  var TEXTURE_2D                    = 0x0DE1;\n  var TEXTURE_CUBE_MAP              = 0x8513;\n  var TEXTURE_3D                    = 0x806F;\n  var TEXTURE_2D_ARRAY              = 0x8C1A;\n\n  var typeMap = {};\n\n  /**\n   * Returns the corresponding bind point for a given sampler type\n   */\n  function getBindPointForSamplerType(gl, type) {\n    return typeMap[type].bindPoint;\n  }\n\n  // This kind of sucks! If you could compose functions as in `var fn = gl[name];`\n  // this code could be a lot smaller but that is sadly really slow (T_T)\n\n  function floatSetter(gl, location) {\n    return function(v) {\n      gl.uniform1f(location, v);\n    };\n  }\n\n  function floatArraySetter(gl, location) {\n    return function(v) {\n      gl.uniform1fv(location, v);\n    };\n  }\n\n  function floatVec2Setter(gl, location) {\n    return function(v) {\n      gl.uniform2fv(location, v);\n    };\n  }\n\n  function floatVec3Setter(gl, location) {\n    return function(v) {\n      gl.uniform3fv(location, v);\n    };\n  }\n\n  function floatVec4Setter(gl, location) {\n    return function(v) {\n      gl.uniform4fv(location, v);\n    };\n  }\n\n  function intSetter(gl, location) {\n    return function(v) {\n      gl.uniform1i(location, v);\n    };\n  }\n\n  function intArraySetter(gl, location) {\n    return function(v) {\n      gl.uniform1iv(location, v);\n    };\n  }\n\n  function intVec2Setter(gl, location) {\n    return function(v) {\n      gl.uniform2iv(location, v);\n    };\n  }\n\n  function intVec3Setter(gl, location) {\n    return function(v) {\n      gl.uniform3iv(location, v);\n    };\n  }\n\n  function intVec4Setter(gl, location) {\n    return function(v) {\n      gl.uniform4iv(location, v);\n    };\n  }\n\n  function uintSetter(gl, location) {\n    return function(v) {\n      gl.uniform1ui(location, v);\n    };\n  }\n\n  function uintArraySetter(gl, location) {\n    return function(v) {\n      gl.uniform1uiv(location, v);\n    };\n  }\n\n  function uintVec2Setter(gl, location) {\n    return function(v) {\n      gl.uniform2uiv(location, v);\n    };\n  }\n\n  function uintVec3Setter(gl, location) {\n    return function(v) {\n      gl.uniform3uiv(location, v);\n    };\n  }\n\n  function uintVec4Setter(gl, location) {\n    return function(v) {\n      gl.uniform4uiv(location, v);\n    };\n  }\n\n  function floatMat2Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix2fv(location, false, v);\n    };\n  }\n\n  function floatMat3Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix3fv(location, false, v);\n    };\n  }\n\n  function floatMat4Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix4fv(location, false, v);\n    };\n  }\n\n  function floatMat23Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix2x3fv(location, false, v);\n    };\n  }\n\n  function floatMat32Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix3x2fv(location, false, v);\n    };\n  }\n\n  function floatMat24Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix2x4fv(location, false, v);\n    };\n  }\n\n  function floatMat42Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix4x2fv(location, false, v);\n    };\n  }\n\n  function floatMat34Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix3x4fv(location, false, v);\n    };\n  }\n\n  function floatMat43Setter(gl, location) {\n    return function(v) {\n      gl.uniformMatrix4x3fv(location, false, v);\n    };\n  }\n\n  function samplerSetter(gl, type, unit, location) {\n    var bindPoint = getBindPointForSamplerType(gl, type);\n    return function(texture) {\n      gl.uniform1i(location, unit);\n      gl.activeTexture(gl.TEXTURE0 + unit);\n      gl.bindTexture(bindPoint, texture);\n    };\n  }\n\n  function samplerArraySetter(gl, type, unit, location, size) {\n    var bindPoint = getBindPointForSamplerType(gl, type);\n    var units = new Int32Array(size);\n    for (var ii = 0; ii < size; ++ii) {\n      units[ii] = unit + ii;\n    }\n\n    return function(textures) {\n      gl.uniform1iv(location, units);\n      textures.forEach(function(texture, index) {\n        gl.activeTexture(gl.TEXTURE0 + units[index]);\n        gl.bindTexture(bindPoint, texture);\n      });\n    };\n  }\n\n  typeMap[FLOAT]                         = { Type: Float32Array, size:  4, setter: floatSetter,      arraySetter: floatArraySetter, };\n  typeMap[FLOAT_VEC2]                    = { Type: Float32Array, size:  8, setter: floatVec2Setter,  };\n  typeMap[FLOAT_VEC3]                    = { Type: Float32Array, size: 12, setter: floatVec3Setter,  };\n  typeMap[FLOAT_VEC4]                    = { Type: Float32Array, size: 16, setter: floatVec4Setter,  };\n  typeMap[INT]                           = { Type: Int32Array,   size:  4, setter: intSetter,        arraySetter: intArraySetter, };\n  typeMap[INT_VEC2]                      = { Type: Int32Array,   size:  8, setter: intVec2Setter,    };\n  typeMap[INT_VEC3]                      = { Type: Int32Array,   size: 12, setter: intVec3Setter,    };\n  typeMap[INT_VEC4]                      = { Type: Int32Array,   size: 16, setter: intVec4Setter,    };\n  typeMap[UNSIGNED_INT]                  = { Type: Uint32Array,  size:  4, setter: uintSetter,       arraySetter: uintArraySetter, };\n  typeMap[UNSIGNED_INT_VEC2]             = { Type: Uint32Array,  size:  8, setter: uintVec2Setter,   };\n  typeMap[UNSIGNED_INT_VEC3]             = { Type: Uint32Array,  size: 12, setter: uintVec3Setter,   };\n  typeMap[UNSIGNED_INT_VEC4]             = { Type: Uint32Array,  size: 16, setter: uintVec4Setter,   };\n  typeMap[BOOL]                          = { Type: Uint32Array,  size:  4, setter: intSetter,        arraySetter: intArraySetter, };\n  typeMap[BOOL_VEC2]                     = { Type: Uint32Array,  size:  8, setter: intVec2Setter,    };\n  typeMap[BOOL_VEC3]                     = { Type: Uint32Array,  size: 12, setter: intVec3Setter,    };\n  typeMap[BOOL_VEC4]                     = { Type: Uint32Array,  size: 16, setter: intVec4Setter,    };\n  typeMap[FLOAT_MAT2]                    = { Type: Float32Array, size: 16, setter: floatMat2Setter,  };\n  typeMap[FLOAT_MAT3]                    = { Type: Float32Array, size: 36, setter: floatMat3Setter,  };\n  typeMap[FLOAT_MAT4]                    = { Type: Float32Array, size: 64, setter: floatMat4Setter,  };\n  typeMap[FLOAT_MAT2x3]                  = { Type: Float32Array, size: 24, setter: floatMat23Setter, };\n  typeMap[FLOAT_MAT2x4]                  = { Type: Float32Array, size: 32, setter: floatMat24Setter, };\n  typeMap[FLOAT_MAT3x2]                  = { Type: Float32Array, size: 24, setter: floatMat32Setter, };\n  typeMap[FLOAT_MAT3x4]                  = { Type: Float32Array, size: 48, setter: floatMat34Setter, };\n  typeMap[FLOAT_MAT4x2]                  = { Type: Float32Array, size: 32, setter: floatMat42Setter, };\n  typeMap[FLOAT_MAT4x3]                  = { Type: Float32Array, size: 48, setter: floatMat43Setter, };\n  typeMap[SAMPLER_2D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n  typeMap[SAMPLER_CUBE]                  = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n  typeMap[SAMPLER_3D]                    = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };\n  typeMap[SAMPLER_2D_SHADOW]             = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n  typeMap[SAMPLER_2D_ARRAY]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n  typeMap[SAMPLER_2D_ARRAY_SHADOW]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n  typeMap[SAMPLER_CUBE_SHADOW]           = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n  typeMap[INT_SAMPLER_2D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n  typeMap[INT_SAMPLER_3D]                = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };\n  typeMap[INT_SAMPLER_CUBE]              = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n  typeMap[INT_SAMPLER_2D_ARRAY]          = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n  typeMap[UNSIGNED_INT_SAMPLER_2D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D,       };\n  typeMap[UNSIGNED_INT_SAMPLER_3D]       = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_3D,       };\n  typeMap[UNSIGNED_INT_SAMPLER_CUBE]     = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_CUBE_MAP, };\n  typeMap[UNSIGNED_INT_SAMPLER_2D_ARRAY] = { Type: null,         size:  0, setter: samplerSetter,    arraySetter: samplerArraySetter, bindPoint: TEXTURE_2D_ARRAY, };\n\n  var attrTypeMap = {};\n  attrTypeMap[FLOAT_MAT2] = { size:  4, count: 2, };\n  attrTypeMap[FLOAT_MAT3] = { size:  9, count: 3, };\n  attrTypeMap[FLOAT_MAT4] = { size: 16, count: 4, };\n\n  // make sure we don't see a global gl\n  var gl = undefined;  // eslint-disable-line\n\n  /**\n   * Error Callback\n   * @callback ErrorCallback\n   * @param {string} msg error message.\n   * @param {number} [lineOffset] amount to add to line number\n   * @memberOf module:twgl\n   */\n\n  function addLineNumbers(src, lineOffset) {\n    lineOffset = lineOffset || 0;\n    ++lineOffset;\n\n    return src.split(\"\\n\").map(function(line, ndx) {\n      return (ndx + lineOffset) + \": \" + line;\n    }).join(\"\\n\");\n  }\n\n  var spaceRE = /^[ \\t]*\\n/;\n\n  /**\n   * Loads a shader.\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n   * @param {string} shaderSource The shader source.\n   * @param {number} shaderType The type of shader.\n   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors.\n   * @return {WebGLShader} The created shader.\n   */\n  function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\n    var errFn = opt_errorCallback || error;\n    // Create the shader object\n    var shader = gl.createShader(shaderType);\n\n    // Remove the first end of line because WebGL 2.0 notrequirebecasebrowserifymessesups\n    // #version 300 es\n    // as the first line. No whitespace allowed before that line\n    // so\n    //\n    // <script>\n    // #version 300 es\n    // </script>\n    //\n    // Has one line before it which is invalid according to GLSL ES 3.00\n    //\n    var lineOffset = 0;\n    if (spaceRE.test(shaderSource)) {\n      lineOffset = 1;\n      shaderSource = shaderSource.replace(spaceRE, '');\n    }\n\n    // Load the shader source\n    gl.shaderSource(shader, shaderSource);\n\n    // Compile the shader\n    gl.compileShader(shader);\n\n    // Check the compile status\n    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (!compiled) {\n      // Something went wrong during compilation; get the error\n      var lastError = gl.getShaderInfoLog(shader);\n      errFn(addLineNumbers(shaderSource, lineOffset) + \"\\n*** Error compiling shader: \" + lastError);\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    return shader;\n  }\n\n  /**\n   * Creates a program, attaches shaders, binds attrib locations, links the\n   * program and calls useProgram.\n   *\n   * NOTE: There are 3 signatures for this function\n   *\n   *     twgl.createProgram(gl, [vs, fs], opt_errFunc);\n   *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_errFunc);\n   *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n   *\n   * @param {WebGLShader[]} shaders The shaders to attach\n   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console\n   *        on error. If you want something else pass an callback. It's passed an error message.\n   * @return {WebGLProgram?} the created program or null if error.\n   * @memberOf module:twgl/programs\n   */\n  function createProgram(\n      gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {\n    if (typeof opt_locations === 'function') {\n      opt_errorCallback = opt_locations;\n      opt_locations = undefined;\n    }\n    if (typeof opt_attribs === 'function') {\n      opt_errorCallback = opt_attribs;\n      opt_attribs = undefined;\n    }\n    var errFn = opt_errorCallback || error;\n    var program = gl.createProgram();\n    shaders.forEach(function(shader) {\n      gl.attachShader(program, shader);\n    });\n    if (opt_attribs) {\n      opt_attribs.forEach(function(attrib,  ndx) {\n        gl.bindAttribLocation(\n            program,\n            opt_locations ? opt_locations[ndx] : ndx,\n            attrib);\n      });\n    }\n    gl.linkProgram(program);\n\n    // Check the link status\n    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!linked) {\n        // something went wrong with the link\n        var lastError = gl.getProgramInfoLog(program);\n        errFn(\"Error in program linking:\" + lastError);\n\n        gl.deleteProgram(program);\n        return null;\n    }\n    return program;\n  }\n\n  /**\n   * Loads a shader from a script tag.\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n   * @param {string} scriptId The id of the script tag.\n   * @param {number} [opt_shaderType] The type of shader. If not passed in it will\n   *     be derived from the type of the script tag.\n   * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors.\n   * @return {WebGLShader?} The created shader or null if error.\n   */\n  function createShaderFromScript(\n      gl, scriptId, opt_shaderType, opt_errorCallback) {\n    var shaderSource = \"\";\n    var shaderType;\n    var shaderScript = document.getElementById(scriptId);\n    if (!shaderScript) {\n      throw \"*** Error: unknown script element\" + scriptId;\n    }\n    shaderSource = shaderScript.text;\n\n    if (!opt_shaderType) {\n      if (shaderScript.type === \"x-shader/x-vertex\") {\n        shaderType = gl.VERTEX_SHADER;\n      } else if (shaderScript.type === \"x-shader/x-fragment\") {\n        shaderType = gl.FRAGMENT_SHADER;\n      } else if (shaderType !== gl.VERTEX_SHADER && shaderType !== gl.FRAGMENT_SHADER) {\n        throw \"*** Error: unknown shader type\";\n      }\n    }\n\n    return loadShader(\n        gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,\n        opt_errorCallback);\n  }\n\n  var defaultShaderType = [\n    \"VERTEX_SHADER\",\n    \"FRAGMENT_SHADER\",\n  ];\n\n  /**\n   * Creates a program from 2 script tags.\n   *\n   * NOTE: There are 3 signatures for this function\n   *\n   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_errFunc);\n   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_errFunc);\n   *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n   *\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n   *        to use.\n   * @param {string[]} shaderScriptIds Array of ids of the script\n   *        tags for the shaders. The first is assumed to be the\n   *        vertex shader, the second the fragment shader.\n   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n   *        on error. If you want something else pass an callback. It's passed an error message.\n   * @return {WebGLProgram} The created program.\n   * @memberOf module:twgl/programs\n   */\n  function createProgramFromScripts(\n      gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {\n    var shaders = [];\n    for (var ii = 0; ii < shaderScriptIds.length; ++ii) {\n      var shader = createShaderFromScript(\n          gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], opt_errorCallback);\n      if (!shader) {\n        return null;\n      }\n      shaders.push(shader);\n    }\n    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n  }\n\n  /**\n   * Creates a program from 2 sources.\n   *\n   * NOTE: There are 3 signatures for this function\n   *\n   *     twgl.createProgramFromSource(gl, [vs, fs], opt_errFunc);\n   *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_errFunc);\n   *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n   *\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n   *        to use.\n   * @param {string[]} shaderSourcess Array of sources for the\n   *        shaders. The first is assumed to be the vertex shader,\n   *        the second the fragment shader.\n   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n   * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n   *        on error. If you want something else pass an callback. It's passed an error message.\n   * @return {WebGLProgram} The created program.\n   * @memberOf module:twgl/programs\n   */\n  function createProgramFromSources(\n      gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n    var shaders = [];\n    for (var ii = 0; ii < shaderSources.length; ++ii) {\n      var shader = loadShader(\n          gl, shaderSources[ii], gl[defaultShaderType[ii]], opt_errorCallback);\n      if (!shader) {\n        return null;\n      }\n      shaders.push(shader);\n    }\n    return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n  }\n\n  /**\n   * Creates setter functions for all uniforms of a shader\n   * program.\n   *\n   * @see {@link module:twgl.setUniforms}\n   *\n   * @param {WebGLProgram} program the program to create setters for.\n   * @returns {Object.<string, function>} an object with a setter by name for each uniform\n   * @memberOf module:twgl/programs\n   */\n  function createUniformSetters(gl, program) {\n    var textureUnit = 0;\n\n    /**\n     * Creates a setter for a uniform of the given program with it's\n     * location embedded in the setter.\n     * @param {WebGLProgram} program\n     * @param {WebGLUniformInfo} uniformInfo\n     * @returns {function} the created setter.\n     */\n    function createUniformSetter(program, uniformInfo) {\n      var location = gl.getUniformLocation(program, uniformInfo.name);\n      var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === \"[0]\");\n      var type = uniformInfo.type;\n      var typeInfo = typeMap[type];\n      if (!typeInfo) {\n        throw (\"unknown type: 0x\" + type.toString(16)); // we should never get here.\n      }\n      if (typeInfo.bindPoint) {\n        // it's a sampler\n        var unit = textureUnit;\n        textureUnit += uniformInfo.size;\n\n        if (isArray) {\n          return typeInfo.arraySetter(gl, type, unit, location, uniformInfo.size);\n        } else {\n          return typeInfo.setter(gl, type, unit, location, uniformInfo.size);\n        }\n      } else {\n        if (typeInfo.arraySetter && isArray) {\n          return typeInfo.arraySetter(gl, location);\n        } else {\n          return typeInfo.setter(gl, location);\n        }\n      }\n    }\n\n    var uniformSetters = { };\n    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    for (var ii = 0; ii < numUniforms; ++ii) {\n      var uniformInfo = gl.getActiveUniform(program, ii);\n      if (!uniformInfo) {\n        break;\n      }\n      var name = uniformInfo.name;\n      // remove the array suffix.\n      if (name.substr(-3) === \"[0]\") {\n        name = name.substr(0, name.length - 3);\n      }\n      var setter = createUniformSetter(program, uniformInfo);\n      uniformSetters[name] = setter;\n    }\n    return uniformSetters;\n  }\n\n  /**\n   * @typedef {Object} UniformData\n   * @property {number} type The WebGL type enum for this uniform\n   * @property {number} size The number of elements for this uniform\n   * @property {number} blockNdx The block index this uniform appears in\n   * @property {number} offset The byte offset in the block for this uniform's value\n   * @memberOf module:twgl\n   */\n\n  /**\n   * The specification for one UniformBlockObject\n   *\n   * @typedef {Object} BlockSpec\n   * @property {number} index The index of the block.\n   * @property {number} size The size in bytes needed for the block\n   * @property {number[]} uniformIndices The indices of the uniforms used by the block. These indices\n   *    correspond to entries in a UniformData array in the {@link module:twgl.UniformBlockSpec}.\n   * @property {bool} usedByVertexShader Self explanitory\n   * @property {bool} usedByFragmentShader Self explanitory\n   * @property {bool} used Self explanitory\n   * @memberOf module:twgl\n   */\n\n  /**\n   * A `UniformBlockSpec` represents the data needed to create and bind\n   * UniformBlockObjects for a given program\n   *\n   * @typedef {Object} UniformBlockSpec\n   * @property {Object.<string, module:twgl.BlockSpec> blockSpecs The BlockSpec for each block by block name\n   * @property {UniformData[]} uniformData An array of data for each uniform by uniform index.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Creates a UniformBlockSpec for the given program.\n   *\n   * A UniformBlockSpec represents the data needed to create and bind\n   * UniformBlockObjects\n   *\n   * @param {WebGL2RenderingContext} gl A WebGL2 Rendering Context\n   * @param {WebGLProgram} program A WebGLProgram for a successfully linked program\n   * @return {module:twgl.UniformBlockSpec} The created UniformBlockSpec\n   * @memberOf module:twgl/programs\n   */\n  function createUniformBlockSpecFromProgram(gl, program) {\n    var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n    var uniformData = [];\n    var uniformIndices = [];\n\n    for (var ii = 0; ii < numUniforms; ++ii) {\n      uniformIndices.push(ii);\n      uniformData.push({});\n      var uniformInfo = gl.getActiveUniform(program, ii);\n      if (!uniformInfo) {\n        break;\n      }\n      // REMOVE [0]?\n      uniformData[ii].name = uniformInfo.name;\n    }\n\n    [\n      [ \"UNIFORM_TYPE\", \"type\" ],\n      [ \"UNIFORM_SIZE\", \"size\" ],  // num elements\n      [ \"UNIFORM_BLOCK_INDEX\", \"blockNdx\" ],\n      [ \"UNIFORM_OFFSET\", \"offset\", ],\n    ].forEach(function(pair) {\n      var pname = pair[0];\n      var key = pair[1];\n      gl.getActiveUniforms(program, uniformIndices, gl[pname]).forEach(function(value, ndx) {\n        uniformData[ndx][key] = value;\n      });\n    });\n\n    var blockSpecs = {};\n\n    var numUniformBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n    for (ii = 0; ii < numUniformBlocks; ++ii) {\n      var name = gl.getActiveUniformBlockName(program, ii);\n      var blockSpec = {\n        index: ii,\n        usedByVertexShader: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),\n        usedByFragmentShader: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),\n        size: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_DATA_SIZE),\n        uniformIndices: gl.getActiveUniformBlockParameter(program, ii, gl.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES),\n      };\n      blockSpec.used = blockSpec.usedByVertexSahder || blockSpec.usedByFragmentShader;\n      blockSpecs[name] = blockSpec;\n    }\n\n    return {\n      blockSpecs: blockSpecs,\n      uniformData: uniformData,\n    };\n  }\n\n  var arraySuffixRE = /\\[\\d+\\]\\.$/;  // better way to check?\n\n  /**\n   * Represents a UniformBlockObject including an ArrayBuffer with all the uniform values\n   * and a corresponding WebGLBuffer to hold those values on the GPU\n   *\n   * @typedef {Object} UniformBlockInfo\n   * @property {string} name The name of the block\n   * @property {ArrayBuffer} array The array buffer that contains the uniform values\n   * @property {Float32Array} asFloat A float view on the array buffer. This is useful\n   *    inspecting the contents of the buffer in the debugger.\n   * @property {WebGLBuffer} buffer A WebGL buffer that will hold a copy of the uniform values for rendering.\n   * @property {number} [offset] offset into buffer\n   * @property {Object.<string, ArrayBufferView>} uniforms A uniform name to ArrayBufferView map.\n   *   each Uniform has a correctly typed `ArrayBufferView` into array at the correct offset\n   *   and length of that uniform. So for example a float uniform would have a 1 float `Float32Array`\n   *   view. A single mat4 would have a 16 element `Float32Array` view. An ivec2 would have an\n   *   `Int32Array` view, etc.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Creates a `UniformBlockInfo` for the specified block\n   *\n   * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy\n   * `UniformBlockInfo` is returned**. This is because when debugging GLSL\n   * it is common to comment out large portions of a shader or for example set\n   * the final output to a constant. When that happens blocks get optimized out.\n   * If this function did not create dummy blocks your code would crash when debugging.\n   *\n   * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext\n   * @param {WebGLProgram} program A WebGLProgram\n   * @param {module:twgl.UniformBlockSpec} uinformBlockSpec. A UniformBlockSpec as returned\n   *     from {@link module:twgl.createUniformBlockSpecFromProgram}.\n   * @param {string} blockName The name of the block.\n   * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo\n   * @memberOf module:twgl/programs\n   */\n  function createUniformBlockInfoFromProgram(gl, program, uniformBlockSpec, blockName) {\n    var blockSpecs = uniformBlockSpec.blockSpecs;\n    var uniformData = uniformBlockSpec.uniformData;\n    var blockSpec = blockSpecs[blockName];\n    if (!blockSpec) {\n      warn(\"no uniform block object named:\", blockName);\n      return {\n        name: blockName,\n        uniforms: {},\n      };\n    }\n    var array = new ArrayBuffer(blockSpec.size);\n    var buffer = gl.createBuffer();\n    var uniformBufferIndex = blockSpec.index;\n    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);\n    gl.uniformBlockBinding(program, blockSpec.index, uniformBufferIndex);\n\n    var prefix = blockName + \".\";\n    if (arraySuffixRE.test(prefix)) {\n      prefix = prefix.replace(arraySuffixRE, \".\");\n    }\n    var uniforms = {};\n    blockSpec.uniformIndices.forEach(function(uniformNdx) {\n      var data = uniformData[uniformNdx];\n      var typeInfo = typeMap[data.type];\n      var Type = typeInfo.Type;\n      var length = data.size * typeInfo.size;\n      var name = data.name;\n      if (name.substr(0, prefix.length) === prefix) {\n        name = name.substr(prefix.length);\n      }\n      uniforms[name] = new Type(array, data.offset, length / Type.BYTES_PER_ELEMENT);\n    });\n    return {\n      name: blockName,\n      array: array,\n      asFloat: new Float32Array(array),  // for debugging\n      buffer: buffer,\n      uniforms: uniforms,\n    };\n  }\n\n  /**\n   * Creates a `UniformBlockInfo` for the specified block\n   *\n   * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy\n   * `UniformBlockInfo` is returned**. This is because when debugging GLSL\n   * it is common to comment out large portions of a shader or for example set\n   * the final output to a constant. When that happens blocks get optimized out.\n   * If this function did not create dummy blocks your code would crash when debugging.\n   *\n   * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext\n   * @param {module:twgl.ProgramInfo} programInfo a `ProgramInfo`\n   *     as returned from {@link module:twgl.createProgramInfo}\n   * @param {string} blockName The name of the block.\n   * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo\n   * @memberOf module:twgl/programs\n   */\n  function createUniformBlockInfo(gl, programInfo, blockName) {\n    return createUniformBlockInfoFromProgram(gl, programInfo.program, programInfo.uniformBlockSpec, blockName);\n  }\n\n  /**\n   * Binds a unform block to the matching uniform block point.\n   * Matches by blocks by name so blocks must have the same name not just the same\n   * structure.\n   *\n   * If you have changed any values and you upload the valus into the corresponding WebGLBuffer\n   * call {@link module:twgl.setUniformBlock} instead.\n   *\n   * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.\n   * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`\n   *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as\n   *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.\n   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from\n   *     {@link module:twgl.createUniformBlockInfo}.\n   * @return {bool} true if buffer was bound. If the programInfo has no block with the same block name\n   *     no buffer is bound.\n   * @memberOf module:twgl/programs\n   */\n  function bindUniformBlock(gl, programInfo, uniformBlockInfo) {\n    var uniformBlockSpec = programInfo.uniformBlockSpec || programInfo;\n    var blockSpec = uniformBlockSpec.blockSpecs[uniformBlockInfo.name];\n    if (blockSpec) {\n      var bufferBindIndex = blockSpec.index;\n      gl.bindBufferRange(gl.UNIFORM_BUFFER, bufferBindIndex, uniformBlockInfo.buffer, uniformBlockInfo.offset || 0, uniformBlockInfo.array.byteLength);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Uploads the current uniform values to the corresponding WebGLBuffer\n   * and binds that buffer to the program's corresponding bind point for the uniform block object.\n   *\n   * If you haven't changed any values and you only need to bind the uniform block object\n   * call {@link module:twgl.bindUniformBlock} instead.\n   *\n   * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.\n   * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`\n   *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as\n   *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.\n   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from\n   *     {@link module:twgl.createUniformBlockInfo}.\n   * @memberOf module:twgl/programs\n   */\n  function setUniformBlock(gl, programInfo, uniformBlockInfo) {\n    if (bindUniformBlock(gl, programInfo, uniformBlockInfo)) {\n      gl.bufferData(gl.UNIFORM_BUFFER, uniformBlockInfo.array, gl.DYNAMIC_DRAW);\n    }\n  }\n\n  /**\n   * Sets values of a uniform block object\n   *\n   * @param {module:twgl.UniformBlockInfo} uniformBlockInfo A UniformBlockInfo as returned by {@link module:twgl.createUniformBlockInfo}.\n   * @param {Object.<string, ?>} values A uniform name to value map where the value is correct for the given\n   *    type of uniform. So for example given a block like\n   *\n   *       uniform SomeBlock {\n   *         float someFloat;\n   *         vec2 someVec2;\n   *         vec3 someVec3Array[2];\n   *         int someInt;\n   *       }\n   *\n   *  You can set the values of the uniform block with\n   *\n   *       twgl.setBlockUniforms(someBlockInfo, {\n   *          someFloat: 12.3,\n   *          someVec2: [1, 2],\n   *          someVec3Array: [1, 2, 3, 4, 5, 6],\n   *          someInt: 5,\n   *       }\n   *\n   *  Arrays can be JavaScript arrays or typed arrays\n   *\n   *  Any name that doesn't match will be ignored\n   * @memberOf module:twgl/programs\n   */\n  function setBlockUniforms(uniformBlockInfo, values) {\n    var uniforms = uniformBlockInfo.uniforms;\n    for (var name in values) {\n      var array = uniforms[name];\n      if (array) {\n        var value = values[name];\n        if (value.length) {\n          array.set(value);\n        } else {\n          array[0] = value;\n        }\n      }\n    }\n  }\n\n  /**\n   * Set uniforms and binds related textures.\n   *\n   * example:\n   *\n   *     var programInfo = createProgramInfo(\n   *         gl, [\"some-vs\", \"some-fs\"]);\n   *\n   *     var tex1 = gl.createTexture();\n   *     var tex2 = gl.createTexture();\n   *\n   *     ... assume we setup the textures with data ...\n   *\n   *     var uniforms = {\n   *       u_someSampler: tex1,\n   *       u_someOtherSampler: tex2,\n   *       u_someColor: [1,0,0,1],\n   *       u_somePosition: [0,1,1],\n   *       u_someMatrix: [\n   *         1,0,0,0,\n   *         0,1,0,0,\n   *         0,0,1,0,\n   *         0,0,0,0,\n   *       ],\n   *     };\n   *\n   *     gl.useProgram(program);\n   *\n   * This will automatically bind the textures AND set the\n   * uniforms.\n   *\n   *     twgl.setUniforms(programInfo, uniforms);\n   *\n   * For the example above it is equivalent to\n   *\n   *     var texUnit = 0;\n   *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n   *     gl.bindTexture(gl.TEXTURE_2D, tex1);\n   *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n   *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n   *     gl.bindTexture(gl.TEXTURE_2D, tex2);\n   *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n   *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);\n   *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);\n   *     gl.uniformMatrix4fv(u_someMatrix, false, [\n   *         1,0,0,0,\n   *         0,1,0,0,\n   *         0,0,1,0,\n   *         0,0,0,0,\n   *       ]);\n   *\n   * Note it is perfectly reasonable to call `setUniforms` multiple times. For example\n   *\n   *     var uniforms = {\n   *       u_someSampler: tex1,\n   *       u_someOtherSampler: tex2,\n   *     };\n   *\n   *     var moreUniforms {\n   *       u_someColor: [1,0,0,1],\n   *       u_somePosition: [0,1,1],\n   *       u_someMatrix: [\n   *         1,0,0,0,\n   *         0,1,0,0,\n   *         0,0,1,0,\n   *         0,0,0,0,\n   *       ],\n   *     };\n   *\n   *     twgl.setUniforms(programInfo, uniforms);\n   *     twgl.setUniforms(programInfo, moreUniforms);\n   *\n   * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from\n   *        `createUniformSetters`.\n   * @param {Object.<string, ?>} values an object with values for the\n   *        uniforms.\n   *   You can pass multiple objects by putting them in an array or by calling with more arguments.For example\n   *\n   *     var sharedUniforms = {\n   *       u_fogNear: 10,\n   *       u_projection: ...\n   *       ...\n   *     };\n   *\n   *     var localUniforms = {\n   *       u_world: ...\n   *       u_diffuseColor: ...\n   *     };\n   *\n   *     twgl.setUniforms(programInfo, sharedUniforms, localUniforms);\n   *\n   *     // is the same as\n   *\n   *     twgl.setUniforms(programInfo, [sharedUniforms, localUniforms]);\n   *\n   *     // is the same as\n   *\n   *     twgl.setUniforms(programInfo, sharedUniforms);\n   *     twgl.setUniforms(programInfo, localUniforms};\n   *\n   * @memberOf module:twgl/programs\n   */\n  function setUniforms(setters, values) {  // eslint-disable-line\n    var actualSetters = setters.uniformSetters || setters;\n    var numArgs = arguments.length;\n    for (var andx = 1; andx < numArgs; ++andx) {\n      var vals = arguments[andx];\n      if (Array.isArray(vals)) {\n        var numValues = vals.length;\n        for (var ii = 0; ii < numValues; ++ii) {\n          setUniforms(actualSetters, vals[ii]);\n        }\n      } else {\n        for (var name in vals) {\n          var setter = actualSetters[name];\n          if (setter) {\n            setter(vals[name]);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Creates setter functions for all attributes of a shader\n   * program. You can pass this to {@link module:twgl.setBuffersAndAttributes} to set all your buffers and attributes.\n   *\n   * @see {@link module:twgl.setAttributes} for example\n   * @param {WebGLProgram} program the program to create setters for.\n   * @return {Object.<string, function>} an object with a setter for each attribute by name.\n   * @memberOf module:twgl/programs\n   */\n  function createAttributeSetters(gl, program) {\n    var attribSetters = {\n    };\n\n    function createAttribSetter(index) {\n      return function(b) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n        gl.enableVertexAttribArray(index);\n        gl.vertexAttribPointer(\n            index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);\n      };\n    }\n\n    function createMatAttribSetter(index, typeInfo) {\n      var defaultSize = typeInfo.size;\n      var count = typeInfo.count;\n\n      return function(b) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n        var numComponents = b.size || b.numComponents || defaultSize;\n        var size = numComponents / count;\n        var type = b.type || gl.FLOAT;\n        var typeInfo = typeMap[type];\n        var stride = typeInfo.size * numComponents;\n        var normalize = b.normalize || false;\n        var offset = b.offset || 0;\n        var rowOffset = stride / count;\n        for (var i = 0; i < count; ++i) {\n          gl.enableVertexAttribArray(index + i);\n          gl.vertexAttribPointer(\n              index + i, size, type, normalize, stride, offset + rowOffset * i);\n        }\n      };\n    }\n\n    var numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n    for (var ii = 0; ii < numAttribs; ++ii) {\n      var attribInfo = gl.getActiveAttrib(program, ii);\n      if (!attribInfo) {\n        break;\n      }\n      var index = gl.getAttribLocation(program, attribInfo.name);\n      var typeInfo = attrTypeMap[attribInfo.type];\n      if (typeInfo) {\n        attribSetters[attribInfo.name] = createMatAttribSetter(index, typeInfo);\n      } else {\n        attribSetters[attribInfo.name] = createAttribSetter(index);\n      }\n    }\n\n    return attribSetters;\n  }\n\n  /**\n   * Sets attributes and binds buffers (deprecated... use {@link module:twgl.setBuffersAndAttributes})\n   *\n   * Example:\n   *\n   *     var program = createProgramFromScripts(\n   *         gl, [\"some-vs\", \"some-fs\");\n   *\n   *     var attribSetters = createAttributeSetters(program);\n   *\n   *     var positionBuffer = gl.createBuffer();\n   *     var texcoordBuffer = gl.createBuffer();\n   *\n   *     var attribs = {\n   *       a_position: {buffer: positionBuffer, numComponents: 3},\n   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n   *     };\n   *\n   *     gl.useProgram(program);\n   *\n   * This will automatically bind the buffers AND set the\n   * attributes.\n   *\n   *     setAttributes(attribSetters, attribs);\n   *\n   * Properties of attribs. For each attrib you can add\n   * properties:\n   *\n   * *   type: the type of data in the buffer. Default = gl.FLOAT\n   * *   normalize: whether or not to normalize the data. Default = false\n   * *   stride: the stride. Default = 0\n   * *   offset: offset into the buffer. Default = 0\n   *\n   * For example if you had 3 value float positions, 2 value\n   * float texcoord and 4 value uint8 colors you'd setup your\n   * attribs like this\n   *\n   *     var attribs = {\n   *       a_position: {buffer: positionBuffer, numComponents: 3},\n   *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n   *       a_color: {\n   *         buffer: colorBuffer,\n   *         numComponents: 4,\n   *         type: gl.UNSIGNED_BYTE,\n   *         normalize: true,\n   *       },\n   *     };\n   *\n   * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters\n   * @param {Object.<string, module:twgl.AttribInfo>} buffers AttribInfos mapped by attribute name.\n   * @memberOf module:twgl/programs\n   * @deprecated use {@link module:twgl.setBuffersAndAttributes}\n   */\n  function setAttributes(setters, buffers) {\n    for (var name in buffers) {\n      var setter = setters[name];\n      if (setter) {\n        setter(buffers[name]);\n      }\n    }\n  }\n\n  /**\n   * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate\n   *\n   * Example:\n   *\n   *     var programInfo = createProgramInfo(\n   *         gl, [\"some-vs\", \"some-fs\");\n   *\n   *     var arrays = {\n   *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n   *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n   *     };\n   *\n   *     var bufferInfo = createBufferInfoFromArrays(gl, arrays);\n   *\n   *     gl.useProgram(programInfo.program);\n   *\n   * This will automatically bind the buffers AND set the\n   * attributes.\n   *\n   *     setBuffersAndAttributes(gl, programInfo, bufferInfo);\n   *\n   * For the example above it is equivilent to\n   *\n   *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n   *     gl.enableVertexAttribArray(a_positionLocation);\n   *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);\n   *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n   *     gl.enableVertexAttribArray(a_texcoordLocation);\n   *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n   * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters A `ProgramInfo` as returned from {@link module:twgl.createProgrmaInfo} or Attribute setters as returned from {@link module:twgl.createAttributeSetters}\n   * @param {(module:twgl.BufferInfo|module:twgl.vertexArrayInfo)} buffers a `BufferInfo` as returned from {@link module:twgl.createBufferInfoFromArrays}.\n   *   or a `VertexArrayInfo` as returned from {@link module:twgl.createVertexArrayInfo}\n   * @memberOf module:twgl/programs\n   */\n  function setBuffersAndAttributes(gl, programInfo, buffers) {\n    if (buffers.vertexArrayObject) {\n      gl.bindVertexArray(buffers.vertexArrayObject);\n    } else {\n      setAttributes(programInfo.attribSetters || programInfo, buffers.attribs);\n      if (buffers.indices) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\n      }\n    }\n  }\n\n  /**\n   * @typedef {Object} ProgramInfo\n   * @property {WebGLProgram} program A shader program\n   * @property {Object<string, function>} uniformSetters object of setters as returned from createUniformSetters,\n   * @property {Object<string, function>} attribSetters object of setters as returned from createAttribSetters,\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Creates a ProgramInfo from an existing program.\n   *\n   * A ProgramInfo contains\n   *\n   *     programInfo = {\n   *        program: WebGLProgram,\n   *        uniformSetters: object of setters as returned from createUniformSetters,\n   *        attribSetters: object of setters as returned from createAttribSetters,\n   *     }\n   *\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n   *        to use.\n   * @param {WebGLProgram} program an existing WebGLProgram.\n   * @return {module:twgl.ProgramInfo} The created ProgramInfo.\n   * @memberOf module:twgl/programs\n   */\n  function createProgramInfoFromProgram(gl, program) {\n    var uniformSetters = createUniformSetters(gl, program);\n    var attribSetters = createAttributeSetters(gl, program);\n    var programInfo = {\n      program: program,\n      uniformSetters: uniformSetters,\n      attribSetters: attribSetters,\n    };\n\n    if (utils.isWebGL2(gl)) {\n      programInfo.uniformBlockSpec = createUniformBlockSpecFromProgram(gl, program);\n    }\n\n    return programInfo;\n  }\n\n  /**\n   * Creates a ProgramInfo from 2 sources.\n   *\n   * A ProgramInfo contains\n   *\n   *     programInfo = {\n   *        program: WebGLProgram,\n   *        uniformSetters: object of setters as returned from createUniformSetters,\n   *        attribSetters: object of setters as returned from createAttribSetters,\n   *     }\n   *\n   * NOTE: There are 3 signatures for this function\n   *\n   *     twgl.createProgramInfo(gl, [vs, fs], opt_errFunc);\n   *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_errFunc);\n   *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);\n   *\n   * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n   *        to use.\n   * @param {string[]} shaderSourcess Array of sources for the\n   *        shaders or ids. The first is assumed to be the vertex shader,\n   *        the second the fragment shader.\n   * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n   * @param {number[]} [opt_locations] The locations for the attributes. A parallel array to opt_attribs letting you assign locations.\n   * @param {module:twgl.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n   *        on error. If you want something else pass an callback. It's passed an error message.\n   * @return {module:twgl.ProgramInfo?} The created ProgramInfo or null if it failed to link or compile\n   * @memberOf module:twgl/programs\n   */\n  function createProgramInfo(\n      gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n    if (typeof opt_locations === 'function') {\n      opt_errorCallback = opt_locations;\n      opt_locations = undefined;\n    }\n    if (typeof opt_attribs === 'function') {\n      opt_errorCallback = opt_attribs;\n      opt_attribs = undefined;\n    }\n    var errFn = opt_errorCallback || error;\n    var good = true;\n    shaderSources = shaderSources.map(function(source) {\n      // Lets assume if there is no \\n it's an id\n      if (source.indexOf(\"\\n\") < 0) {\n        var script = document.getElementById(source);\n        if (!script) {\n          errFn(\"no element with id: \" + source);\n          good = false;\n        } else {\n          source = script.text;\n        }\n      }\n      return source;\n    });\n    if (!good) {\n      return null;\n    }\n    var program = createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback);\n    if (!program) {\n      return null;\n    }\n    return createProgramInfoFromProgram(gl, program);\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  // No speed diff AFAICT.\n  return {\n    \"createAttributeSetters\": createAttributeSetters,\n\n    \"createProgram\": createProgram,\n    \"createProgramFromScripts\": createProgramFromScripts,\n    \"createProgramFromSources\": createProgramFromSources,\n    \"createProgramInfo\": createProgramInfo,\n    \"createProgramInfoFromProgram\": createProgramInfoFromProgram,\n    \"createUniformSetters\": createUniformSetters,\n    \"createUniformBlockSpecFromProgram\": createUniformBlockSpecFromProgram,\n    \"createUniformBlockInfoFromProgram\": createUniformBlockInfoFromProgram,\n    \"createUniformBlockInfo\": createUniformBlockInfo,\n\n    \"setAttributes\": setAttributes,\n    \"setBuffersAndAttributes\": setBuffersAndAttributes,\n    \"setUniforms\": setUniforms,\n    \"setUniformBlock\": setUniformBlock,\n    \"setBlockUniforms\": setBlockUniforms,\n    \"bindUniformBlock\": bindUniformBlock,\n  };\n\n});\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/draw',[\n    './programs',\n  ], function(\n    programs) {\n\n\n  /**\n   * Drawing related functions\n   *\n   * For backward compatibily they are available at both `twgl.draw` and `twgl`\n   * itself\n   *\n   * See {@link module:twgl} for core functions\n   *\n   * @module twgl/draw\n   */\n\n  /**\n   * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate\n   *\n   * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself\n   * but calling this means if you switch from indexed data to non-indexed\n   * data you don't have to remember to update your draw call.\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} bufferInfo A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays} or\n   *   a VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}\n   * @param {enum} [type] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...). Defaults to `gl.TRIANGLES`\n   * @param {number} [count] An optional count. Defaults to bufferInfo.numElements\n   * @param {number} [offset] An optional offset. Defaults to 0.\n   * @memberOf module:twgl/draw\n   */\n  function drawBufferInfo(gl, bufferInfo, type, count, offset) {\n    type = type === undefined ? gl.TRIANGLES : type;\n    var indices = bufferInfo.indices;\n    var elementType = bufferInfo.elementType;\n    var numElements = count === undefined ? bufferInfo.numElements : count;\n    offset = offset === undefined ? 0 : offset;\n    if (elementType || indices) {\n      gl.drawElements(type, numElements, elementType === undefined ? gl.UNSIGNED_SHORT : bufferInfo.elementType, offset);\n    } else {\n      gl.drawArrays(type, offset, numElements);\n    }\n  }\n\n  /**\n   * A DrawObject is useful for putting objects in to an array and passing them to {@link module:twgl.drawObjectList}.\n   *\n   * You need either a `BufferInfo` or a `VertexArrayInfo`.\n   *\n   * @typedef {Object} DrawObject\n   * @property {boolean} [active] whether or not to draw. Default = `true` (must be `false` to be not true). In otherwords `undefined` = `true`\n   * @property {number} [type] type to draw eg. `gl.TRIANGLES`, `gl.LINES`, etc...\n   * @property {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}\n   * @property {module:twgl.BufferInfo} [bufferInfo] A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays}\n   * @property {module:twgl.VertexArrayInfo} [vertexArrayInfo] A VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}\n   * @property {Object<string, ?>} uniforms The values for the uniforms.\n   *   You can pass multiple objects by putting them in an array. For example\n   *\n   *     var sharedUniforms = {\n   *       u_fogNear: 10,\n   *       u_projection: ...\n   *       ...\n   *     };\n   *\n   *     var localUniforms = {\n   *       u_world: ...\n   *       u_diffuseColor: ...\n   *     };\n   *\n   *     var drawObj = {\n   *       ...\n   *       uniforms: [sharedUniforms, localUniforms],\n   *     };\n   *\n   * @property {number} [offset] the offset to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to 0.\n   * @property {number} [count] the count to pass to `gl.drawArrays` or `gl.drawElemnts`. Defaults to bufferInfo.numElements.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Draws a list of objects\n   * @param {DrawObject[]} objectsToDraw an array of objects to draw.\n   * @memberOf module:twgl/draw\n   */\n  function drawObjectList(gl, objectsToDraw) {\n    var lastUsedProgramInfo = null;\n    var lastUsedBufferInfo = null;\n\n    objectsToDraw.forEach(function(object) {\n      if (object.active === false) {\n        return;\n      }\n\n      var programInfo = object.programInfo;\n      var bufferInfo = object.vertexArrayInfo || object.bufferInfo;\n      var bindBuffers = false;\n      var type = object.type === undefined ? gl.TRIANGLES : object.type;\n\n      if (programInfo !== lastUsedProgramInfo) {\n        lastUsedProgramInfo = programInfo;\n        gl.useProgram(programInfo.program);\n\n        // We have to rebind buffers when changing programs because we\n        // only bind buffers the program uses. So if 2 programs use the same\n        // bufferInfo but the 1st one uses only positions the when the\n        // we switch to the 2nd one some of the attributes will not be on.\n        bindBuffers = true;\n      }\n\n      // Setup all the needed attributes.\n      if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {\n        if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject && !bufferInfo.vertexArrayObject) {\n          gl.bindVertexArray(null);\n        }\n        lastUsedBufferInfo = bufferInfo;\n        programs.setBuffersAndAttributes(gl, programInfo, bufferInfo);\n      }\n\n      // Set the uniforms.\n      programs.setUniforms(programInfo, object.uniforms);\n\n      // Draw\n      drawBufferInfo(gl, bufferInfo, type, object.count, object.offset);\n    });\n\n    if (lastUsedBufferInfo.vertexArrayObject) {\n      gl.bindVertexArray(null);\n    }\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  // No speed diff AFAICT.\n  return {\n    \"drawBufferInfo\": drawBufferInfo,\n    \"drawObjectList\": drawObjectList,\n  };\n\n});\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/textures',[\n    './typedarrays',\n    './utils',\n  ], function(\n    typedArrays,\n    utils) {\n\n\n  /**\n   * Low level texture related functions\n   *\n   * You should generally not need to use these functions. They are provided\n   * for those cases where you're doing something out of the ordinary\n   * and you need lower level access.\n   *\n   * For backward compatibily they are available at both `twgl.textures` and `twgl`\n   * itself\n   *\n   * See {@link module:twgl} for core functions\n   *\n   * @module twgl/textures\n   */\n\n  // make sure we don't see a global gl\n  var gl = undefined;  // eslint-disable-line\n  var defaults = {\n    textureColor: new Uint8Array([128, 192, 255, 255]),\n    textureOptions: {},\n    crossOrigin: undefined,\n  };\n  var isArrayBuffer = typedArrays.isArrayBuffer;\n\n  /* PixelFormat */\n  var ALPHA                          = 0x1906;\n  var RGB                            = 0x1907;\n  var RGBA                           = 0x1908;\n  var LUMINANCE                      = 0x1909;\n  var LUMINANCE_ALPHA                = 0x190A;\n\n  /* TextureWrapMode */\n  var REPEAT                         = 0x2901;  // eslint-disable-line\n  var MIRRORED_REPEAT                = 0x8370;  // eslint-disable-line\n\n  /* TextureMagFilter */\n  var NEAREST                        = 0x2600;  // eslint-disable-line\n\n  /* TextureMinFilter */\n  var NEAREST_MIPMAP_NEAREST         = 0x2700;  // eslint-disable-line\n  var LINEAR_MIPMAP_NEAREST          = 0x2701;  // eslint-disable-line\n  var NEAREST_MIPMAP_LINEAR          = 0x2702;  // eslint-disable-line\n  var LINEAR_MIPMAP_LINEAR           = 0x2703;  // eslint-disable-line\n\n  /**\n   * Sets the default texture color.\n   *\n   * The default texture color is used when loading textures from\n   * urls. Because the URL will be loaded async we'd like to be\n   * able to use the texture immediately. By putting a 1x1 pixel\n   * color in the texture we can start using the texture before\n   * the URL has loaded.\n   *\n   * @param {number[]} color Array of 4 values in the range 0 to 1\n   * @deprecated see {@link module:twgl.setDefaults}\n   * @memberOf module:twgl/textures\n   */\n  function setDefaultTextureColor(color) {\n    defaults.textureColor = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);\n  }\n\n  function setDefaults(newDefaults) {\n    utils.copyExistingProperties(newDefaults, defaults);\n    if (newDefaults.textureColor) {\n      setDefaultTextureColor(newDefaults.textureColor);\n    }\n  }\n\n  /**\n   * Gets a string for gl enum\n   *\n   * Note: Several enums are the same. Without more\n   * context (which function) it's impossible to always\n   * give the correct enum.\n   *\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @param {number} value the value of the enum you want to look up.\n   */\n  var glEnumToString = (function() {\n    var enums;\n\n    function init(gl) {\n      if (!enums) {\n        enums = {};\n        Object.keys(gl).forEach(function(key) {\n          if (typeof gl[key] === 'number') {\n            enums[gl[key]] = key;\n          }\n        });\n      }\n    }\n\n    return function glEnumToString(gl, value) {\n      init();\n      return enums[value] || (\"0x\" + value.toString(16));\n    };\n  }());\n\n  /**\n   * A function to generate the source for a texture.\n   * @callback TextureFunc\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   * @param {module:twgl.TextureOptions} options the texture options\n   * @return {*} Returns any of the things documentented for `src` for {@link module:twgl.TextureOptions}.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Texture options passed to most texture functions. Each function will use whatever options\n   * are appropriate for its needs. This lets you pass the same options to all functions.\n   *\n   * @typedef {Object} TextureOptions\n   * @property {number} [target] the type of texture `gl.TEXTURE_2D` or `gl.TEXTURE_CUBE_MAP`. Defaults to `gl.TEXTURE_2D`.\n   * @property {number} [width] the width of the texture. Only used if src is an array or typed array or null.\n   * @property {number} [height] the height of a texture. Only used if src is an array or typed array or null.\n   * @property {number} [depth] the depth of a texture. Only used if src is an array or type array or null and target is `TEXTURE_3D` .\n   * @property {number} [min] the min filter setting (eg. `gl.LINEAR`). Defaults to `gl.NEAREST_MIPMAP_LINEAR`\n   *     or if texture is not a power of 2 on both dimensions then defaults to `gl.LINEAR`.\n   * @property {number} [mag] the mag filter setting (eg. `gl.LINEAR`). Defaults to `gl.LINEAR`\n   * @property {number} [internalFormat] internal format for texture. Defaults to `gl.RGBA`\n   * @property {number} [format] format for texture. Defaults to `gl.RGBA`.\n   * @property {number} [type] type for texture. Defaults to `gl.UNSIGNED_BYTE` unless `src` is ArrayBuffer. If `src`\n   *     is ArrayBuffer defaults to type that matches ArrayBuffer type.\n   * @property {number} [wrap] Texture wrapping for both S and T (and R if TEXTURE_3D). Defaults to `gl.REPEAT` for 2D unless src is WebGL1 and src not npot and `gl.CLAMP_TO_EDGE` for cube\n   * @property {number} [wrapS] Texture wrapping for S. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n   * @property {number} [wrapT] Texture wrapping for T. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n   * @property {number} [wrapR] Texture wrapping for R. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.\n   * @property {number} [minLod] TEXTURE_MIN_LOD setting\n   * @property {number} [maxLod] TEXTURE_MAX_LOD setting\n   * @property {number} [baseLevel] TEXTURE_BASE_LEVEL setting\n   * @property {number} [maxLevel] TEXTURE_MAX_LEVEL setting\n   * @property {number} [unpackAlignment] The `gl.UNPACK_ALIGNMENT` used when uploading an array. Defaults to 1.\n   * @property {number} [premultiplyAlpha] Whether or not to premultiply alpha. Defaults to whatever the current setting is.\n   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n   *     the current setting for specific textures.\n   * @property {number} [flipY] Whether or not to flip the texture vertically on upload. Defaults to whatever the current setting is.\n   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n   *     the current setting for specific textures.\n   * @property {number} [colorspaceConversion] Whether or not to let the browser do colorspace conversion of the texture on upload. Defaults to whatever the current setting is.\n   *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override\n   *     the current setting for specific textures.\n   * @property {(number[]|ArrayBuffer)} color color used as temporary 1x1 pixel color for textures loaded async when src is a string.\n   *    If it's a JavaScript array assumes color is 0 to 1 like most GL colors as in `[1, 0, 0, 1] = red=1, green=0, blue=0, alpha=0`.\n   *    Defaults to `[0.5, 0.75, 1, 1]`. See {@link module:twgl.setDefaultTextureColor}. If `false` texture is set. Can be used to re-load a texture\n   * @property {boolean} [auto] If not `false` then texture working filtering is set automatically for non-power of 2 images and\n   *    mips are generated for power of 2 images.\n   * @property {number[]} [cubeFaceOrder] The order that cube faces are pulled out of an img or set of images. The default is\n   *\n   *     [gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n   *      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n   *      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n   *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]\n   *\n   * @property {(number[]|ArrayBuffer|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement|string|string[]|module:twgl.TextureFunc)} [src] source for texture\n   *\n   *    If `string` then it's assumed to be a URL to an image. The image will be downloaded async. A usable\n   *    1x1 pixel texture will be returned immediatley. The texture will be updated once the image has downloaded.\n   *    If `target` is `gl.TEXTURE_CUBE_MAP` will attempt to divide image into 6 square pieces. 1x6, 6x1, 3x2, 2x3.\n   *    The pieces will be uploaded in `cubeFaceOrder`\n   *\n   *    If `string[]` then it must have 6 entries, one for each face of a cube map. Target must be `gl.TEXTURE_CUBE_MAP`.\n   *\n   *    If `HTMLElement` then it wil be used immediately to create the contents of the texture. Examples `HTMLImageElement`,\n   *    `HTMLCanvasElement`, `HTMLVideoElement`.\n   *\n   *    If `number[]` or `ArrayBuffer` it's assumed to be data for a texture. If `width` or `height` is\n   *    not specified it is guessed as follows. First the number of elements is computed by `src.length / numComponets`\n   *    where `numComponents` is derived from `format`. If `target` is `gl.TEXTURE_CUBE_MAP` then `numElements` is divided\n   *    by 6. Then\n   *\n   *    *   If neither `width` nor `height` are specified and `sqrt(numElements)` is an integer then width and height\n   *        are set to `sqrt(numElements)`. Otherwise `width = numElements` and `height = 1`.\n   *\n   *    *   If only one of `width` or `height` is specified then the other equals `numElements / specifiedDimension`.\n   *\n   * If `number[]` will be converted to `type`.\n   *\n   * If `src` is a function it will be called with a `WebGLRenderingContext` and these options.\n   * Whatever it returns is subject to these rules. So it can return a string url, an `HTMLElement`\n   * an array etc...\n   *\n   * If `src` is undefined then an empty texture will be created of size `width` by `height`.\n   *\n   * @property {string} [crossOrigin] What to set the crossOrigin property of images when they are downloaded.\n   *    default: undefined. Also see {@link module:twgl.setDefaults}.\n   *\n   * @memberOf module:twgl\n   */\n\n  // NOTE: While querying GL is considered slow it's not remotely as slow\n  // as uploading a texture. On top of that you're unlikely to call this in\n  // a perf critical loop. Even if upload a texture every frame that's unlikely\n  // to be more than 1 or 2 textures a frame. In other words, the benefits of\n  // making the API easy to use outweigh any supposed perf benefits\n  var lastPackState = {};\n\n  /**\n   * Saves any packing state that will be set based on the options.\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   */\n  function savePackState(gl, options) {\n    if (options.colorspaceConversion !== undefined) {\n      lastPackState.colorspaceConversion = gl.getParameter(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL);\n      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, options.colorspaceConversion);\n    }\n    if (options.premultiplyAlpha !== undefined) {\n      lastPackState.premultiplyAlpha = gl.getParameter(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL);\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlpha);\n    }\n    if (options.flipY !== undefined) {\n      lastPackState.flipY = gl.getParameter(gl.UNPACK_FLIP_Y_WEBGL);\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, options.flipY);\n    }\n  }\n\n  /**\n   * Restores any packing state that was set based on the options.\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   */\n  function restorePackState(gl, options) {\n    if (options.colorspaceConversion !== undefined) {\n      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, lastPackState.colorspaceConversion);\n    }\n    if (options.premultiplyAlpha !== undefined) {\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, lastPackState.premultiplyAlpha);\n    }\n    if (options.flipY !== undefined) {\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, lastPackState.flipY);\n    }\n  }\n\n  /**\n   * Sets the texture parameters of a texture.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   *   This is often the same options you passed in when you created the texture.\n   * @memberOf module:twgl/textures\n   */\n  function setTextureParameters(gl, tex, options) {\n    var target = options.target || gl.TEXTURE_2D;\n    gl.bindTexture(target, tex);\n    if (options.min) {\n      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, options.min);\n    }\n    if (options.mag) {\n      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, options.mag);\n    }\n    if (options.wrap) {\n      gl.texParameteri(target, gl.TEXTURE_WRAP_S, options.wrap);\n      gl.texParameteri(target, gl.TEXTURE_WRAP_T, options.wrap);\n      if (target === gl.TEXTURE_3D) {\n        gl.texParameteri(target, gl.TEXTURE_WRAP_R, options.wrap);\n      }\n    }\n    if (options.wrapR) {\n      gl.texParameteri(target, gl.TEXTURE_WRAP_R, options.wrapR);\n    }\n    if (options.wrapS) {\n      gl.texParameteri(target, gl.TEXTURE_WRAP_S, options.wrapS);\n    }\n    if (options.wrapT) {\n      gl.texParameteri(target, gl.TEXTURE_WRAP_T, options.wrapT);\n    }\n    if (options.minLod) {\n      gl.texParameteri(target, gl.TEXTURE_MIN_LOD, options.minLod);\n    }\n    if (options.maxLod) {\n      gl.texParameteri(target, gl.TEXTURE_MAX_LOD, options.maxLod);\n    }\n    if (options.baseLevel) {\n      gl.texParameteri(target, gl.TEXTURE_BASE_LEVEL, options.baseLevel);\n    }\n    if (options.maxLevel) {\n      gl.texParameteri(target, gl.TEXTURE_MAX_LEVEL, options.maxLevel);\n    }\n  }\n\n  /**\n   * Makes a 1x1 pixel\n   * If no color is passed in uses the default color which can be set by calling `setDefaultTextureColor`.\n   * @param {(number[]|ArrayBuffer)} [color] The color using 0-1 values\n   * @return {Uint8Array} Unit8Array with color.\n   */\n  function make1Pixel(color) {\n    color = color || defaults.textureColor;\n    if (isArrayBuffer(color)) {\n      return color;\n    }\n    return new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);\n  }\n\n  /**\n   * Returns true if value is power of 2\n   * @param {number} value number to check.\n   * @return true if value is power of 2\n   */\n  function isPowerOf2(value) {\n    return (value & (value - 1)) === 0;\n  }\n\n  /**\n   * Sets filtering or generates mips for texture based on width or height\n   * If width or height is not passed in uses `options.width` and//or `options.height`\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n   *   This is often the same options you passed in when you created the texture.\n   * @param {number} [width] width of texture\n   * @param {number} [height] height of texture\n   * @memberOf module:twgl/textures\n   */\n  function setTextureFilteringForSize(gl, tex, options, width, height) {\n    options = options || defaults.textureOptions;\n    var target = options.target || gl.TEXTURE_2D;\n    width = width || options.width;\n    height = height || options.height;\n    gl.bindTexture(target, tex);\n    if (!isPowerOf2(width) || !isPowerOf2(height)) {\n      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    } else {\n      gl.generateMipmap(target);\n    }\n  }\n\n  /**\n   * Gets an array of cubemap face enums\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   *   This is often the same options you passed in when you created the texture.\n   * @return {number[]} cubemap face enums\n   */\n  function getCubeFaceOrder(gl, options) {\n    options = options || {};\n    return options.cubeFaceOrder || [\n        gl.TEXTURE_CUBE_MAP_POSITIVE_X,\n        gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\n        gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\n        gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\n        gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n        gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\n      ];\n  }\n\n  /**\n   * @typedef {Object} FaceInfo\n   * @property {number} face gl enum for texImage2D\n   * @property {number} ndx face index (0 - 5) into source data\n   * @ignore\n   */\n\n  /**\n   * Gets an array of FaceInfos\n   * There's a bug in some NVidia drivers that will crash the driver if\n   * `gl.TEXTURE_CUBE_MAP_POSITIVE_X` is not uploaded first. So, we take\n   * the user's desired order from his faces to WebGL and make sure we\n   * do the faces in WebGL order\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   * @return {FaceInfo[]} cubemap face infos. Arguably the `face` property of each element is redundent but\n   *    it's needed internally to sort the array of `ndx` properties by `face`.\n   */\n  function getCubeFacesWithNdx(gl, options) {\n    var faces = getCubeFaceOrder(gl, options);\n    // work around bug in NVidia drivers. We have to upload the first face first else the driver crashes :(\n    var facesWithNdx = faces.map(function(face, ndx) {\n      return { face: face, ndx: ndx };\n    });\n    facesWithNdx.sort(function(a, b) {\n      return a.face - b.face;\n    });\n    return facesWithNdx;\n  }\n\n  /**\n   * Set a texture from the contents of an element. Will also set\n   * texture filtering or generate mips based on the dimensions of the element\n   * unless `options.auto === false`. If `target === gl.TEXTURE_CUBE_MAP` will\n   * attempt to slice image into 1x6, 2x3, 3x2, or 6x1 images, one for each face.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {HTMLElement} element a canvas, img, or video element.\n   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n   *   This is often the same options you passed in when you created the texture.\n   * @memberOf module:twgl/textures\n   * @kind function\n   */\n  var setTextureFromElement = function() {\n    var ctx = document.createElement(\"canvas\").getContext(\"2d\");\n    return function setTextureFromElement(gl, tex, element, options) {\n      options = options || defaults.textureOptions;\n      var target = options.target || gl.TEXTURE_2D;\n      var width = element.width;\n      var height = element.height;\n      var format = options.format || gl.RGBA;\n      var internalFormat = options.internalFormat || format;\n      var type = options.type || gl.UNSIGNED_BYTE;\n      savePackState(gl, options);\n      gl.bindTexture(target, tex);\n      if (target === gl.TEXTURE_CUBE_MAP) {\n        // guess the parts\n        var imgWidth  = element.width;\n        var imgHeight = element.height;\n        var size;\n        var slices;\n        if (imgWidth / 6 === imgHeight) {\n          // It's 6x1\n          size = imgHeight;\n          slices = [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0];\n        } else if (imgHeight / 6 === imgWidth) {\n          // It's 1x6\n          size = imgWidth;\n          slices = [0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5];\n        } else if (imgWidth / 3 === imgHeight / 2) {\n          // It's 3x2\n          size = imgWidth / 3;\n          slices = [0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1];\n        } else if (imgWidth / 2 === imgHeight / 3) {\n          // It's 2x3\n          size = imgWidth / 2;\n          slices = [0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2];\n        } else {\n          throw \"can't figure out cube map from element: \" + (element.src ? element.src : element.nodeName);\n        }\n        ctx.canvas.width = size;\n        ctx.canvas.height = size;\n        width = size;\n        height = size;\n        getCubeFacesWithNdx(gl, options).forEach(function(f) {\n          var xOffset = slices[f.ndx * 2 + 0] * size;\n          var yOffset = slices[f.ndx * 2 + 1] * size;\n          ctx.drawImage(element, xOffset, yOffset, size, size, 0, 0, size, size);\n          gl.texImage2D(f.face, 0, internalFormat, format, type, ctx.canvas);\n        });\n        // Free up the canvas memory\n        ctx.canvas.width = 1;\n        ctx.canvas.height = 1;\n      } else if (target === gl.TEXTURE_3D) {\n        var smallest = Math.min(element.width, element.height);\n        var largest = Math.max(element.width, element.height);\n        var depth = largest / smallest;\n        if (depth % 1 !== 0) {\n          throw \"can not compute 3D dimensions of element\";\n        }\n        var xMult = element.width  === largest ? 1 : 0;\n        var yMult = element.height === largest ? 1 : 0;\n        gl.texImage3D(target, 0, internalFormat, smallest, smallest, smallest, 0, format, type, null);\n        // remove this is texSubImage3D gets width and height arguments\n        ctx.canvas.width = smallest;\n        ctx.canvas.height = smallest;\n        for (var d = 0; d < depth; ++d) {\n//          gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, d * smallest);\n//          gl.texSubImage3D(target, 0, 0, 0, d, format, type, element);\n            var srcX = d * smallest * xMult;\n            var srcY = d * smallest * yMult;\n            var srcW = smallest;\n            var srcH = smallest;\n            var dstX = 0;\n            var dstY = 0;\n            var dstW = smallest;\n            var dstH = smallest;\n            ctx.drawImage(element, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);\n            gl.texSubImage3D(target, 0, 0, 0, d, format, type, ctx.canvas);\n        }\n        ctx.canvas.width = 0;\n        ctx.canvas.height = 0;\n// FIX (save state)\n//        gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, 0);\n      } else {\n        gl.texImage2D(target, 0, internalFormat, format, type, element);\n      }\n      restorePackState(gl, options);\n      if (options.auto !== false) {\n        setTextureFilteringForSize(gl, tex, options, width, height);\n      }\n      setTextureParameters(gl, tex, options);\n    };\n  }();\n\n  function noop() {\n  }\n\n  /**\n   * Loads an image\n   * @param {string} url url to image\n   * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null\n   *     if there was an error\n   * @return {HTMLImageElement} the image being loaded.\n   */\n  function loadImage(url, crossOrigin, callback) {\n    callback = callback || noop;\n    var img = new Image();\n    crossOrigin = crossOrigin !== undefined ? crossOrigin : defaults.crossOrigin;\n    if (crossOrigin !== undefined) {\n      img.crossOrigin = crossOrigin;\n    }\n\n    function clearEventHandlers() {\n      img.removeEventListener('error', onError);  // eslint-disable-line\n      img.removeEventListener('load', onLoad);  // eslint-disable-line\n      img = null;\n    }\n\n    function onError() {\n      var msg = \"couldn't load image: \" + url;\n      utils.error(msg);\n      callback(msg, img);\n      clearEventHandlers();\n    }\n\n    function onLoad() {\n      callback(null, img);\n      clearEventHandlers();\n    }\n\n    img.addEventListener('error', onError);\n    img.addEventListener('load', onLoad);\n    img.src = url;\n    return img;\n  }\n\n  /**\n   * Sets a texture to a 1x1 pixel color. If `options.color === false` is nothing happens. If it's not set\n   * the default texture color is used which can be set by calling `setDefaultTextureColor`.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n   *   This is often the same options you passed in when you created the texture.\n   * @memberOf module:twgl/textures\n   */\n  function setTextureTo1PixelColor(gl, tex, options) {\n    options = options || defaults.textureOptions;\n    var target = options.target || gl.TEXTURE_2D;\n    gl.bindTexture(target, tex);\n    if (options.color === false) {\n      return;\n    }\n    // Assume it's a URL\n    // Put 1x1 pixels in texture. That makes it renderable immediately regardless of filtering.\n    var color = make1Pixel(options.color);\n    if (target === gl.TEXTURE_CUBE_MAP) {\n      for (var ii = 0; ii < 6; ++ii) {\n        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n      }\n    } else if (target === gl.TEXTURE_3D) {\n      gl.texImage3D(target, 0, gl.RGBA, 1, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n    } else {\n      gl.texImage2D(target, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, color);\n    }\n  }\n\n  /**\n   * The src image(s) used to create a texture.\n   *\n   * When you call {@link module:twgl.createTexture} or {@link module:twgl.createTextures}\n   * you can pass in urls for images to load into the textures. If it's a single url\n   * then this will be a single HTMLImageElement. If it's an array of urls used for a cubemap\n   * this will be a corresponding array of images for the cubemap.\n   *\n   * @typedef {HTMLImageElement|HTMLImageElement[]} TextureSrc\n   * @memberOf module:twgl\n   */\n\n  /**\n   * A callback for when an image finished downloading and been uploaded into a texture\n   * @callback TextureReadyCallback\n   * @param {*} err If truthy there was an error.\n   * @param {WebGLTexture} texture the texture.\n   * @param {module:twgl.TextureSrc} souce image(s) used to as the src for the texture\n   * @memberOf module:twgl\n   */\n\n  /**\n   * A callback for when all images have finished downloading and been uploaded into their respective textures\n   * @callback TexturesReadyCallback\n   * @param {*} err If truthy there was an error.\n   * @param {Object.<string, WebGLTexture>} textures the created textures by name. Same as returned by {@link module:twgl.createTextures}.\n   * @param {Object.<string, module:twgl.TextureSrc>} sources the image(s) used for the texture by name.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * A callback for when an image finished downloading and been uploaded into a texture\n   * @callback CubemapReadyCallback\n   * @param {*} err If truthy there was an error.\n   * @param {WebGLTexture} tex the texture.\n   * @param {HTMLImageElement[]} imgs the images for each face.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Loads a texture from an image from a Url as specified in `options.src`\n   * If `options.color !== false` will set the texture to a 1x1 pixel color so that the texture is\n   * immediately useable. It will be updated with the contents of the image once the image has finished\n   * downloading. Filtering options will be set as approriate for image unless `options.auto === false`.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n   * @param {module:twgl.TextureReadyCallback} [callback] A function to be called when the image has finished loading. err will\n   *    be non null if there was an error.\n   * @return {HTMLImageElement} the image being downloaded.\n   * @memberOf module:twgl/textures\n   */\n  function loadTextureFromUrl(gl, tex, options, callback) {\n    callback = callback || noop;\n    options = options || defaults.textureOptions;\n    setTextureTo1PixelColor(gl, tex, options);\n    // Because it's async we need to copy the options.\n    options = utils.shallowCopy(options);\n    var img = loadImage(options.src, options.crossOrigin, function(err, img) {\n      if (err) {\n        callback(err, tex, img);\n      } else {\n        setTextureFromElement(gl, tex, img, options);\n        callback(null, tex, img);\n      }\n    });\n    return img;\n  }\n\n  /**\n   * Loads a cubemap from 6 urls as specified in `options.src`. Will set the cubemap to a 1x1 pixel color\n   * so that it is usable immediately unless `option.color === false`.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   * @param {module:twgl.CubemapReadyCallback} [callback] A function to be called when all the images have finished loading. err will\n   *    be non null if there was an error.\n   * @memberOf module:twgl/textures\n   */\n  function loadCubemapFromUrls(gl, tex, options, callback) {\n    callback = callback || noop;\n    var urls = options.src;\n    if (urls.length !== 6) {\n      throw \"there must be 6 urls for a cubemap\";\n    }\n    var format = options.format || gl.RGBA;\n    var type = options.type || gl.UNSIGNED_BYTE;\n    var target = options.target || gl.TEXTURE_2D;\n    if (target !== gl.TEXTURE_CUBE_MAP) {\n      throw \"target must be TEXTURE_CUBE_MAP\";\n    }\n    setTextureTo1PixelColor(gl, tex, options);\n    // Because it's async we need to copy the options.\n    options = utils.shallowCopy(options);\n    var numToLoad = 6;\n    var errors = [];\n    var imgs;\n    var faces = getCubeFaceOrder(gl, options);\n\n    function uploadImg(faceTarget) {\n      return function(err, img) {\n        --numToLoad;\n        if (err) {\n          errors.push(err);\n        } else {\n          if (img.width !== img.height) {\n            errors.push(\"cubemap face img is not a square: \" + img.src);\n          } else {\n            savePackState(gl, options);\n            gl.bindTexture(target, tex);\n\n            // So assuming this is the first image we now have one face that's img sized\n            // and 5 faces that are 1x1 pixel so size the other faces\n            if (numToLoad === 5) {\n              // use the default order\n              getCubeFaceOrder(gl).forEach(function(otherTarget) {\n                // Should we re-use the same face or a color?\n                gl.texImage2D(otherTarget, 0, format, format, type, img);\n              });\n            } else {\n              gl.texImage2D(faceTarget, 0, format, format, type, img);\n            }\n\n            restorePackState(gl, options);\n            gl.generateMipmap(target);\n          }\n        }\n\n        if (numToLoad === 0) {\n          callback(errors.length ? errors : undefined, imgs, tex);\n        }\n      };\n    }\n\n    imgs = urls.map(function(url, ndx) {\n      return loadImage(url, options.crossOrigin, uploadImg(faces[ndx]));\n    });\n  }\n\n  /**\n   * Gets the number of compontents for a given image format.\n   * @param {number} format the format.\n   * @return {number} the number of components for the format.\n   * @memberOf module:twgl/textures\n   */\n  function getNumComponentsForFormat(format) {\n    switch (format) {\n      case ALPHA:\n      case LUMINANCE:\n        return 1;\n      case LUMINANCE_ALPHA:\n        return 2;\n      case RGB:\n        return 3;\n      case RGBA:\n        return 4;\n      default:\n        throw \"unknown type: \" + format;\n    }\n  }\n\n  /**\n   * Gets the texture type for a given array type.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @return {number} the gl texture type\n   */\n  function getTextureTypeForArrayType(gl, src) {\n    if (isArrayBuffer(src)) {\n      return typedArrays.getGLTypeForTypedArray(src);\n    }\n    return gl.UNSIGNED_BYTE;\n  }\n\n  function guessDimensions(gl, target, width, height, numElements) {\n    if (numElements % 1 !== 0) {\n      throw \"can't guess dimensions\";\n    }\n    if (!width && !height) {\n      var size = Math.sqrt(numElements / (target === gl.TEXTURE_CUBE_MAP ? 6 : 1));\n      if (size % 1 === 0) {\n        width = size;\n        height = size;\n      } else {\n        width = numElements;\n        height = 1;\n      }\n    } else if (!height) {\n      height = numElements / width;\n      if (height % 1) {\n        throw \"can't guess dimensions\";\n      }\n    } else if (!width) {\n      width = numElements / height;\n      if (width % 1) {\n        throw \"can't guess dimensions\";\n      }\n    }\n    return {\n      width: width,\n      height: height,\n    };\n  }\n\n  /**\n   * Sets a texture from an array or typed array. If the width or height is not provided will attempt to\n   * guess the size. See {@link module:twgl.TextureOptions}.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {(number[]|ArrayBuffer)} src An array or typed arry with texture data.\n   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n   *   This is often the same options you passed in when you created the texture.\n   * @memberOf module:twgl/textures\n   */\n  function setTextureFromArray(gl, tex, src, options) {\n    options = options || defaults.textureOptions;\n    var target = options.target || gl.TEXTURE_2D;\n    gl.bindTexture(target, tex);\n    var width = options.width;\n    var height = options.height;\n    var depth = options.depth;\n    var format = options.format || gl.RGBA;\n    var internalFormat = options.internalFormat || format;\n    var type = options.type || getTextureTypeForArrayType(gl, src);\n    var numComponents = getNumComponentsForFormat(format);\n    var numElements = src.length / numComponents;\n    if (numElements % 1) {\n      throw \"length wrong size for format: \" + glEnumToString(gl, format);\n    }\n    var dimensions;\n    if (target === gl.TEXTURE_3D) {\n      if (!width && !height && !depth) {\n        var size = Math.cbrt(numElements);\n        if (size % 1 !== 0) {\n          throw \"can't guess cube size of array of numElements: \" + numElements;\n        }\n        width = size;\n        height = size;\n        depth = size;\n      } else if (width && (!height || !depth)) {\n        dimensions = guessDimensions(gl, target, height, depth, numElements / width);\n        height = dimensions.width;\n        depth = dimensions.height;\n      } else if (height && (!width || !depth)) {\n        dimensions = guessDimensions(gl, target, width, depth, numElements / height);\n        width = dimensions.width;\n        depth = dimensions.height;\n      } else {\n        dimensions = guessDimensions(gl, target, width, height, numElements / depth);\n        width = dimensions.width;\n        height = dimensions.height;\n      }\n    } else {\n      dimensions = guessDimensions(gl, target, width, height, numElements);\n      width = dimensions.width;\n      height = dimensions.height;\n    }\n    if (!isArrayBuffer(src)) {\n      var Type = typedArrays.getTypedArrayTypeForGLType(type);\n      src = new Type(src);\n    } else {\n      if (src instanceof Uint8ClampedArray) {\n        src = new Uint8Array(src.buffer);\n      }\n    }\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, options.unpackAlignment || 1);\n    savePackState(gl, options);\n    if (target === gl.TEXTURE_CUBE_MAP) {\n      var faceSize = numElements / 6 * numComponents;\n      getCubeFacesWithNdx(gl, options).forEach(function(f) {\n        var offset = faceSize * f.ndx;\n        var data = src.subarray(offset, offset + faceSize);\n        gl.texImage2D(f.face, 0, internalFormat, width, height, 0, format, type, data);\n      });\n    } else if (target === gl.TEXTURE_3D) {\n      gl.texImage3D(target, 0, internalFormat, width, height, depth, 0, format, type, src);\n    } else {\n      gl.texImage2D(target, 0, internalFormat, width, height, 0, format, type, src);\n    }\n    restorePackState(gl, options);\n    return {\n      width: width,\n      height: height,\n      depth: depth,\n    };\n  }\n\n  /**\n   * Sets a texture with no contents of a certain size. In other words calls `gl.texImage2D` with `null`.\n   * You must set `options.width` and `options.height`.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the WebGLTexture to set parameters for\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   * @memberOf module:twgl/textures\n   */\n  function setEmptyTexture(gl, tex, options) {\n    var target = options.target || gl.TEXTURE_2D;\n    gl.bindTexture(target, tex);\n    var format = options.format || gl.RGBA;\n    var internalFormat = options.internalFormat || format;\n    var type = options.type || gl.UNSIGNED_BYTE;\n    savePackState(gl, options);\n    if (target === gl.TEXTURE_CUBE_MAP) {\n      for (var ii = 0; ii < 6; ++ii) {\n        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, internalFormat, options.width, options.height, 0, format, type, null);\n      }\n    } else if (target === gl.TEXTURE_3D) {\n      gl.texImage3D(target, 0, internalFormat, options.width, options.height, options.depth, 0, format, type, null);\n    } else {\n      gl.texImage2D(target, 0, internalFormat, options.width, options.height, 0, format, type, null);\n    }\n    restorePackState(gl, options);\n  }\n\n  /**\n   * Creates a texture based on the options passed in.\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.\n   * @param {module:twgl.TextureReadyCallback} [callback] A callback called when an image has been downloaded and uploaded to the texture.\n   * @return {WebGLTexture} the created texture.\n   * @memberOf module:twgl/textures\n   */\n  function createTexture(gl, options, callback) {\n    callback = callback || noop;\n    options = options || defaults.textureOptions;\n    var tex = gl.createTexture();\n    var target = options.target || gl.TEXTURE_2D;\n    var width  = options.width  || 1;\n    var height = options.height || 1;\n    gl.bindTexture(target, tex);\n    if (target === gl.TEXTURE_CUBE_MAP) {\n      // this should have been the default for CUBEMAPS :(\n      gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    }\n    var src = options.src;\n    if (src) {\n      if (typeof src === \"function\") {\n        src = src(gl, options);\n      }\n      if (typeof (src) === \"string\") {\n        loadTextureFromUrl(gl, tex, options, callback);\n      } else if (isArrayBuffer(src) ||\n                 (Array.isArray(src) && (\n                      typeof src[0] === 'number' ||\n                      Array.isArray(src[0]) ||\n                      isArrayBuffer(src[0]))\n                 )\n                ) {\n        var dimensions = setTextureFromArray(gl, tex, src, options);\n        width  = dimensions.width;\n        height = dimensions.height;\n      } else if (Array.isArray(src) && typeof (src[0]) === 'string') {\n        loadCubemapFromUrls(gl, tex, options, callback);\n      } else if (src instanceof HTMLElement) {\n        setTextureFromElement(gl, tex, src, options);\n        width  = src.width;\n        height = src.height;\n      } else {\n        throw \"unsupported src type\";\n      }\n    } else {\n      setEmptyTexture(gl, tex, options);\n    }\n    if (options.auto !== false) {\n      setTextureFilteringForSize(gl, tex, options, width, height);\n    }\n    setTextureParameters(gl, tex, options);\n    return tex;\n  }\n\n  /**\n   * Resizes a texture based on the options passed in.\n   *\n   * Note: This is not a generic resize anything function.\n   * It's mostly used by {@link module:twgl.resizeFramebufferInfo}\n   * It will use `options.src` if it exists to try to determine a `type`\n   * otherwise it will assume `gl.UNSIGNED_BYTE`. No data is provided\n   * for the texture. Texture parameters will be set accordingly\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {WebGLTexture} tex the texture to resize\n   * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.\n   * @param {number} [width] the new width. If not passed in will use `options.width`\n   * @param {number} [height] the new height. If not passed in will use `options.height`\n   * @memberOf module:twgl/textures\n   */\n  function resizeTexture(gl, tex, options, width, height) {\n    width = width || options.width;\n    height = height || options.height;\n    var target = options.target || gl.TEXTURE_2D;\n    gl.bindTexture(target, tex);\n    var format = options.format || gl.RGBA;\n    var type;\n    var src = options.src;\n    if (!src) {\n      type = options.type || gl.UNSIGNED_BYTE;\n    } else if (isArrayBuffer(src) || (Array.isArray(src) && typeof (src[0]) === 'number')) {\n      type = options.type || getTextureTypeForArrayType(gl, src);\n    } else {\n      type = options.type || gl.UNSIGNED_BYTE;\n    }\n    if (target === gl.TEXTURE_CUBE_MAP) {\n      for (var ii = 0; ii < 6; ++ii) {\n        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, format, width, height, 0, format, type, null);\n      }\n    } else {\n      gl.texImage2D(target, 0, format, width, height, 0, format, type, null);\n    }\n  }\n\n  /**\n   * Check if a src is an async request.\n   * if src is a string we're going to download an image\n   * if src is an array of strings we're going to download cubemap images\n   * @param {*} src The src from a TextureOptions\n   * @returns {bool} true if src is async.\n   */\n  function isAsyncSrc(src) {\n    return typeof src === 'string' ||\n           (Array.isArray(src) && typeof src[0] === 'string');\n  }\n\n  /**\n   * Creates a bunch of textures based on the passed in options.\n   *\n   * Example:\n   *\n   *     var textures = twgl.createTextures(gl, {\n   *       // a power of 2 image\n   *       hftIcon: { src: \"images/hft-icon-16.png\", mag: gl.NEAREST },\n   *       // a non-power of 2 image\n   *       clover: { src: \"images/clover.jpg\" },\n   *       // From a canvas\n   *       fromCanvas: { src: ctx.canvas },\n   *       // A cubemap from 6 images\n   *       yokohama: {\n   *         target: gl.TEXTURE_CUBE_MAP,\n   *         src: [\n   *           'images/yokohama/posx.jpg',\n   *           'images/yokohama/negx.jpg',\n   *           'images/yokohama/posy.jpg',\n   *           'images/yokohama/negy.jpg',\n   *           'images/yokohama/posz.jpg',\n   *           'images/yokohama/negz.jpg',\n   *         ],\n   *       },\n   *       // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)\n   *       goldengate: {\n   *         target: gl.TEXTURE_CUBE_MAP,\n   *         src: 'images/goldengate.jpg',\n   *       },\n   *       // A 2x2 pixel texture from a JavaScript array\n   *       checker: {\n   *         mag: gl.NEAREST,\n   *         min: gl.LINEAR,\n   *         src: [\n   *           255,255,255,255,\n   *           192,192,192,255,\n   *           192,192,192,255,\n   *           255,255,255,255,\n   *         ],\n   *       },\n   *       // a 1x2 pixel texture from a typed array.\n   *       stripe: {\n   *         mag: gl.NEAREST,\n   *         min: gl.LINEAR,\n   *         format: gl.LUMINANCE,\n   *         src: new Uint8Array([\n   *           255,\n   *           128,\n   *           255,\n   *           128,\n   *           255,\n   *           128,\n   *           255,\n   *           128,\n   *         ]),\n   *         width: 1,\n   *       },\n   *     });\n   *\n   * Now\n   *\n   * *   `textures.hftIcon` will be a 2d texture\n   * *   `textures.clover` will be a 2d texture\n   * *   `textures.fromCanvas` will be a 2d texture\n   * *   `textures.yohohama` will be a cubemap texture\n   * *   `textures.goldengate` will be a cubemap texture\n   * *   `textures.checker` will be a 2d texture\n   * *   `textures.stripe` will be a 2d texture\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per texture.\n   * @param {module:twgl.TexturesReadyCallback} [callback] A callback called when all textures have been downloaded.\n   * @return {Object.<string,WebGLTexture>} the created textures by name\n   * @memberOf module:twgl/textures\n   */\n  function createTextures(gl, textureOptions, callback) {\n    callback = callback || noop;\n    var numDownloading = 0;\n    var errors = [];\n    var textures = {};\n    var images = {};\n\n    function callCallbackIfReady() {\n      if (numDownloading === 0) {\n        setTimeout(function() {\n          callback(errors.length ? errors : undefined, textures, images);\n        }, 0);\n      }\n    }\n\n    Object.keys(textureOptions).forEach(function(name) {\n      var options = textureOptions[name];\n      var onLoadFn;\n      if (isAsyncSrc(options.src)) {\n        onLoadFn = function(err, tex, img) {\n          images[name] = img;\n          --numDownloading;\n          if (err) {\n            errors.push(err);\n          }\n          callCallbackIfReady();\n        };\n        ++numDownloading;\n      }\n      textures[name] = createTexture(gl, options, onLoadFn);\n    });\n\n    // queue the callback if there are no images to download.\n    // We do this because if your code is structured to wait for\n    // images to download but then you comment out all the async\n    // images your code would break.\n    callCallbackIfReady();\n\n    return textures;\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  // No speed diff AFAICT.\n  return {\n    \"setDefaults_\": setDefaults,\n\n    \"createTexture\": createTexture,\n    \"setEmptyTexture\": setEmptyTexture,\n    \"setTextureFromArray\": setTextureFromArray,\n    \"loadTextureFromUrl\": loadTextureFromUrl,\n    \"setTextureFromElement\": setTextureFromElement,\n    \"setTextureFilteringForSize\": setTextureFilteringForSize,\n    \"setTextureParameters\": setTextureParameters,\n    \"setDefaultTextureColor\": setDefaultTextureColor,\n    \"createTextures\": createTextures,\n    \"resizeTexture\": resizeTexture,\n    \"getNumComponentsForFormat\": getNumComponentsForFormat,\n  };\n});\n\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/framebuffers',[\n    './textures',\n    './utils',\n  ], function(\n    textures,\n    utils) {\n\n\n  /**\n   * Framebuffer related functions\n   *\n   * For backward compatibily they are available at both `twgl.framebuffer` and `twgl`\n   * itself\n   *\n   * See {@link module:twgl} for core functions\n   *\n   * @module twgl/framebuffers\n   */\n\n  // make sure we don't see a global gl\n  var gl = undefined;  // eslint-disable-line\n\n  var UNSIGNED_BYTE                  = 0x1401;\n\n  /* PixelFormat */\n  var DEPTH_COMPONENT                = 0x1902;\n  var RGBA                           = 0x1908;\n\n  /* Framebuffer Object. */\n  var RGBA4                          = 0x8056;\n  var RGB5_A1                        = 0x8057;\n  var RGB565                         = 0x8D62;\n  var DEPTH_COMPONENT16              = 0x81A5;\n  var STENCIL_INDEX                  = 0x1901;\n  var STENCIL_INDEX8                 = 0x8D48;\n  var DEPTH_STENCIL                  = 0x84F9;\n  var COLOR_ATTACHMENT0              = 0x8CE0;\n  var DEPTH_ATTACHMENT               = 0x8D00;\n  var STENCIL_ATTACHMENT             = 0x8D20;\n  var DEPTH_STENCIL_ATTACHMENT       = 0x821A;\n\n  /* TextureWrapMode */\n  var REPEAT                         = 0x2901;  // eslint-disable-line\n  var CLAMP_TO_EDGE                  = 0x812F;\n  var MIRRORED_REPEAT                = 0x8370;  // eslint-disable-line\n\n  /* TextureMagFilter */\n  var NEAREST                        = 0x2600;  // eslint-disable-line\n  var LINEAR                         = 0x2601;\n\n  /* TextureMinFilter */\n  var NEAREST_MIPMAP_NEAREST         = 0x2700;  // eslint-disable-line\n  var LINEAR_MIPMAP_NEAREST          = 0x2701;  // eslint-disable-line\n  var NEAREST_MIPMAP_LINEAR          = 0x2702;  // eslint-disable-line\n  var LINEAR_MIPMAP_LINEAR           = 0x2703;  // eslint-disable-line\n\n  /**\n   * The options for a framebuffer attachment.\n   *\n   * Note: For a `format` that is a texture include all the texture\n   * options from {@link module:twgl.TextureOptions} for example\n   * `min`, `mag`, `clamp`, etc... Note that unlike {@link module:twgl.TextureOptions}\n   * `auto` defaults to `false` for attachment textures but `min` and `mag` default\n   * to `gl.LINEAR` and `wrap` defaults to `CLAMP_TO_EDGE`\n   *\n   * @typedef {Object} AttachmentOptions\n   * @property {number} [attach] The attachment point. Defaults\n   *   to `gl.COLOR_ATTACTMENT0 + ndx` unless type is a depth or stencil type\n   *   then it's gl.DEPTH_ATTACHMENT or `gl.DEPTH_STENCIL_ATTACHMENT` depending\n   *   on the format or attachment type.\n   * @property {number} [format] The format. If one of `gl.RGBA4`,\n   *   `gl.RGB565`, `gl.RGB5_A1`, `gl.DEPTH_COMPONENT16`,\n   *   `gl.STENCIL_INDEX8` or `gl.DEPTH_STENCIL` then will create a\n   *   renderbuffer. Otherwise will create a texture. Default = `gl.RGBA`\n   * @property {number} [type] The type. Used for texture. Default = `gl.UNSIGNED_BYTE`.\n   * @property {number} [target] The texture target for `gl.framebufferTexture2D`.\n   *   Defaults to `gl.TEXTURE_2D`. Set to appropriate face for cube maps.\n   * @property {number} [level] level for `gl.framebufferTexture2D`. Defaults to 0.\n   * @property {WebGLObject} [attachment] An existing renderbuffer or texture.\n   *    If provided will attach this Object. This allows you to share\n   *    attachemnts across framebuffers.\n   * @memberOf module:twgl\n   */\n\n  var defaultAttachments = [\n    { format: RGBA, type: UNSIGNED_BYTE, min: LINEAR, wrap: CLAMP_TO_EDGE, },\n    { format: DEPTH_STENCIL, },\n  ];\n\n  var attachmentsByFormat = {};\n  attachmentsByFormat[DEPTH_STENCIL] = DEPTH_STENCIL_ATTACHMENT;\n  attachmentsByFormat[STENCIL_INDEX] = STENCIL_ATTACHMENT;\n  attachmentsByFormat[STENCIL_INDEX8] = STENCIL_ATTACHMENT;\n  attachmentsByFormat[DEPTH_COMPONENT] = DEPTH_ATTACHMENT;\n  attachmentsByFormat[DEPTH_COMPONENT16] = DEPTH_ATTACHMENT;\n\n  function getAttachmentPointForFormat(format) {\n    return attachmentsByFormat[format];\n  }\n\n  var renderbufferFormats = {};\n  renderbufferFormats[RGBA4] = true;\n  renderbufferFormats[RGB5_A1] = true;\n  renderbufferFormats[RGB565] = true;\n  renderbufferFormats[DEPTH_STENCIL] = true;\n  renderbufferFormats[DEPTH_COMPONENT16] = true;\n  renderbufferFormats[STENCIL_INDEX] = true;\n  renderbufferFormats[STENCIL_INDEX8] = true;\n\n  function isRenderbufferFormat(format) {\n    return renderbufferFormats[format];\n  }\n\n  /**\n   * @typedef {Object} FramebufferInfo\n   * @property {WebGLFramebuffer} framebuffer The WebGLFramebuffer for this framebufferInfo\n   * @property {WebGLObject[]} attachments The created attachments in the same order as passed in to {@link module:twgl.createFramebufferInfo}.\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Creates a framebuffer and attachments.\n   *\n   * This returns a {@link module:twgl.FramebufferInfo} because it needs to return the attachments as well as the framebuffer.\n   *\n   * The simplest usage\n   *\n   *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer\n   *     var fbi = twgl.createFramebuffer(gl);\n   *\n   * More complex usage\n   *\n   *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer\n   *     var attachments = [\n   *       { format: RGB565, mag: NEAREST },\n   *       { format: STENCIL_INDEX8 },\n   *     ]\n   *     var fbi = twgl.createFramebuffer(gl, attachments);\n   *\n   * Passing in a specific size\n   *\n   *     var width = 256;\n   *     var height = 256;\n   *     var fbi = twgl.createFramebuffer(gl, attachments, width, height);\n   *\n   * **Note!!** It is up to you to check if the framebuffer is renderable by calling `gl.checkFramebufferStatus`.\n   * [WebGL only guarantees 3 combinations of attachments work](https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.6).\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {module:twgl.AttachmentOptions[]} [attachments] which attachments to create. If not provided the default is a framebuffer with an\n   *    `RGBA`, `UNSIGNED_BYTE` texture `COLOR_ATTACHMENT0` and a `DEPTH_STENCIL` renderbuffer `DEPTH_STENCIL_ATTACHMENT`.\n   * @param {number} [width] the width for the attachments. Default = size of drawingBuffer\n   * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer\n   * @return {module:twgl.FramebufferInfo} the framebuffer and attachments.\n   * @memberOf module:twgl/framebuffers\n   */\n  function createFramebufferInfo(gl, attachments, width, height) {\n    var target = gl.FRAMEBUFFER;\n    var fb = gl.createFramebuffer();\n    gl.bindFramebuffer(target, fb);\n    width  = width  || gl.drawingBufferWidth;\n    height = height || gl.drawingBufferHeight;\n    attachments = attachments || defaultAttachments;\n    var colorAttachmentCount = 0;\n    var framebufferInfo = {\n      framebuffer: fb,\n      attachments: [],\n      width: width,\n      height: height,\n    };\n    attachments.forEach(function(attachmentOptions) {\n      var attachment = attachmentOptions.attachment;\n      var format = attachmentOptions.format;\n      var attachmentPoint = getAttachmentPointForFormat(format);\n      if (!attachmentPoint) {\n        attachmentPoint = COLOR_ATTACHMENT0 + colorAttachmentCount++;\n      }\n      if (!attachment) {\n        if (isRenderbufferFormat(format)) {\n          attachment = gl.createRenderbuffer();\n          gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);\n          gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);\n        } else {\n          var textureOptions = utils.shallowCopy(attachmentOptions);\n          textureOptions.width = width;\n          textureOptions.height = height;\n          if (textureOptions.auto === undefined) {\n            textureOptions.auto = false;\n            textureOptions.min = textureOptions.min || gl.LINEAR;\n            textureOptions.mag = textureOptions.mag || gl.LINEAR;\n            textureOptions.wrapS = textureOptions.wrapS || textureOptions.wrap || gl.CLAMP_TO_EDGE;\n            textureOptions.wrapT = textureOptions.wrapT || textureOptions.wrap || gl.CLAMP_TO_EDGE;\n          }\n          attachment = textures.createTexture(gl, textureOptions);\n        }\n      }\n      if (attachment instanceof WebGLRenderbuffer) {\n        gl.framebufferRenderbuffer(target, attachmentPoint, gl.RENDERBUFFER, attachment);\n      } else if (attachment instanceof WebGLTexture) {\n        gl.framebufferTexture2D(\n            target,\n            attachmentPoint,\n            attachmentOptions.texTarget || gl.TEXTURE_2D,\n            attachment,\n            attachmentOptions.level || 0);\n      } else {\n        throw \"unknown attachment type\";\n      }\n      framebufferInfo.attachments.push(attachment);\n    });\n    return framebufferInfo;\n  }\n\n  /**\n   * Resizes the attachments of a framebuffer.\n   *\n   * You need to pass in the same `attachments` as you passed in {@link module:twgl.createFramebuffer}\n   * because TWGL has no idea the format/type of each attachment.\n   *\n   * The simplest usage\n   *\n   *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer\n   *     var fbi = twgl.createFramebuffer(gl);\n   *\n   *     ...\n   *\n   *     function render() {\n   *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {\n   *         // resize the attachments\n   *         twgl.resizeFramebufferInfo(gl, fbi);\n   *       }\n   *\n   * More complex usage\n   *\n   *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer\n   *     var attachments = [\n   *       { format: RGB565, mag: NEAREST },\n   *       { format: STENCIL_INDEX8 },\n   *     ]\n   *     var fbi = twgl.createFramebuffer(gl, attachments);\n   *\n   *     ...\n   *\n   *     function render() {\n   *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {\n   *         // resize the attachments to match\n   *         twgl.resizeFramebufferInfo(gl, fbi, attachments);\n   *       }\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {module:twgl.FramebufferInfo} framebufferInfo a framebufferInfo as returned from {@link module:twgl.createFramebuffer}.\n   * @param {module:twgl.AttachmentOptions[]} [attachments] the same attachments options as passed to {@link module:twgl.createFramebuffer}.\n   * @param {number} [width] the width for the attachments. Default = size of drawingBuffer\n   * @param {number} [height] the height for the attachments. Defautt = size of drawingBuffer\n   * @memberOf module:twgl/framebuffers\n   */\n  function resizeFramebufferInfo(gl, framebufferInfo, attachments, width, height) {\n    width  = width  || gl.drawingBufferWidth;\n    height = height || gl.drawingBufferHeight;\n    framebufferInfo.width = width;\n    framebufferInfo.height = height;\n    attachments = attachments || defaultAttachments;\n    attachments.forEach(function(attachmentOptions, ndx) {\n      var attachment = framebufferInfo.attachments[ndx];\n      var format = attachmentOptions.format;\n      if (attachment instanceof WebGLRenderbuffer) {\n        gl.bindRenderbuffer(gl.RENDERBUFFER, attachment);\n        gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);\n      } else if (attachment instanceof WebGLTexture) {\n        textures.resizeTexture(gl, attachment, attachmentOptions, width, height);\n      } else {\n        throw \"unknown attachment type\";\n      }\n    });\n  }\n\n  /**\n   * Binds a framebuffer\n   *\n   * This function pretty much soley exists because I spent hours\n   * trying to figure out why something I wrote wasn't working only\n   * to realize I forget to set the viewport dimensions.\n   * My hope is this function will fix that.\n   *\n   * It is effectively the same as\n   *\n   *     gl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);\n   *     gl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);\n   *\n   * @param {WebGLRenderingContext} gl the WebGLRenderingContext\n   * @param {module:twgl.FramebufferInfo} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebuffer}.\n   *   If not passed will bind the canvas.\n   * @param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.\n   * @memberOf module:twgl/framebuffers\n   */\n\n  function bindFramebufferInfo(gl, framebufferInfo, target) {\n    target = target || gl.FRAMEBUFFER;\n    if (framebufferInfo) {\n      gl.bindFramebuffer(target, framebufferInfo.framebuffer);\n      gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);\n    } else {\n      gl.bindFramebuffer(target, null);\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    }\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  // No speed diff AFAICT.\n  return {\n    \"bindFramebufferInfo\": bindFramebufferInfo,\n    \"createFramebufferInfo\": createFramebufferInfo,\n    \"resizeFramebufferInfo\": resizeFramebufferInfo,\n  };\n});\n\n\n/*\n * Copyright 2015, Gregg Tavares.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Gregg Tavares. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\ndefine('twgl/twgl',[\n    './attributes',\n    './draw',\n    './framebuffers',\n    './programs',\n    './textures',\n    './typedarrays',\n    './utils',\n  ], function(\n    attributes,\n    draw,\n    framebuffers,\n    programs,\n    textures,\n    typedArrays,\n    utils) {\n\n\n  /**\n   * The main TWGL module.\n   *\n   * For most use cases you shouldn't need anything outside this module.\n   * Exceptions between the stuff added to twgl-full (v3, m4, primitives)\n   *\n   * @module twgl\n   * @borrows module:twgl/attributes.setAttribInfoBufferFromArray as setAttribInfoBufferFromArray\n   * @borrows module:twgl/attributes.createBufferInfoFromArrays as createBufferInfoFromArrays\n   * @borrows module:twgl/attributes.createVertexArrayInfo as createVertexArrayInfo\n   * @borrows module:twgl/draw.drawBufferInfo as drawBufferInfo\n   * @borrows module:twgl/draw.drawObjectList as drawObjectList\n   * @borrows module:twgl/framebuffers.createFramebufferInfo as createFramebufferInfo\n   * @borrows module:twgl/framebuffers.resizeFramebufferInfo as resizeFramebufferInfo\n   * @borrows module:twgl/framebuffers.bindFramebufferInfo as bindFramebufferInfo\n   * @borrows module:twgl/programs.createProgramInfo as createProgramInfo\n   * @borrows module:twgl/programs.createUniformBlockInfo as createUniformBlockInfo\n   * @borrows module:twgl/programs.bindUniformBlock as bindUniformBlock\n   * @borrows module:twgl/programs.setUniformBlock as setUniformBlock\n   * @borrows module:twgl/programs.setBlockUniforms as setBlockUniforms\n   * @borrows module:twgl/programs.setUniforms as setUniforms\n   * @borrows module:twgl/programs.setBuffersAndAttributes as setBuffersAndAttributes\n   * @borrows module:twgl/textures.setTextureFromArray as setTextureFromArray\n   * @borrows module:twgl/textures.createTexture as createTexture\n   * @borrows module:twgl/textures.resizeTexture as resizeTexture\n   * @borrows module:twgl/textures.createTextures as createTextures\n   */\n\n  // make sure we don't see a global gl\n  var gl = undefined;  // eslint-disable-line\n  var defaults = {\n    enableVertexArrayObjects: true,\n  };\n\n  /**\n   * Various default settings for twgl.\n   *\n   * Note: You can call this any number of times. Example:\n   *\n   *     twgl.setDefaults({ textureColor: [1, 0, 0, 1] });\n   *     twgl.setDefaults({ attribPrefix: 'a_' });\n   *\n   * is equivalent to\n   *\n   *     twgl.setDefaults({\n   *       textureColor: [1, 0, 0, 1],\n   *       attribPrefix: 'a_',\n   *     });\n   *\n   * @typedef {Object} Defaults\n   * @property {string} attribPrefix The prefix to stick on attributes\n   *\n   *   When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`\n   *   as it makes it clear where they came from. But, when building geometry I prefer using unprefixed names.\n   *\n   *   In otherwords I'll create arrays of geometry like this\n   *\n   *       var arrays = {\n   *         position: ...\n   *         normal: ...\n   *         texcoord: ...\n   *       };\n   *\n   *   But need those mapped to attributes and my attributes start with `a_`.\n   *\n   *   Default: `\"\"`\n   *\n   * @property {number[]} textureColor Array of 4 values in the range 0 to 1\n   *\n   *   The default texture color is used when loading textures from\n   *   urls. Because the URL will be loaded async we'd like to be\n   *   able to use the texture immediately. By putting a 1x1 pixel\n   *   color in the texture we can start using the texture before\n   *   the URL has loaded.\n   *\n   *   Default: `[0.5, 0.75, 1, 1]`\n   *\n   * @property {string} crossOrigin\n   *\n   *   If not undefined sets the crossOrigin attribute on images\n   *   that twgl creates when downloading images for textures.\n   *\n   *   Also see {@link module:twgl.TextureOptions}.\n   *\n   * @property {bool} enableVertexArrayObjects\n   *\n   *   If true then in WebGL 1.0 will attempt to get the `OES_vertex_array_object` extension.\n   *   If successful it will copy create/bind/delete/isVertexArrayOES from the extension to\n   *   the WebGLRenderingContext removing the OES at the end which is the standard entry point\n   *   for WebGL 2.\n   *\n   *   Note: According to webglstats.com 90% of devices support `OES_vertex_array_object`.\n   *   If you just want to count on support I suggest using [this polyfill](https://github.com/KhronosGroup/WebGL/blob/master/sdk/demos/google/resources/OESVertexArrayObject.js)\n   *   or ignoring devices that don't support them.\n   *\n   *   Default: `true`\n   *\n   * @memberOf module:twgl\n   */\n\n  /**\n   * Sets various defaults for twgl.\n   *\n   * In the interest of terseness which is kind of the point\n   * of twgl I've integrated a few of the older functions here\n   *\n   * @param {module:twgl.Defaults} newDefaults The default settings.\n   * @memberOf module:twgl\n   */\n  function setDefaults(newDefaults) {\n    utils.copyExistingProperties(newDefaults, defaults);\n    attributes.setDefaults_(newDefaults);  // eslint-disable-line\n    textures.setDefaults_(newDefaults);  // eslint-disable-line\n  }\n\n  /**\n   * Adds Vertex Array Objects to WebGL 1 GL contexts if available\n   * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n   */\n  function addVertexArrayObjectSupport(gl) {\n    if (!gl || !defaults.enableVertexArrayObjects) {\n      return;\n    }\n    if (utils.isWebGL1(gl)) {\n      var ext = gl.getExtension(\"OES_vertex_array_object\");\n      if (ext) {\n        gl.createVertexArray = function() {\n          return ext.createVertexArrayOES();\n        };\n        gl.deleteVertexArray = function(v) {\n          ext.deleteVertexArrayOES(v);\n        };\n        gl.isVertexArray = function(v) {\n          return ext.isVertexArrayOES(v);\n        };\n        gl.bindVertexArray = function(v) {\n          ext.bindVertexArrayOES(v);\n        };\n        gl.VERTEX_ARRAY_BINDING = ext.VERTEX_ARRAY_BINDING_OES;\n      }\n    }\n  }\n\n  /**\n   * Creates a webgl context.\n   * @param {HTMLCanvasElement} canvas The canvas tag to get\n   *     context from. If one is not passed in one will be\n   *     created.\n   * @return {WebGLRenderingContext} The created context.\n   */\n  function create3DContext(canvas, opt_attribs) {\n    var names = [\"webgl\", \"experimental-webgl\"];\n    var context = null;\n    for (var ii = 0; ii < names.length; ++ii) {\n      try {\n        context = canvas.getContext(names[ii], opt_attribs);\n      } catch(e) {}  // eslint-disable-line\n      if (context) {\n        break;\n      }\n    }\n    return context;\n  }\n\n  /**\n   * Gets a WebGL context.\n   * @param {HTMLCanvasElement} canvas a canvas element.\n   * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes\n   * @memberOf module:twgl\n   */\n  function getWebGLContext(canvas, opt_attribs) {\n    var gl = create3DContext(canvas, opt_attribs);\n    addVertexArrayObjectSupport(gl);\n    return gl;\n  }\n\n  /**\n   * Creates a webgl context.\n   *\n   * Will return a WebGL2 context if possible.\n   *\n   * You can check if it's WebGL2 with\n   *\n   *     twgl.isWebGL2(gl);\n   *\n   * @param {HTMLCanvasElement} canvas The canvas tag to get\n   *     context from. If one is not passed in one will be\n   *     created.\n   * @return {WebGLRenderingContext} The created context.\n   */\n  function createContext(canvas, opt_attribs) {\n    var names = [\"webgl2\", \"experimental-webgl2\", \"webgl\", \"experimental-webgl\"];\n    var context = null;\n    for (var ii = 0; ii < names.length; ++ii) {\n      try {\n        context = canvas.getContext(names[ii], opt_attribs);\n      } catch(e) {}  // eslint-disable-line\n      if (context) {\n        break;\n      }\n    }\n    return context;\n  }\n\n  /**\n   * Gets a WebGL context.  Will create a WebGL2 context if possible.\n   *\n   * You can check if it's WebGL2 with\n   *\n   *    function isWebGL2(gl) {\n   *      return gl.getParameter(gl.VERSION).indexOf(\"WebGL 2.0 \") == 0;\n   *    }\n   *\n   * @param {HTMLCanvasElement} canvas a canvas element.\n   * @param {WebGLContextCreationAttirbutes} [opt_attribs] optional webgl context creation attributes\n   * @return {WebGLRenderingContext} The created context.\n   * @memberOf module:twgl\n   */\n  function getContext(canvas, opt_attribs) {\n    var gl = createContext(canvas, opt_attribs);\n    addVertexArrayObjectSupport(gl);\n    return gl;\n  }\n\n  /**\n   * Resize a canvas to match the size it's displayed.\n   * @param {HTMLCanvasElement} canvas The canvas to resize.\n   * @param {number} [multiplier] So you can pass in `window.devicePixelRatio` if you want to.\n   * @return {boolean} true if the canvas was resized.\n   * @memberOf module:twgl\n   */\n  function resizeCanvasToDisplaySize(canvas, multiplier) {\n    multiplier = multiplier || 1;\n    multiplier = Math.max(1, multiplier);\n    var width  = canvas.clientWidth  * multiplier | 0;\n    var height = canvas.clientHeight * multiplier | 0;\n    if (canvas.width !== width ||\n        canvas.height !== height) {\n      canvas.width = width;\n      canvas.height = height;\n      return true;\n    }\n    return false;\n  }\n\n  // Using quotes prevents Uglify from changing the names.\n  // No speed diff AFAICT.\n  var api = {\n    \"getContext\": getContext,\n    \"getWebGLContext\": getWebGLContext,\n    \"isWebGL1\": utils.isWebGL1,\n    \"isWebGL2\": utils.isWebGL2,\n    \"resizeCanvasToDisplaySize\": resizeCanvasToDisplaySize,\n    \"setDefaults\": setDefaults,\n  };\n\n  function notPrivate(name) {\n    return name[name.length - 1] !== '_';\n  }\n\n  function copyPublicProperties(src, dst) {\n    Object.keys(src).filter(notPrivate).forEach(function(key) {\n      dst[key] = src[key];\n    });\n    return dst;\n  }\n\n  var apis = {\n    attributes: attributes,\n    draw: draw,\n    framebuffers: framebuffers,\n    programs: programs,\n    textures: textures,\n    typedArrays: typedArrays,\n  };\n  Object.keys(apis).forEach(function(name) {\n    var srcApi = apis[name];\n    copyPublicProperties(srcApi, api);\n    api[name] = copyPublicProperties(srcApi, {});\n  });\n\n  return api;\n\n});\n\n\ndefine('main', [\n    'twgl/twgl',\n  ], function(\n    twgl\n  ) {\n    return twgl;\n})\n\nnotrequirebecasebrowserifymessesup(['main'], function(main) {\n  return main;\n}, undefined, true);   // forceSync = true\n\n\n\n\n;\ndefine(\"build/js/twgl-includer\", function(){});\n\n    return notrequirebecasebrowserifymessesup('main');\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/twgl-base.js/dist/2.x/twgl.js\n// module id = 41\n// module chunks = 0"],"sourceRoot":""}